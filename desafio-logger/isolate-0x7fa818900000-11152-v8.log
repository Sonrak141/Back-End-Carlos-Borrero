v8-version,9,5,172,21,-node.12,0
v8-platform,macos,macos
shared-library,/usr/local/bin/node,0x10c0e13c0,0x10cc904f4,202219520
shared-library,/usr/lib/libz.1.dylib,0x7fff2a49b2d0,0x7fff2a4a6bf5,503808
shared-library,/usr/local/opt/libuv/lib/libuv.1.dylib,0x10e553a20,0x10e56a6fc,4535427072
shared-library,/usr/local/opt/brotli/lib/libbrotlidec.1.dylib,0x10e58cd64,0x10e59342d,4535652352
shared-library,/usr/local/opt/brotli/lib/libbrotlienc.1.dylib,0x10e5a7edc,0x10e5e3c6e,4535767040
shared-library,/usr/local/opt/c-ares/lib/libcares.2.dylib,0x10e6420f4,0x10e64d631,4536393728
shared-library,/usr/local/opt/libnghttp2/lib/libnghttp2.14.dylib,0x10e663dc4,0x10e6743f2,4536532992
shared-library,/usr/local/opt/openssl@1.1/lib/libcrypto.1.1.dylib,0x10e694000,0x10e80b648,4536737792
shared-library,/usr/local/opt/openssl@1.1/lib/libssl.1.1.dylib,0x10e8f19ac,0x10e934b4b,4539219968
shared-library,/usr/local/opt/icu4c/lib/libicui18n.69.dylib,0x10e970ff0,0x10eac676a,4539736064
shared-library,/usr/local/opt/icu4c/lib/libicuuc.69.dylib,0x10ec12270,0x10ecd64ee,4542484480
shared-library,/usr/local/opt/icu4c/lib/libicudata.69.dylib,0x10edacd30,0x10edacd30,4544180224
shared-library,/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation,0x7fff20402510,0x7fff205beaf1,503808
shared-library,/usr/lib/libc++.1.dylib,0x7fff202eba70,0x7fff20333200,503808
shared-library,/usr/lib/libSystem.B.dylib,0x7fff2a563511,0x7fff2a563a1e,503808
shared-library,/usr/lib/system/libcache.dylib,0x7fff2a55d85c,0x7fff2a5603ac,503808
shared-library,/usr/lib/system/libcommonCrypto.dylib,0x7fff2a518a00,0x7fff2a52282c,503808
shared-library,/usr/lib/system/libcompiler_rt.dylib,0x7fff2a542f28,0x7fff2a547a25,503808
shared-library,/usr/lib/system/libcopyfile.dylib,0x7fff2a538780,0x7fff2a540040,503808
shared-library,/usr/lib/system/libcorecrypto.dylib,0x7fff20112780,0x7fff2018dcad,503808
shared-library,/usr/lib/system/libdispatch.dylib,0x7fff201ddde0,0x7fff202111a4,503808
shared-library,/usr/lib/system/libdyld.dylib,0x7fff20390330,0x7fff203c16a0,503808
shared-library,/usr/lib/system/libkeymgr.dylib,0x7fff2a553a61,0x7fff2a553e90,503808
shared-library,/usr/lib/system/liblaunch.dylib,0x7fff2d966fc0,0x7fff2d966fc0,503808
shared-library,/usr/lib/system/libmacho.dylib,0x7fff2a4f745c,0x7fff2a4fb95c,503808
shared-library,/usr/lib/system/libquarantine.dylib,0x7fff29cef019,0x7fff29cf0bd0,503808
shared-library,/usr/lib/system/libremovefile.dylib,0x7fff2a551770,0x7fff2a552bdb,503808
shared-library,/usr/lib/system/libsystem_asl.dylib,0x7fff24bf4df8,0x7fff24c0907d,503808
shared-library,/usr/lib/system/libsystem_blocks.dylib,0x7fff200c227c,0x7fff200c27e8,503808
shared-library,/usr/lib/system/libsystem_c.dylib,0x7fff2025fab0,0x7fff202deb59,503808
shared-library,/usr/lib/system/libsystem_collections.dylib,0x7fff2a54aa95,0x7fff2a54cb80,503808
shared-library,/usr/lib/system/libsystem_configuration.dylib,0x7fff28ff4e5c,0x7fff28ff76c0,503808
shared-library,/usr/lib/system/libsystem_containermanager.dylib,0x7fff282e0ce0,0x7fff282ed0de,503808
shared-library,/usr/lib/system/libsystem_coreservices.dylib,0x7fff2a29a440,0x7fff2a29d2d0,503808
shared-library,/usr/lib/system/libsystem_darwin.dylib,0x7fff227d1210,0x7fff227d70d3,503808
shared-library,/usr/lib/system/libsystem_dnssd.dylib,0x7fff2a554df4,0x7fff2a55a0bc,503808
shared-library,/usr/lib/system/libsystem_featureflags.dylib,0x7fff2025c500,0x7fff2025dc60,503808
shared-library,/usr/lib/system/libsystem_info.dylib,0x7fff203d6530,0x7fff203fc130,503808
shared-library,/usr/lib/system/libsystem_m.dylib,0x7fff2a4ae240,0x7fff2a4da38f,503808
shared-library,/usr/lib/system/libsystem_malloc.dylib,0x7fff201b03b0,0x7fff201d2e30,503808
shared-library,/usr/lib/system/libsystem_networkextension.dylib,0x7fff24b882ba,0x7fff24b9325e,503808
shared-library,/usr/lib/system/libsystem_notify.dylib,0x7fff22beffbc,0x7fff22bf9b9d,503808
shared-library,/usr/lib/system/libsystem_product_info_filter.dylib,0x7fff2fdfe000,0x7fff2fdfe000,503808
shared-library,/usr/lib/system/libsystem_sandbox.dylib,0x7fff28ff8b0c,0x7fff28ffc26c,503808
shared-library,/usr/lib/system/libsystem_secinit.dylib,0x7fff2a54dcad,0x7fff2a54f25e,503808
shared-library,/usr/lib/system/libsystem_kernel.dylib,0x7fff20353fc0,0x7fff20378797,503808
shared-library,/usr/lib/system/libsystem_platform.dylib,0x7fff203cbea0,0x7fff203d2686,503808
shared-library,/usr/lib/system/libsystem_pthread.dylib,0x7fff20384540,0x7fff2038ca1e,503808
shared-library,/usr/lib/system/libsystem_symptoms.dylib,0x7fff262d1edb,0x7fff262d73ee,503808
shared-library,/usr/lib/system/libsystem_trace.dylib,0x7fff200facf0,0x7fff2010dab3,503808
shared-library,/usr/lib/system/libunwind.dylib,0x7fff2a5294e0,0x7fff2a52e3da,503808
shared-library,/usr/lib/system/libxpc.dylib,0x7fff200c4e30,0x7fff200eab2e,503808
shared-library,/usr/lib/libc++abi.dylib,0x7fff2033e460,0x7fff2034fcc4,503808
shared-library,/usr/lib/libobjc.A.dylib,0x7fff20222b80,0x7fff20248d4f,503808
shared-library,/usr/lib/liboah.dylib,0x7fff2a530350,0x7fff2a535d2a,503808
shared-library,/usr/local/opt/brotli/lib/libbrotlicommon.1.dylib,0x11090c0b2,0x11090c4b0,4572884992
shared-library,/usr/lib/libresolv.9.dylib,0x7fff2cdfad40,0x7fff2ce10803,503808
shared-library,/usr/lib/libfakelink.dylib,0x7fff2a564dc0,0x7fff2a567bc8,503808
shared-library,/usr/lib/libicucore.A.dylib,0x7fff225711d0,0x7fff2276344a,503808
shared-library,/System/Library/PrivateFrameworks/SoftLinking.framework/Versions/A/SoftLinking,0x7fff2a568ef8,0x7fff2a568f4e,503808
shared-library-end
profiler,begin,1000
tick,0x7fff203542f6,1181,0,0x0,6
new,CodeRange,0x1142ba000,0
new,MemoryChunk,0x24b386900000,262144
tick,0x10c8557db,2156,0,0x0,6
new,MemoryChunk,0x24b35f580000,262144
new,MemoryChunk,0x24b3c1180000,262144
new,MemoryChunk,0x24b3375c0000,262144
new,MemoryChunk,0x24b375c00000,262144
heap-capacity,1031072
heap-available,4346066752
new,MemoryChunk,0x24b3c0580000,262144
new,MemoryChunk,0x24b39d980000,262144
new,MemoryChunk,0x24b360880000,262144
tick,0x10c8557d8,3424,0,0x0,6
new,MemoryChunk,0x24b3bc580000,262144
new,MemoryChunk,0x24b3a2c00000,262144
new,MemoryChunk,0x24b3cf280000,262144
new,MemoryChunk,0x24b381140000,262144
new,MemoryChunk,0x1142c0000,262144
tick,0x10c8575ba,4743,0,0x0,6
new,MemoryChunk,0x24b36b1c0000,262144
tick,0x10c483f25,6042,0,0x0,6
code-creation,Builtin,2,7094,0x10c0e1400,800,DeoptimizationEntry_Eager
code-creation,Builtin,2,7127,0x10c0e1740,804,DeoptimizationEntry_Soft
code-creation,Builtin,2,7135,0x10c0e1a80,804,DeoptimizationEntry_Bailout
code-creation,Builtin,2,7143,0x10c0e1dc0,804,DeoptimizationEntry_Lazy
code-creation,Builtin,2,7151,0x10c0e2100,88,DynamicCheckMapsTrampoline
code-creation,Builtin,2,7159,0x10c0e2180,88,DynamicCheckMapsWithFeedbackVectorTrampoline
code-creation,Builtin,2,7167,0x10c0e2200,1368,RecordWriteEmitRememberedSetSaveFP
code-creation,Builtin,2,7177,0x10c0e2780,464,RecordWriteOmitRememberedSetSaveFP
code-creation,Builtin,2,7185,0x10c0e2980,648,RecordWriteEmitRememberedSetIgnoreFP
code-creation,Builtin,2,7193,0x10c0e2c40,220,RecordWriteOmitRememberedSetIgnoreFP
code-creation,Builtin,2,7201,0x10c0e2d40,364,EphemeronKeyBarrierSaveFP
code-creation,Builtin,2,7208,0x10c0e2ec0,128,EphemeronKeyBarrierIgnoreFP
code-creation,Builtin,2,7219,0x10c0e2f80,100,AdaptorWithBuiltinExitFrame
code-creation,Builtin,2,7235,0x10c0e3000,368,CallFunction_ReceiverIsNullOrUndefined
code-creation,Builtin,2,7243,0x10c0e3180,420,CallFunction_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,7292,0x10c0e3340,456,CallFunction_ReceiverIsAny
code-creation,Builtin,2,7313,0x10c0e3540,104,CallBoundFunction
code-creation,Builtin,2,7321,0x10c0e35c0,120,Call_ReceiverIsNullOrUndefined
code-creation,Builtin,2,7329,0x10c0e3640,120,Call_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,7337,0x10c0e36c0,120,Call_ReceiverIsAny
code-creation,Builtin,2,7344,0x10c0e3740,988,Call_ReceiverIsNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,7352,0x10c0e3b40,984,Call_ReceiverIsNullOrUndefined_Baseline
code-creation,Builtin,2,7360,0x10c0e3f40,1068,Call_ReceiverIsNotNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,7370,0x10c0e4380,1064,Call_ReceiverIsNotNullOrUndefined_Baseline
code-creation,Builtin,2,7381,0x10c0e47c0,1068,Call_ReceiverIsAny_Baseline_Compact
code-creation,Builtin,2,7408,0x10c0e4c00,1064,Call_ReceiverIsAny_Baseline
code-creation,Builtin,2,7416,0x10c0e5040,936,Call_ReceiverIsNullOrUndefined_WithFeedback
code-creation,Builtin,2,7424,0x10c0e5400,936,Call_ReceiverIsNotNullOrUndefined_WithFeedback
code-creation,Builtin,2,7433,0x10c0e57c0,936,Call_ReceiverIsAny_WithFeedback
code-creation,Builtin,2,7461,0x10c0e5b80,748,CallProxy
code-creation,Builtin,2,7499,0x10c0e5e80,156,CallVarargs
code-creation,Builtin,2,7505,0x10c0e5f40,952,CallWithSpread
code-creation,Builtin,2,7519,0x10c0e6300,1952,CallWithSpread_Baseline
code-creation,Builtin,2,7528,0x10c0e6ac0,1924,CallWithSpread_WithFeedback
code-creation,Builtin,2,7537,0x10c0e7280,868,CallWithArrayLike
code-creation,Builtin,2,7546,0x10c0e7600,1812,CallWithArrayLike_WithFeedback
code-creation,Builtin,2,7556,0x10c0e7d40,156,CallForwardVarargs
code-creation,Builtin,2,7565,0x10c0e7e00,156,CallFunctionForwardVarargs
code-creation,Builtin,2,7572,0x10c0e7ec0,132,CallFunctionTemplate_CheckAccess
code-creation,Builtin,2,7582,0x10c0e7f80,232,CallFunctionTemplate_CheckCompatibleReceiver
code-creation,Builtin,2,7592,0x10c0e8080,320,CallFunctionTemplate_CheckAccessAndCompatibleReceiver
code-creation,Builtin,2,7603,0x10c0e8200,32,ConstructFunction
code-creation,Builtin,2,7612,0x10c0e8240,104,ConstructBoundFunction
code-creation,Builtin,2,7621,0x10c0e82c0,28,ConstructedNonConstructable
code-creation,Builtin,2,7630,0x10c0e8300,100,Construct
code-creation,Builtin,2,7640,0x10c0e8380,156,ConstructVarargs
code-creation,Builtin,2,7648,0x10c0e8440,976,ConstructWithSpread
code-creation,Builtin,2,7658,0x10c0e8840,1752,ConstructWithSpread_Baseline
code-creation,Builtin,2,7672,0x10c0e8f40,1768,ConstructWithSpread_WithFeedback
code-creation,Builtin,2,7685,0x10c0e9640,928,ConstructWithArrayLike
code-creation,Builtin,2,7698,0x10c0e9a00,1652,ConstructWithArrayLike_WithFeedback
code-creation,Builtin,2,7711,0x10c0ea080,196,ConstructForwardVarargs
code-creation,Builtin,2,7724,0x10c0ea180,196,ConstructFunctionForwardVarargs
code-creation,Builtin,2,7738,0x10c0ea280,792,Construct_Baseline
code-creation,Builtin,2,7753,0x10c0ea5c0,812,Construct_WithFeedback
code-creation,Builtin,2,7765,0x10c0ea900,488,JSConstructStubGeneric
code-creation,Builtin,2,7778,0x10c0eab00,384,JSBuiltinsConstructStub
code-creation,Builtin,2,7788,0x10c0eacc0,688,FastNewObject
code-creation,Builtin,2,7797,0x10c0eaf80,300,FastNewClosure
code-creation,Builtin,2,7806,0x10c0eb0c0,732,ConstructProxy
code-creation,Builtin,2,7815,0x10c0eb3c0,192,JSEntry
code-creation,Builtin,2,7824,0x10c0eb4c0,192,JSConstructEntry
code-creation,Builtin,2,7833,0x10c0eb5c0,192,JSRunMicrotasksEntry
code-creation,Builtin,2,7843,0x10c0eb6c0,96,JSEntryTrampoline
code-creation,Builtin,2,7852,0x10c0eb740,96,JSConstructEntryTrampoline
code-creation,Builtin,2,7862,0x10c0eb7c0,284,ResumeGeneratorTrampoline
code-creation,Builtin,2,7872,0x10c0eb900,1124,StringCodePointAt
code-creation,Builtin,2,7885,0x10c0ebd80,1560,StringFromCodePointAt
code-creation,Builtin,2,7894,0x10c0ec3c0,560,StringEqual
tick,0x7fff203572be,7907,0,0x0,6
code-creation,Builtin,2,7930,0x10c0ec600,296,StringGreaterThan
code-creation,Builtin,2,7945,0x10c0ec740,296,StringGreaterThanOrEqual
code-creation,Builtin,2,7952,0x10c0ec880,296,StringLessThan
code-creation,Builtin,2,7959,0x10c0ec9c0,296,StringLessThanOrEqual
code-creation,Builtin,2,7966,0x10c0ecb00,2528,StringSubstring
code-creation,Builtin,2,7973,0x10c0ed500,80,OrderedHashTableHealIndex
code-creation,Builtin,2,7980,0x10c0ed580,1172,InterpreterEntryTrampoline
code-creation,Builtin,2,7988,0x10c0eda40,76,InterpreterPushArgsThenCall
code-creation,Builtin,2,7995,0x10c0edac0,84,InterpreterPushUndefinedAndArgsThenCall
code-creation,Builtin,2,8003,0x10c0edb40,84,InterpreterPushArgsThenCallWithFinalSpread
code-creation,Builtin,2,8011,0x10c0edbc0,80,InterpreterPushArgsThenConstruct
code-creation,Builtin,2,8019,0x10c0edc40,80,InterpreterPushArgsThenConstructArrayFunction
code-creation,Builtin,2,8027,0x10c0edcc0,84,InterpreterPushArgsThenConstructWithFinalSpread
code-creation,Builtin,2,8035,0x10c0edd40,84,InterpreterEnterAtBytecode
code-creation,Builtin,2,8059,0x10c0eddc0,220,InterpreterEnterAtNextBytecode
code-creation,Builtin,2,8067,0x10c0edec0,52,InterpreterOnStackReplacement
code-creation,Builtin,2,8074,0x10c0edf00,596,BaselineOutOfLinePrologue
code-creation,Builtin,2,8081,0x10c0ee180,56,BaselineOnStackReplacement
code-creation,Builtin,2,8089,0x10c0ee1c0,84,BaselineLeaveFrame
code-creation,Builtin,2,8096,0x10c0ee240,220,BaselineOrInterpreterEnterAtBytecode
code-creation,Builtin,2,8103,0x10c0ee340,228,BaselineOrInterpreterEnterAtNextBytecode
code-creation,Builtin,2,8111,0x10c0ee440,192,InterpreterOnStackReplacement_ToBaseline
code-creation,Builtin,2,8119,0x10c0ee540,1004,CompileLazy
code-creation,Builtin,2,8127,0x10c0ee940,72,CompileLazyDeoptimizedCode
code-creation,Builtin,2,8135,0x10c0ee9c0,272,InstantiateAsmJs
code-creation,Builtin,2,8142,0x10c0eeb00,32,NotifyDeoptimized
code-creation,Builtin,2,8149,0x10c0eeb40,52,ContinueToCodeStubBuiltin
code-creation,Builtin,2,8156,0x10c0eeb80,60,ContinueToCodeStubBuiltinWithResult
code-creation,Builtin,2,8164,0x10c0eebc0,56,ContinueToJavaScriptBuiltin
code-creation,Builtin,2,8171,0x10c0eec00,64,ContinueToJavaScriptBuiltinWithResult
code-creation,Builtin,2,8179,0x10c0eec80,292,CallApiCallback
code-creation,Builtin,2,8186,0x10c0eedc0,276,CallApiGetter
code-creation,Builtin,2,8192,0x10c0eef00,12,HandleApiCall
code-creation,Builtin,2,8199,0x10c0eef40,12,HandleApiCallAsFunction
code-creation,Builtin,2,8206,0x10c0eef80,12,HandleApiCallAsConstructor
code-creation,Builtin,2,8213,0x10c0eefc0,64,AllocateInYoungGeneration
code-creation,Builtin,2,8222,0x10c0ef040,52,AllocateRegularInYoungGeneration
code-creation,Builtin,2,8230,0x10c0ef080,64,AllocateInOldGeneration
code-creation,Builtin,2,8237,0x10c0ef100,52,AllocateRegularInOldGeneration
code-creation,Builtin,2,8244,0x10c0ef140,436,CopyFastSmiOrObjectElements
code-creation,Builtin,2,8252,0x10c0ef300,496,GrowFastDoubleElements
code-creation,Builtin,2,8259,0x10c0ef500,404,GrowFastSmiOrObjectElements
code-creation,Builtin,2,8266,0x10c0ef6c0,392,DebugBreakTrampoline
code-creation,Builtin,2,8273,0x10c0ef880,180,ToNumber
code-creation,Builtin,2,8280,0x10c0ef940,292,ToNumber_Baseline
code-creation,Builtin,2,8286,0x10c0efa80,360,ToNumeric_Baseline
code-creation,Builtin,2,8295,0x10c0efc00,104,PlainPrimitiveToNumber
code-creation,Builtin,2,8303,0x10c0efc80,212,ToNumberConvertBigInt
code-creation,Builtin,2,8318,0x10c0efd80,132,Typeof
code-creation,Builtin,2,8325,0x10c0efe40,104,BigIntToI64
code-creation,Builtin,2,8331,0x10c0efec0,4,BigIntToI32Pair
code-creation,Builtin,2,8338,0x10c0eff00,232,I64ToBigInt
code-creation,Builtin,2,8345,0x10c0f0000,4,I32PairToBigInt
code-creation,Builtin,2,8352,0x10c0f0040,112,ToBooleanLazyDeoptContinuation
code-creation,Builtin,2,8360,0x10c0f00c0,4304,KeyedLoadIC_PolymorphicName
code-creation,Builtin,2,8367,0x10c0f11c0,15820,KeyedStoreIC_Megamorphic
code-creation,Builtin,2,8374,0x10c0f4fc0,280,LoadGlobalIC_NoFeedback
code-creation,Builtin,2,8382,0x10c0f5100,68,LoadIC_FunctionPrototype
code-creation,Builtin,2,8389,0x10c0f5180,12,LoadIC_StringLength
code-creation,Builtin,2,8396,0x10c0f51c0,16,LoadIC_StringWrapperLength
code-creation,Builtin,2,8404,0x10c0f5200,3128,LoadIC_NoFeedback
code-creation,Builtin,2,8411,0x10c0f5e40,32,StoreGlobalIC_Slow
code-creation,Builtin,2,8418,0x10c0f5e80,7336,StoreIC_NoFeedback
code-creation,Builtin,2,8425,0x10c0f7b40,184,KeyedLoadIC_SloppyArguments
code-creation,Builtin,2,8433,0x10c0f7c00,72,LoadIndexedInterceptorIC
code-creation,Builtin,2,8441,0x10c0f7c80,244,KeyedStoreIC_SloppyArguments_Standard
code-creation,Builtin,2,8449,0x10c0f7d80,244,KeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW
code-creation,Builtin,2,8461,0x10c0f7e80,244,KeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB
code-creation,Builtin,2,8470,0x10c0f7f80,244,KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW
code-creation,Builtin,2,8483,0x10c0f8080,14052,StoreFastElementIC_Standard
code-creation,Builtin,2,8491,0x10c0fb780,9768,StoreFastElementIC_GrowNoTransitionHandleCOW
code-creation,Builtin,2,8503,0x10c0fddc0,13232,StoreFastElementIC_NoTransitionIgnoreOOB
code-creation,Builtin,2,8541,0x10c101180,6236,StoreFastElementIC_NoTransitionHandleCOW
code-creation,Builtin,2,8552,0x10c102a00,8528,ElementsTransitionAndStore_Standard
code-creation,Builtin,2,8560,0x10c104b80,19500,ElementsTransitionAndStore_GrowNoTransitionHandleCOW
code-creation,Builtin,2,8568,0x10c1097c0,8528,ElementsTransitionAndStore_NoTransitionIgnoreOOB
code-creation,Builtin,2,8577,0x10c10b940,11136,ElementsTransitionAndStore_NoTransitionHandleCOW
code-creation,Builtin,2,8586,0x10c10e500,828,KeyedHasIC_PolymorphicName
code-creation,Builtin,2,8593,0x10c10e840,172,KeyedHasIC_SloppyArguments
code-creation,Builtin,2,8604,0x10c10e900,72,HasIndexedInterceptorIC
code-creation,Builtin,2,8613,0x10c10e980,264,DynamicCheckMaps
code-creation,Builtin,2,8623,0x10c10eac0,224,DynamicCheckMapsWithFeedbackVector
code-creation,Builtin,2,8633,0x10c10ebc0,172,EnqueueMicrotask
code-creation,Builtin,2,8643,0x10c10ec80,8,RunMicrotasksTrampoline
code-creation,Builtin,2,8652,0x10c10ecc0,3628,RunMicrotasks
code-creation,Builtin,2,8662,0x10c10fb00,2688,HasProperty
code-creation,Builtin,2,8672,0x10c1105c0,1180,DeleteProperty
code-creation,Builtin,2,8681,0x10c110a80,2000,CopyDataProperties
code-creation,Builtin,2,8690,0x10c111280,9232,SetDataProperties
code-creation,Builtin,2,8699,0x10c1136c0,28,Abort
code-creation,Builtin,2,8708,0x10c113700,28,AbortCSAAssert
code-creation,Builtin,2,8719,0x10c113740,12,EmptyFunction
code-creation,Builtin,2,8726,0x10c113780,12,Illegal
code-creation,Builtin,2,8735,0x10c1137c0,12,StrictPoisonPillThrower
code-creation,Builtin,2,8743,0x10c113800,12,UnsupportedThrower
code-creation,Builtin,2,8750,0x10c113840,64,ReturnReceiver
code-creation,Builtin,2,8757,0x10c1138c0,36,ArrayConstructor
code-creation,Builtin,2,8764,0x10c113900,416,ArrayConstructorImpl
code-creation,Builtin,2,8772,0x10c113ac0,220,ArrayNoArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,8782,0x10c113bc0,220,ArrayNoArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,8794,0x10c113cc0,180,ArrayNoArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,8805,0x10c113d80,180,ArrayNoArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,8815,0x10c113e40,180,ArrayNoArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,8824,0x10c113f00,180,ArrayNoArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,8833,0x10c113fc0,192,ArrayNoArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,8842,0x10c1140c0,192,ArrayNoArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,8851,0x10c1141c0,520,ArraySingleArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,8859,0x10c114400,484,ArraySingleArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,8871,0x10c114600,444,ArraySingleArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,8882,0x10c1147c0,408,ArraySingleArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,8891,0x10c114980,444,ArraySingleArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,8900,0x10c114b40,408,ArraySingleArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,8910,0x10c114d00,452,ArraySingleArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,8919,0x10c114f00,416,ArraySingleArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,8929,0x10c1150c0,64,ArrayNArgumentsConstructor
code-creation,Builtin,2,8937,0x10c115140,12,ArrayConcat
code-creation,Builtin,2,8946,0x10c115180,12,ArrayPrototypeFill
code-creation,Builtin,2,8956,0x10c1151c0,952,ArrayIncludesSmiOrObject
code-creation,Builtin,2,8965,0x10c115580,148,ArrayIncludesPackedDoubles
code-creation,Builtin,2,8975,0x10c115640,220,ArrayIncludesHoleyDoubles
code-creation,Builtin,2,8984,0x10c115740,560,ArrayIncludes
code-creation,Builtin,2,8993,0x10c115980,860,ArrayIndexOfSmiOrObject
code-creation,Builtin,2,9002,0x10c115d00,116,ArrayIndexOfPackedDoubles
code-creation,Builtin,2,9023,0x10c115d80,116,ArrayIndexOfHoleyDoubles
code-creation,Builtin,2,9030,0x10c115e00,560,ArrayIndexOf
code-creation,Builtin,2,9037,0x10c116040,12,ArrayPop
code-creation,Builtin,2,9044,0x10c116080,628,ArrayPrototypePop
code-creation,Builtin,2,9051,0x10c116300,12,ArrayPush
code-creation,Builtin,2,9057,0x10c116340,2432,ArrayPrototypePush
code-creation,Builtin,2,9064,0x10c116d00,12,ArrayShift
code-creation,Builtin,2,9071,0x10c116d40,12,ArrayUnshift
code-creation,Builtin,2,9077,0x10c116d80,964,CloneFastJSArray
code-creation,Builtin,2,9086,0x10c117180,2236,CloneFastJSArrayFillingHoles
code-creation,Builtin,2,9095,0x10c117a40,992,ExtractFastJSArray
code-creation,Builtin,2,9102,0x10c117e40,260,ArrayPrototypeEntries
code-creation,Builtin,2,9110,0x10c117f80,248,ArrayPrototypeKeys
code-creation,Builtin,2,9117,0x10c118080,260,ArrayPrototypeValues
code-creation,Builtin,2,9124,0x10c1181c0,4488,ArrayIteratorPrototypeNext
code-creation,Builtin,2,9131,0x10c119380,4228,FlattenIntoArray
code-creation,Builtin,2,9138,0x10c11a440,4232,FlatMapIntoArray
code-creation,Builtin,2,9145,0x10c11b500,384,ArrayPrototypeFlat
code-creation,Builtin,2,9152,0x10c11b6c0,436,ArrayPrototypeFlatMap
code-creation,Builtin,2,9159,0x10c11b880,12,ArrayBufferConstructor
code-creation,Builtin,2,9168,0x10c11b8c0,12,ArrayBufferConstructor_DoNotInitialize
code-creation,Builtin,2,9179,0x10c11b900,12,ArrayBufferPrototypeSlice
code-creation,Builtin,2,9188,0x10c11b940,12,ArrayBufferPrototypeResize
code-creation,Builtin,2,9198,0x10c11b980,816,AsyncFunctionEnter
code-creation,Builtin,2,9207,0x10c11bcc0,136,AsyncFunctionReject
code-creation,Builtin,2,9216,0x10c11bd80,128,AsyncFunctionResolve
code-creation,Builtin,2,9225,0x10c11be40,12,AsyncFunctionLazyDeoptContinuation
code-creation,Builtin,2,9234,0x10c11be80,2836,AsyncFunctionAwaitCaught
code-creation,Builtin,2,9242,0x10c11c9c0,2836,AsyncFunctionAwaitUncaught
code-creation,Builtin,2,9250,0x10c11d500,172,AsyncFunctionAwaitRejectClosure
code-creation,Builtin,2,9257,0x10c11d5c0,164,AsyncFunctionAwaitResolveClosure
code-creation,Builtin,2,9266,0x10c11d680,12,BigIntConstructor
code-creation,Builtin,2,9279,0x10c11d6c0,12,BigIntAsUintN
code-creation,Builtin,2,9291,0x10c11d700,12,BigIntAsIntN
code-creation,Builtin,2,9298,0x10c11d740,12,BigIntPrototypeToLocaleString
code-creation,Builtin,2,9306,0x10c11d780,12,BigIntPrototypeToString
code-creation,Builtin,2,9313,0x10c11d7c0,12,BigIntPrototypeValueOf
code-creation,Builtin,2,9320,0x10c11d800,12,CallSitePrototypeGetColumnNumber
code-creation,Builtin,2,9328,0x10c11d840,12,CallSitePrototypeGetEnclosingColumnNumber
code-creation,Builtin,2,9335,0x10c11d880,12,CallSitePrototypeGetEnclosingLineNumber
code-creation,Builtin,2,9343,0x10c11d8c0,12,CallSitePrototypeGetEvalOrigin
code-creation,Builtin,2,9351,0x10c11d900,12,CallSitePrototypeGetFileName
code-creation,Builtin,2,9360,0x10c11d940,12,CallSitePrototypeGetFunction
code-creation,Builtin,2,9370,0x10c11d980,12,CallSitePrototypeGetFunctionName
code-creation,Builtin,2,9379,0x10c11d9c0,12,CallSitePrototypeGetLineNumber
code-creation,Builtin,2,9387,0x10c11da00,12,CallSitePrototypeGetMethodName
code-creation,Builtin,2,9395,0x10c11da40,12,CallSitePrototypeGetPosition
code-creation,Builtin,2,9403,0x10c11da80,12,CallSitePrototypeGetPromiseIndex
code-creation,Builtin,2,9411,0x10c11dac0,12,CallSitePrototypeGetScriptNameOrSourceURL
code-creation,Builtin,2,9420,0x10c11db00,12,CallSitePrototypeGetThis
code-creation,Builtin,2,9427,0x10c11db40,12,CallSitePrototypeGetTypeName
code-creation,Builtin,2,9435,0x10c11db80,12,CallSitePrototypeIsAsync
code-creation,Builtin,2,9444,0x10c11dbc0,12,CallSitePrototypeIsConstructor
code-creation,Builtin,2,9453,0x10c11dc00,12,CallSitePrototypeIsEval
code-creation,Builtin,2,9463,0x10c11dc40,12,CallSitePrototypeIsNative
code-creation,Builtin,2,9473,0x10c11dc80,12,CallSitePrototypeIsPromiseAll
code-creation,Builtin,2,9483,0x10c11dcc0,12,CallSitePrototypeIsToplevel
code-creation,Builtin,2,9494,0x10c11dd00,12,CallSitePrototypeToString
code-creation,Builtin,2,9506,0x10c11dd40,12,ConsoleDebug
code-creation,Builtin,2,9525,0x10c11dd80,12,ConsoleError
code-creation,Builtin,2,9533,0x10c11ddc0,12,ConsoleInfo
code-creation,Builtin,2,9540,0x10c11de00,12,ConsoleLog
code-creation,Builtin,2,9547,0x10c11de40,12,ConsoleWarn
code-creation,Builtin,2,9555,0x10c11de80,12,ConsoleDir
code-creation,Builtin,2,9562,0x10c11dec0,12,ConsoleDirXml
code-creation,Builtin,2,9569,0x10c11df00,12,ConsoleTable
code-creation,Builtin,2,9577,0x10c11df40,12,ConsoleTrace
code-creation,Builtin,2,9586,0x10c11df80,12,ConsoleGroup
code-creation,Builtin,2,9594,0x10c11dfc0,12,ConsoleGroupCollapsed
code-creation,Builtin,2,9644,0x10c11e000,12,ConsoleGroupEnd
code-creation,Builtin,2,9662,0x10c11e040,12,ConsoleClear
code-creation,Builtin,2,9670,0x10c11e080,12,ConsoleCount
code-creation,Builtin,2,9676,0x10c11e0c0,12,ConsoleCountReset
code-creation,Builtin,2,9684,0x10c11e100,12,ConsoleAssert
code-creation,Builtin,2,9690,0x10c11e140,12,ConsoleProfile
code-creation,Builtin,2,9697,0x10c11e180,12,ConsoleProfileEnd
code-creation,Builtin,2,9704,0x10c11e1c0,12,ConsoleTime
code-creation,Builtin,2,9711,0x10c11e200,12,ConsoleTimeLog
code-creation,Builtin,2,9717,0x10c11e240,12,ConsoleTimeEnd
code-creation,Builtin,2,9724,0x10c11e280,12,ConsoleTimeStamp
code-creation,Builtin,2,9733,0x10c11e2c0,12,ConsoleContext
code-creation,Builtin,2,9739,0x10c11e300,12,DataViewConstructor
code-creation,Builtin,2,9748,0x10c11e340,12,DateConstructor
code-creation,Builtin,2,9755,0x10c11e380,232,DatePrototypeGetDate
code-creation,Builtin,2,9761,0x10c11e480,232,DatePrototypeGetDay
code-creation,Builtin,2,9768,0x10c11e580,232,DatePrototypeGetFullYear
code-creation,Builtin,2,9775,0x10c11e680,232,DatePrototypeGetHours
code-creation,Builtin,2,9782,0x10c11e780,212,DatePrototypeGetMilliseconds
code-creation,Builtin,2,9790,0x10c11e880,232,DatePrototypeGetMinutes
code-creation,Builtin,2,9797,0x10c11e980,232,DatePrototypeGetMonth
code-creation,Builtin,2,9804,0x10c11ea80,232,DatePrototypeGetSeconds
code-creation,Builtin,2,9811,0x10c11eb80,124,DatePrototypeGetTime
code-creation,Builtin,2,9820,0x10c11ec00,212,DatePrototypeGetTimezoneOffset
code-creation,Builtin,2,9830,0x10c11ed00,212,DatePrototypeGetUTCDate
code-creation,Builtin,2,9839,0x10c11ee00,212,DatePrototypeGetUTCDay
code-creation,Builtin,2,9848,0x10c11ef00,212,DatePrototypeGetUTCFullYear
code-creation,Builtin,2,9857,0x10c11f000,212,DatePrototypeGetUTCHours
code-creation,Builtin,2,9867,0x10c11f100,212,DatePrototypeGetUTCMilliseconds
code-creation,Builtin,2,9876,0x10c11f200,212,DatePrototypeGetUTCMinutes
code-creation,Builtin,2,9886,0x10c11f300,212,DatePrototypeGetUTCMonth
code-creation,Builtin,2,9895,0x10c11f400,212,DatePrototypeGetUTCSeconds
code-creation,Builtin,2,9904,0x10c11f500,124,DatePrototypeValueOf
code-creation,Builtin,2,9913,0x10c11f580,368,DatePrototypeToPrimitive
code-creation,Builtin,2,9922,0x10c11f700,12,DatePrototypeGetYear
code-creation,Builtin,2,9931,0x10c11f740,12,DatePrototypeSetYear
code-creation,Builtin,2,9940,0x10c11f780,12,DateNow
code-creation,Builtin,2,9949,0x10c11f7c0,12,DateParse
code-creation,Builtin,2,9958,0x10c11f800,12,DatePrototypeSetDate
code-creation,Builtin,2,9966,0x10c11f840,12,DatePrototypeSetFullYear
code-creation,Builtin,2,9981,0x10c11f880,12,DatePrototypeSetHours
code-creation,Builtin,2,9990,0x10c11f8c0,12,DatePrototypeSetMilliseconds
code-creation,Builtin,2,9999,0x10c11f900,12,DatePrototypeSetMinutes
code-creation,Builtin,2,10008,0x10c11f940,12,DatePrototypeSetMonth
code-creation,Builtin,2,10017,0x10c11f980,12,DatePrototypeSetSeconds
code-creation,Builtin,2,10026,0x10c11f9c0,12,DatePrototypeSetTime
code-creation,Builtin,2,10035,0x10c11fa00,12,DatePrototypeSetUTCDate
code-creation,Builtin,2,10044,0x10c11fa40,12,DatePrototypeSetUTCFullYear
code-creation,Builtin,2,10053,0x10c11fa80,12,DatePrototypeSetUTCHours
code-creation,Builtin,2,10062,0x10c11fac0,12,DatePrototypeSetUTCMilliseconds
code-creation,Builtin,2,10072,0x10c11fb00,12,DatePrototypeSetUTCMinutes
code-creation,Builtin,2,10081,0x10c11fb40,12,DatePrototypeSetUTCMonth
code-creation,Builtin,2,10090,0x10c11fb80,12,DatePrototypeSetUTCSeconds
code-creation,Builtin,2,10116,0x10c11fbc0,12,DatePrototypeToDateString
code-creation,Builtin,2,10126,0x10c11fc00,12,DatePrototypeToISOString
code-creation,Builtin,2,10135,0x10c11fc40,12,DatePrototypeToUTCString
code-creation,Builtin,2,10144,0x10c11fc80,12,DatePrototypeToString
code-creation,Builtin,2,10153,0x10c11fcc0,12,DatePrototypeToTimeString
code-creation,Builtin,2,10162,0x10c11fd00,12,DatePrototypeToJson
code-creation,Builtin,2,10171,0x10c11fd40,12,DateUTC
code-creation,Builtin,2,10179,0x10c11fd80,12,ErrorConstructor
code-creation,Builtin,2,10187,0x10c11fdc0,12,ErrorCaptureStackTrace
code-creation,Builtin,2,10196,0x10c11fe00,12,ErrorPrototypeToString
code-creation,Builtin,2,10205,0x10c11fe40,12,FunctionConstructor
code-creation,Builtin,2,10214,0x10c11fe80,76,FunctionPrototypeApply
code-creation,Builtin,2,10223,0x10c11ff00,12,FunctionPrototypeBind
code-creation,Builtin,2,10232,0x10c11ff40,32,FunctionPrototypeCall
code-creation,Builtin,2,10241,0x10c11ff80,12,FunctionPrototypeToString
code-creation,Builtin,2,10250,0x10c11ffc0,196,CreateIterResultObject
code-creation,Builtin,2,10260,0x10c1200c0,804,CreateGeneratorObject
code-creation,Builtin,2,10269,0x10c120400,12,GeneratorFunctionConstructor
code-creation,Builtin,2,10278,0x10c120440,424,GeneratorPrototypeNext
code-creation,Builtin,2,10287,0x10c120600,428,GeneratorPrototypeReturn
code-creation,Builtin,2,10297,0x10c1207c0,432,GeneratorPrototypeThrow
code-creation,Builtin,2,10306,0x10c120980,12,AsyncFunctionConstructor
code-creation,Builtin,2,10315,0x10c1209c0,372,SuspendGeneratorBaseline
code-creation,Builtin,2,10357,0x10c120b40,88,ResumeGeneratorBaseline
code-creation,Builtin,2,10389,0x10c120bc0,36,GetIteratorWithFeedbackLazyDeoptContinuation
code-creation,Builtin,2,10409,0x10c120c00,12,GlobalDecodeURI
code-creation,Builtin,2,10424,0x10c120c40,12,GlobalDecodeURIComponent
code-creation,Builtin,2,10440,0x10c120c80,12,GlobalEncodeURI
code-creation,Builtin,2,10454,0x10c120cc0,12,GlobalEncodeURIComponent
code-creation,Builtin,2,10468,0x10c120d00,12,GlobalEscape
tick,0x7fff203572be,10508,0,0x0,6
tick,0x7fff203572be,10529,0,0x0,6
code-creation,Builtin,2,10544,0x10c120d40,12,GlobalUnescape
code-creation,Builtin,2,10567,0x10c120d80,12,GlobalEval
code-creation,Builtin,2,10578,0x10c120dc0,140,GlobalIsFinite
code-creation,Builtin,2,10589,0x10c120e80,132,GlobalIsNaN
code-creation,Builtin,2,10600,0x10c120f40,12,JsonParse
code-creation,Builtin,2,10610,0x10c120f80,12,JsonStringify
code-creation,Builtin,2,10619,0x10c120fc0,4680,LoadIC
code-creation,Builtin,2,10635,0x10c122240,4368,LoadIC_Megamorphic
code-creation,Builtin,2,10645,0x10c123380,4592,LoadIC_Noninlined
code-creation,Builtin,2,10655,0x10c124580,44,LoadICTrampoline
code-creation,Builtin,2,10662,0x10c1245c0,24,LoadICBaseline
code-creation,Builtin,2,10670,0x10c124600,44,LoadICTrampoline_Megamorphic
code-creation,Builtin,2,10680,0x10c124640,7516,LoadSuperIC
code-creation,Builtin,2,10687,0x10c1263c0,24,LoadSuperICBaseline
code-creation,Builtin,2,10695,0x10c126400,8280,KeyedLoadIC
code-creation,Builtin,2,10701,0x10c128480,13328,KeyedLoadIC_Megamorphic
code-creation,Builtin,2,10708,0x10c12b8c0,44,KeyedLoadICTrampoline
code-creation,Builtin,2,10716,0x10c12b900,24,KeyedLoadICBaseline
code-creation,Builtin,2,10723,0x10c12b940,44,KeyedLoadICTrampoline_Megamorphic
code-creation,Builtin,2,10731,0x10c12b980,5084,StoreGlobalIC
code-creation,Builtin,2,10738,0x10c12cd80,44,StoreGlobalICTrampoline
code-creation,Builtin,2,10745,0x10c12cdc0,24,StoreGlobalICBaseline
code-creation,Builtin,2,10753,0x10c12ce00,5328,StoreIC
code-creation,Builtin,2,10760,0x10c12e300,44,StoreICTrampoline
code-creation,Builtin,2,10767,0x10c12e340,24,StoreICBaseline
code-creation,Builtin,2,10774,0x10c12e380,5768,KeyedStoreIC
code-creation,Builtin,2,10781,0x10c12fa40,44,KeyedStoreICTrampoline
code-creation,Builtin,2,10789,0x10c12fa80,24,KeyedStoreICBaseline
code-creation,Builtin,2,10796,0x10c12fac0,408,StoreInArrayLiteralIC
code-creation,Builtin,2,10804,0x10c12fc80,24,StoreInArrayLiteralICBaseline
code-creation,Builtin,2,10811,0x10c12fcc0,140,LookupContextBaseline
code-creation,Builtin,2,10819,0x10c12fd80,140,LookupContextInsideTypeofBaseline
code-creation,Builtin,2,10843,0x10c12fe40,3300,LoadGlobalIC
code-creation,Builtin,2,10850,0x10c130b40,3280,LoadGlobalICInsideTypeof
code-creation,Builtin,2,10858,0x10c131840,44,LoadGlobalICTrampoline
code-creation,Builtin,2,10865,0x10c131880,24,LoadGlobalICBaseline
code-creation,Builtin,2,10915,0x10c1318c0,44,LoadGlobalICInsideTypeofTrampoline
code-creation,Builtin,2,10934,0x10c131900,24,LoadGlobalICInsideTypeofBaseline
code-creation,Builtin,2,10950,0x10c131940,144,LookupGlobalICBaseline
code-creation,Builtin,2,10963,0x10c131a00,144,LookupGlobalICInsideTypeofBaseline
code-creation,Builtin,2,10978,0x10c131ac0,2096,CloneObjectIC
code-creation,Builtin,2,10990,0x10c132300,24,CloneObjectICBaseline
code-creation,Builtin,2,11002,0x10c132340,2028,CloneObjectIC_Slow
code-creation,Builtin,2,11016,0x10c132b40,2880,KeyedHasIC
code-creation,Builtin,2,11029,0x10c1336c0,24,KeyedHasICBaseline
code-creation,Builtin,2,11043,0x10c133700,2684,KeyedHasIC_Megamorphic
code-creation,Builtin,2,11058,0x10c134180,1472,IterableToList
tick,0x7fff203572be,11079,0,0x0,6
code-creation,Builtin,2,11106,0x10c134780,1272,IterableToFixedArray
code-creation,Builtin,2,11128,0x10c134c80,748,IterableToListWithSymbolLookup
code-creation,Builtin,2,11138,0x10c134f80,56,IterableToFixedArrayWithSymbolLookupSlow
code-creation,Builtin,2,11146,0x10c134fc0,124,IterableToListMayPreserveHoles
code-creation,Builtin,2,11154,0x10c135040,1004,IterableToFixedArrayForWasm
code-creation,Builtin,2,11161,0x10c135440,1664,StringListFromIterable
code-creation,Builtin,2,11168,0x10c135b00,1260,FindOrderedHashMapEntry
code-creation,Builtin,2,11175,0x10c136000,4288,MapConstructor
code-creation,Builtin,2,11182,0x10c137100,2012,MapPrototypeSet
code-creation,Builtin,2,11189,0x10c137900,1576,MapPrototypeDelete
code-creation,Builtin,2,11197,0x10c137f40,216,MapPrototypeGet
code-creation,Builtin,2,11209,0x10c138040,168,MapPrototypeHas
code-creation,Builtin,2,11220,0x10c138100,12,MapPrototypeClear
code-creation,Builtin,2,11232,0x10c138140,284,MapPrototypeEntries
code-creation,Builtin,2,11242,0x10c138280,144,MapPrototypeGetSize
code-creation,Builtin,2,11249,0x10c138340,504,MapPrototypeForEach
code-creation,Builtin,2,11256,0x10c138540,284,MapPrototypeKeys
code-creation,Builtin,2,11263,0x10c138680,284,MapPrototypeValues
code-creation,Builtin,2,11270,0x10c1387c0,1068,MapIteratorPrototypeNext
code-creation,Builtin,2,11277,0x10c138c00,1196,MapIteratorToList
code-creation,Builtin,2,11285,0x10c1390c0,12,NumberPrototypeToExponential
code-creation,Builtin,2,11292,0x10c139100,12,NumberPrototypeToFixed
code-creation,Builtin,2,11300,0x10c139140,12,NumberPrototypeToLocaleString
code-creation,Builtin,2,11307,0x10c139180,12,NumberPrototypeToPrecision
code-creation,Builtin,2,11314,0x10c1391c0,340,SameValue
code-creation,Builtin,2,11346,0x10c139340,212,SameValueNumbersOnly
code-creation,Builtin,2,11360,0x10c139440,792,Add_Baseline
code-creation,Builtin,2,11371,0x10c139780,828,Subtract_Baseline
code-creation,Builtin,2,11383,0x10c139ac0,808,Multiply_Baseline
code-creation,Builtin,2,11394,0x10c139e00,832,Divide_Baseline
code-creation,Builtin,2,11406,0x10c13a180,764,Modulus_Baseline
code-creation,Builtin,2,11416,0x10c13a480,820,Exponentiate_Baseline
code-creation,Builtin,2,11428,0x10c13a7c0,708,BitwiseAnd_Baseline
code-creation,Builtin,2,11439,0x10c13aac0,700,BitwiseOr_Baseline
code-creation,Builtin,2,11450,0x10c13ad80,708,BitwiseXor_Baseline
code-creation,Builtin,2,11461,0x10c13b080,720,ShiftLeft_Baseline
code-creation,Builtin,2,11473,0x10c13b380,720,ShiftRight_Baseline
code-creation,Builtin,2,11484,0x10c13b680,836,ShiftRightLogical_Baseline
code-creation,Builtin,2,11497,0x10c13ba00,720,Add_WithFeedback
code-creation,Builtin,2,11508,0x10c13bd00,780,Subtract_WithFeedback
code-creation,Builtin,2,11521,0x10c13c040,776,Multiply_WithFeedback
code-creation,Builtin,2,11533,0x10c13c380,804,Divide_WithFeedback
code-creation,Builtin,2,11545,0x10c13c6c0,724,Modulus_WithFeedback
code-creation,Builtin,2,11556,0x10c13c9c0,780,Exponentiate_WithFeedback
code-creation,Builtin,2,11593,0x10c13cd00,684,BitwiseAnd_WithFeedback
code-creation,Builtin,2,11605,0x10c13cfc0,676,BitwiseOr_WithFeedback
code-creation,Builtin,2,11618,0x10c13d280,684,BitwiseXor_WithFeedback
code-creation,Builtin,2,11631,0x10c13d540,692,ShiftLeft_WithFeedback
code-creation,Builtin,2,11644,0x10c13d800,692,ShiftRight_WithFeedback
code-creation,Builtin,2,11657,0x10c13dac0,808,ShiftRightLogical_WithFeedback
code-creation,Builtin,2,11671,0x10c13de00,1700,Equal_Baseline
code-creation,Builtin,2,11684,0x10c13e4c0,916,StrictEqual_Baseline
code-creation,Builtin,2,11697,0x10c13e880,1268,LessThan_Baseline
code-creation,Builtin,2,11709,0x10c13ed80,1268,GreaterThan_Baseline
code-creation,Builtin,2,11721,0x10c13f280,1268,LessThanOrEqual_Baseline
code-creation,Builtin,2,11734,0x10c13f780,1268,GreaterThanOrEqual_Baseline
code-creation,Builtin,2,11747,0x10c13fc80,1632,Equal_WithFeedback
code-creation,Builtin,2,11760,0x10c140300,944,StrictEqual_WithFeedback
code-creation,Builtin,2,11772,0x10c1406c0,1248,LessThan_WithFeedback
code-creation,Builtin,2,11785,0x10c140bc0,1248,GreaterThan_WithFeedback
code-creation,Builtin,2,11798,0x10c1410c0,1248,LessThanOrEqual_WithFeedback
code-creation,Builtin,2,11812,0x10c1415c0,1248,GreaterThanOrEqual_WithFeedback
code-creation,Builtin,2,11826,0x10c141ac0,332,BitwiseNot_Baseline
code-creation,Builtin,2,11838,0x10c141c40,460,Decrement_Baseline
code-creation,Builtin,2,11850,0x10c141e40,464,Increment_Baseline
code-creation,Builtin,2,11862,0x10c142040,488,Negate_Baseline
code-creation,Builtin,2,11875,0x10c142240,316,BitwiseNot_WithFeedback
code-creation,Builtin,2,11888,0x10c142380,440,Decrement_WithFeedback
code-creation,Builtin,2,11900,0x10c142540,444,Increment_WithFeedback
code-creation,Builtin,2,11913,0x10c142700,472,Negate_WithFeedback
code-creation,Builtin,2,11926,0x10c142900,252,ObjectAssign
code-creation,Builtin,2,11938,0x10c142a00,884,ObjectCreate
code-creation,Builtin,2,11993,0x10c142d80,12,ObjectDefineGetter
code-creation,Builtin,2,12009,0x10c142dc0,12,ObjectDefineProperties
code-creation,Builtin,2,12032,0x10c142e00,12,ObjectDefineProperty
code-creation,Builtin,2,12058,0x10c142e40,12,ObjectDefineSetter
code-creation,Builtin,2,12139,0x10c142e80,1528,ObjectEntries
code-creation,Builtin,2,12153,0x10c143480,12,ObjectFreeze
code-creation,Builtin,2,12165,0x10c1434c0,5812,ObjectGetOwnPropertyDescriptor
code-creation,Builtin,2,12230,0x10c144b80,12,ObjectGetOwnPropertyDescriptors
code-creation,Builtin,2,12249,0x10c144bc0,600,ObjectGetOwnPropertyNames
code-creation,Builtin,2,12264,0x10c144e40,12,ObjectGetOwnPropertySymbols
code-creation,Builtin,2,12279,0x10c144e80,172,ObjectHasOwn
code-creation,Builtin,2,12292,0x10c144f40,400,ObjectIs
tick,0x10c26537d,12309,0,0x0,6
code-creation,Builtin,2,12322,0x10c145100,12,ObjectIsFrozen
code-creation,Builtin,2,12342,0x10c145140,12,ObjectIsSealed
code-creation,Builtin,2,12355,0x10c145180,536,ObjectKeys
code-creation,Builtin,2,12366,0x10c1453c0,12,ObjectLookupGetter
code-creation,Builtin,2,12378,0x10c145400,12,ObjectLookupSetter
code-creation,Builtin,2,12390,0x10c145440,2320,ObjectPrototypeHasOwnProperty
code-creation,Builtin,2,12403,0x10c145d80,236,ObjectPrototypeIsPrototypeOf
code-creation,Builtin,2,12416,0x10c145e80,12,ObjectPrototypePropertyIsEnumerable
code-creation,Builtin,2,12458,0x10c145ec0,12,ObjectPrototypeGetProto
code-creation,Builtin,2,12475,0x10c145f00,12,ObjectPrototypeSetProto
code-creation,Builtin,2,12488,0x10c145f40,12,ObjectSeal
code-creation,Builtin,2,12499,0x10c145f80,1124,ObjectToString
code-creation,Builtin,2,12511,0x10c146400,1288,ObjectValues
code-creation,Builtin,2,12531,0x10c146940,300,OrdinaryHasInstance
code-creation,Builtin,2,12553,0x10c146a80,364,InstanceOf
code-creation,Builtin,2,12574,0x10c146c00,648,InstanceOf_WithFeedback
code-creation,Builtin,2,12582,0x10c146ec0,664,InstanceOf_Baseline
code-creation,Builtin,2,12589,0x10c147180,272,ForInEnumerate
code-creation,Builtin,2,12596,0x10c1472c0,148,ForInPrepare
code-creation,Builtin,2,12603,0x10c147380,2640,ForInFilter
code-creation,Builtin,2,12611,0x10c147e00,56,ReflectApply
code-creation,Builtin,2,12621,0x10c147e40,64,ReflectConstruct
code-creation,Builtin,2,12654,0x10c147ec0,12,ReflectDefineProperty
code-creation,Builtin,2,12667,0x10c147f00,12,ReflectGetOwnPropertyDescriptor
code-creation,Builtin,2,12680,0x10c147f40,12,ReflectOwnKeys
code-creation,Builtin,2,12692,0x10c147f80,12,ReflectSet
code-creation,Builtin,2,12704,0x10c147fc0,12,RegExpCapture1Getter
code-creation,Builtin,2,12718,0x10c148000,12,RegExpCapture2Getter
code-creation,Builtin,2,12732,0x10c148040,12,RegExpCapture3Getter
code-creation,Builtin,2,12745,0x10c148080,12,RegExpCapture4Getter
code-creation,Builtin,2,12759,0x10c1480c0,12,RegExpCapture5Getter
code-creation,Builtin,2,12772,0x10c148100,12,RegExpCapture6Getter
code-creation,Builtin,2,12786,0x10c148140,12,RegExpCapture7Getter
code-creation,Builtin,2,12803,0x10c148180,12,RegExpCapture8Getter
code-creation,Builtin,2,12816,0x10c1481c0,12,RegExpCapture9Getter
code-creation,Builtin,2,12830,0x10c148200,2272,RegExpConstructor
code-creation,Builtin,2,12842,0x10c148b00,12,RegExpInputGetter
code-creation,Builtin,2,12854,0x10c148b40,12,RegExpInputSetter
code-creation,Builtin,2,12865,0x10c148b80,12,RegExpLastMatchGetter
code-creation,Builtin,2,12878,0x10c148bc0,12,RegExpLastParenGetter
code-creation,Builtin,2,12890,0x10c148c00,12,RegExpLeftContextGetter
code-creation,Builtin,2,12903,0x10c148c40,936,RegExpPrototypeCompile
code-creation,Builtin,2,12917,0x10c149000,12,RegExpPrototypeToString
code-creation,Builtin,2,12931,0x10c149040,12,RegExpRightContextGetter
code-creation,Builtin,2,12945,0x10c149080,252,RegExpExecAtom
code-creation,Builtin,2,12959,0x10c149180,1036,RegExpExecInternal
code-creation,Builtin,2,12971,0x10c1495c0,8,RegExpInterpreterTrampoline
code-creation,Builtin,2,12985,0x10c149600,8,RegExpExperimentalTrampoline
code-creation,Builtin,2,12998,0x10c149640,2744,SetConstructor
code-creation,Builtin,2,13010,0x10c14a100,1324,SetPrototypeHas
code-creation,Builtin,2,13046,0x10c14a640,1756,SetPrototypeAdd
code-creation,Builtin,2,13062,0x10c14ad40,1532,SetPrototypeDelete
code-creation,Builtin,2,13076,0x10c14b340,12,SetPrototypeClear
code-creation,Builtin,2,13091,0x10c14b380,284,SetPrototypeEntries
code-creation,Builtin,2,13106,0x10c14b4c0,144,SetPrototypeGetSize
code-creation,Builtin,2,13122,0x10c14b580,460,SetPrototypeForEach
code-creation,Builtin,2,13137,0x10c14b780,284,SetPrototypeValues
code-creation,Builtin,2,13151,0x10c14b8c0,1004,SetIteratorPrototypeNext
code-creation,Builtin,2,13167,0x10c14bcc0,1124,SetOrSetIteratorToList
code-creation,Builtin,2,13182,0x10c14c140,12,SharedArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,13200,0x10c14c180,12,SharedArrayBufferPrototypeSlice
code-creation,Builtin,2,13216,0x10c14c1c0,12,SharedArrayBufferPrototypeGrow
code-creation,Builtin,2,13232,0x10c14c200,1280,AtomicsLoad
code-creation,Builtin,2,13249,0x10c14c740,1016,AtomicsStore
code-creation,Builtin,2,13288,0x10c14cb40,1704,AtomicsExchange
code-creation,Builtin,2,13333,0x10c14d200,2096,AtomicsCompareExchange
code-creation,Builtin,2,13364,0x10c14da40,1808,AtomicsAdd
code-creation,Builtin,2,13392,0x10c14e180,1808,AtomicsSub
code-creation,Builtin,2,13407,0x10c14e8c0,1808,AtomicsAnd
code-creation,Builtin,2,13419,0x10c14f000,1808,AtomicsOr
code-creation,Builtin,2,13430,0x10c14f740,1808,AtomicsXor
code-creation,Builtin,2,13468,0x10c14fe80,12,AtomicsNotify
code-creation,Builtin,2,13481,0x10c14fec0,12,AtomicsIsLockFree
code-creation,Builtin,2,13495,0x10c14ff00,12,AtomicsWait
code-creation,Builtin,2,13507,0x10c14ff40,12,AtomicsWaitAsync
code-creation,Builtin,2,13519,0x10c14ff80,12,StringFromCodePoint
code-creation,Builtin,2,13533,0x10c14ffc0,1444,StringFromCharCode
code-creation,Builtin,2,13545,0x10c150580,12,StringPrototypeLastIndexOf
code-creation,Builtin,2,13598,0x10c1505c0,4456,StringPrototypeMatchAll
code-creation,Builtin,2,13611,0x10c151740,12,StringPrototypeLocaleCompare
code-creation,Builtin,2,13625,0x10c151780,1252,StringPrototypeReplace
code-creation,Builtin,2,13637,0x10c151c80,2944,StringPrototypeSplit
code-creation,Builtin,2,13648,0x10c152840,12,StringRaw
code-creation,Builtin,2,13660,0x10c152880,12,SymbolConstructor
code-creation,Builtin,2,13700,0x10c1528c0,12,SymbolFor
code-creation,Builtin,2,13716,0x10c152900,12,SymbolKeyFor
code-creation,Builtin,2,13730,0x10c152940,88,TypedArrayBaseConstructor
code-creation,Builtin,2,13746,0x10c1529c0,264,TypedArrayConstructor
code-creation,Builtin,2,13762,0x10c152b00,12,TypedArrayPrototypeBuffer
code-creation,Builtin,2,13778,0x10c152b40,892,TypedArrayPrototypeByteLength
code-creation,Builtin,2,13795,0x10c152ec0,368,TypedArrayPrototypeByteOffset
code-creation,Builtin,2,13811,0x10c153040,600,TypedArrayPrototypeLength
code-creation,Builtin,2,13826,0x10c1532c0,12,TypedArrayPrototypeCopyWithin
code-creation,Builtin,2,13842,0x10c153300,12,TypedArrayPrototypeFill
code-creation,Builtin,2,13858,0x10c153340,12,TypedArrayPrototypeIncludes
code-creation,Builtin,2,13873,0x10c153380,12,TypedArrayPrototypeIndexOf
code-creation,Builtin,2,13890,0x10c1533c0,12,TypedArrayPrototypeLastIndexOf
code-creation,Builtin,2,13905,0x10c153400,12,TypedArrayPrototypeReverse
code-creation,Builtin,2,13920,0x10c153440,316,TypedArrayPrototypeToStringTag
code-creation,Builtin,2,13937,0x10c153580,10664,TypedArrayPrototypeMap
code-creation,Builtin,2,13954,0x10c155f40,792,GenericJSToWasmWrapper
code-creation,Builtin,2,13969,0x10c156280,148,WasmCompileLazy
code-creation,Builtin,2,13993,0x10c156340,168,WasmDebugBreak
code-creation,Builtin,2,14008,0x10c156400,16,WasmOnStackReplace
code-creation,Builtin,2,14022,0x10c156440,140,WasmFloat32ToNumber
code-creation,Builtin,2,14035,0x10c156500,152,WasmFloat64ToNumber
code-creation,Builtin,2,14051,0x10c1565c0,4,WasmI32AtomicWait32
code-creation,Builtin,2,14066,0x10c156600,4,WasmI64AtomicWait32
code-creation,Builtin,2,14083,0x10c156640,24,JSToWasmLazyDeoptContinuation
code-creation,Builtin,2,14100,0x10c156680,4456,WeakMapConstructor
code-creation,Builtin,2,14116,0x10c157800,200,WeakMapLookupHashIndex
code-creation,Builtin,2,14132,0x10c157900,224,WeakMapGet
code-creation,Builtin,2,14144,0x10c157a00,180,WeakMapPrototypeHas
code-creation,Builtin,2,14158,0x10c157ac0,204,WeakMapPrototypeSet
code-creation,Builtin,2,14171,0x10c157bc0,144,WeakMapPrototypeDelete
code-creation,Builtin,2,14187,0x10c157c80,2944,WeakSetConstructor
code-creation,Builtin,2,14203,0x10c158840,180,WeakSetPrototypeHas
code-creation,Builtin,2,14218,0x10c158900,204,WeakSetPrototypeAdd
code-creation,Builtin,2,14234,0x10c158a00,144,WeakSetPrototypeDelete
code-creation,Builtin,2,14249,0x10c158ac0,384,WeakCollectionDelete
code-creation,Builtin,2,14265,0x10c158c80,784,WeakCollectionSet
code-creation,Builtin,2,14285,0x10c158fc0,296,AsyncGeneratorResolve
code-creation,Builtin,2,14315,0x10c159100,104,AsyncGeneratorReject
code-creation,Builtin,2,14328,0x10c159180,2788,AsyncGeneratorYield
code-creation,Builtin,2,14342,0x10c159c80,2896,AsyncGeneratorReturn
code-creation,Builtin,2,14360,0x10c15a800,308,AsyncGeneratorResumeNext
code-creation,Builtin,2,14373,0x10c15a940,12,AsyncGeneratorFunctionConstructor
code-creation,Builtin,2,14391,0x10c15a980,1040,AsyncGeneratorPrototypeNext
code-creation,Builtin,2,14407,0x10c15adc0,1044,AsyncGeneratorPrototypeReturn
code-creation,Builtin,2,14424,0x10c15b200,1044,AsyncGeneratorPrototypeThrow
code-creation,Builtin,2,14441,0x10c15b640,2772,AsyncGeneratorAwaitCaught
code-creation,Builtin,2,14459,0x10c15c140,2772,AsyncGeneratorAwaitUncaught
code-creation,Builtin,2,14474,0x10c15cc40,116,AsyncGeneratorAwaitResolveClosure
code-creation,Builtin,2,14487,0x10c15ccc0,128,AsyncGeneratorAwaitRejectClosure
code-creation,Builtin,2,14500,0x10c15cd80,120,AsyncGeneratorYieldResolveClosure
code-creation,Builtin,2,14513,0x10c15ce00,120,AsyncGeneratorReturnClosedResolveClosure
code-creation,Builtin,2,14526,0x10c15ce80,112,AsyncGeneratorReturnClosedRejectClosure
code-creation,Builtin,2,14540,0x10c15cf00,128,AsyncGeneratorReturnResolveClosure
code-creation,Builtin,2,14552,0x10c15cfc0,1608,AsyncFromSyncIteratorPrototypeNext
code-creation,Builtin,2,14566,0x10c15d640,1724,AsyncFromSyncIteratorPrototypeThrow
code-creation,Builtin,2,14579,0x10c15dd00,1744,AsyncFromSyncIteratorPrototypeReturn
code-creation,Builtin,2,14593,0x10c15e400,100,AsyncIteratorValueUnwrap
code-creation,Builtin,2,14631,0x10c15e480,220,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,14651,0x10c15e580,220,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,14669,0x10c15e680,204,CEntry_Return1_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,14688,0x10c15e780,400,CEntry_Return1_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,14707,0x10c15e940,400,CEntry_Return1_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,14726,0x10c15eb00,220,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,14746,0x10c15ec00,220,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,14766,0x10c15ed00,204,CEntry_Return2_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,14786,0x10c15ee00,400,CEntry_Return2_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,14804,0x10c15efc0,400,CEntry_Return2_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,14822,0x10c15f180,4,DirectCEntry
code-creation,Builtin,2,14837,0x10c15f1c0,1116,StringAdd_CheckNone
code-creation,Builtin,2,14852,0x10c15f640,2520,SubString
code-creation,Builtin,2,14865,0x10c160040,16,StackCheck
code-creation,Builtin,2,14876,0x10c160080,84,DoubleToI
code-creation,Builtin,2,14887,0x10c160100,2280,GetProperty
code-creation,Builtin,2,14899,0x10c160a00,2360,GetPropertyWithReceiver
code-creation,Builtin,2,14911,0x10c161340,15960,SetProperty
code-creation,Builtin,2,14923,0x10c1651c0,13480,SetPropertyInLiteral
code-creation,Builtin,2,14935,0x10c168680,8,MemCopyUint8Uint8
code-creation,Builtin,2,14948,0x10c1686c0,8,MemMove
code-creation,Builtin,2,14962,0x10c168700,12,IsTraceCategoryEnabled
code-creation,Builtin,2,14980,0x10c168740,12,Trace
code-creation,Builtin,2,14994,0x10c168780,12,FinalizationRegistryUnregister
code-creation,Builtin,2,15012,0x10c1687c0,428,AsyncModuleEvaluate
code-creation,Builtin,2,15029,0x10c168980,12,CallAsyncModuleFulfilled
code-creation,Builtin,2,15046,0x10c1689c0,12,CallAsyncModuleRejected
code-creation,Builtin,2,15064,0x10c168a00,268,AggregateErrorConstructor
code-creation,Builtin,2,15077,0x10c168b40,860,ArrayPrototypeAt
code-creation,Builtin,2,15090,0x10c168ec0,664,ArrayPrototypeConcat
code-creation,Builtin,2,15104,0x10c169180,5844,ArrayPrototypeCopyWithin
code-creation,Builtin,2,15118,0x10c16a880,220,ArrayEveryLoopEagerDeoptContinuation
code-creation,Builtin,2,15132,0x10c16a980,624,ArrayEveryLoopLazyDeoptContinuation
code-creation,Builtin,2,15145,0x10c16ac00,3336,ArrayEveryLoopContinuation
code-creation,Builtin,2,15157,0x10c16b940,1500,ArrayEvery
code-creation,Builtin,2,15169,0x10c16bf40,284,ArrayFilterLoopEagerDeoptContinuation
code-creation,Builtin,2,15179,0x10c16c080,992,ArrayFilterLoopLazyDeoptContinuation
code-creation,Builtin,2,15189,0x10c16c480,3632,ArrayFilterLoopContinuation
code-creation,Builtin,2,15198,0x10c16d2c0,4300,ArrayFilter
code-creation,Builtin,2,15207,0x10c16e3c0,204,ArrayFindLoopEagerDeoptContinuation
code-creation,Builtin,2,15216,0x10c16e4c0,32,ArrayFindLoopLazyDeoptContinuation
code-creation,Builtin,2,15226,0x10c16e500,320,ArrayFindLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,15236,0x10c16e680,536,ArrayFindLoopContinuation
code-creation,Builtin,2,15246,0x10c16e8c0,1488,ArrayPrototypeFind
code-creation,Builtin,2,15255,0x10c16eec0,204,ArrayFindIndexLoopEagerDeoptContinuation
code-creation,Builtin,2,15265,0x10c16efc0,32,ArrayFindIndexLoopLazyDeoptContinuation
code-creation,Builtin,2,15274,0x10c16f000,320,ArrayFindIndexLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,15285,0x10c16f180,532,ArrayFindIndexLoopContinuation
code-creation,Builtin,2,15294,0x10c16f3c0,1488,ArrayPrototypeFindIndex
code-creation,Builtin,2,15304,0x10c16f9c0,456,ArrayFindLastLoopContinuation
code-creation,Builtin,2,15314,0x10c16fbc0,1732,ArrayPrototypeFindLast
code-creation,Builtin,2,15323,0x10c1702c0,452,ArrayFindLastIndexLoopContinuation
code-creation,Builtin,2,15333,0x10c1704c0,1728,ArrayPrototypeFindLastIndex
code-creation,Builtin,2,15387,0x10c170bc0,220,ArrayForEachLoopEagerDeoptContinuation
code-creation,Builtin,2,15413,0x10c170cc0,220,ArrayForEachLoopLazyDeoptContinuation
code-creation,Builtin,2,15429,0x10c170dc0,3212,ArrayForEachLoopContinuation
code-creation,Builtin,2,15445,0x10c171a80,1356,ArrayForEach
code-creation,Builtin,2,15459,0x10c172000,3632,ArrayFrom
code-creation,Builtin,2,15473,0x10c172e40,160,ArrayIsArray
code-creation,Builtin,2,15485,0x10c172f00,424,LoadJoinElement_DictionaryElements_0
code-creation,Builtin,2,15498,0x10c1730c0,44,LoadJoinElement_FastSmiOrObjectElements_0
code-creation,Builtin,2,15512,0x10c173100,144,LoadJoinElement_FastDoubleElements_0
code-creation,Builtin,2,15525,0x10c1731c0,332,ConvertToLocaleString
code-creation,Builtin,2,15537,0x10c173340,764,JoinStackPush
code-creation,Builtin,2,15547,0x10c173640,280,JoinStackPop
code-creation,Builtin,2,15562,0x10c173780,6740,ArrayPrototypeJoin
code-creation,Builtin,2,15575,0x10c175200,5464,ArrayPrototypeToLocaleString
code-creation,Builtin,2,15588,0x10c176780,236,ArrayPrototypeToString
code-creation,Builtin,2,15600,0x10c176880,6040,TypedArrayPrototypeJoin
code-creation,Builtin,2,15612,0x10c178040,4736,TypedArrayPrototypeToLocaleString
code-creation,Builtin,2,15625,0x10c179300,3864,ArrayPrototypeLastIndexOf
code-creation,Builtin,2,15644,0x10c17a240,260,ArrayMapPreLoopLazyDeoptContinuation
code-creation,Builtin,2,15657,0x10c17a380,252,ArrayMapLoopEagerDeoptContinuation
code-creation,Builtin,2,15673,0x10c17a480,532,ArrayMapLoopLazyDeoptContinuation
code-creation,Builtin,2,15689,0x10c17a6c0,3256,ArrayMapLoopContinuation
code-creation,Builtin,2,15705,0x10c17b380,3936,ArrayMap
code-creation,Builtin,2,15719,0x10c17c300,1012,ArrayOf
code-creation,Builtin,2,15733,0x10c17c700,444,ArrayReduceRightPreLoopEagerDeoptContinuation
code-creation,Builtin,2,15751,0x10c17c8c0,204,ArrayReduceRightLoopEagerDeoptContinuation
code-creation,Builtin,2,15770,0x10c17c9c0,204,ArrayReduceRightLoopLazyDeoptContinuation
code-creation,Builtin,2,15789,0x10c17cac0,3276,ArrayReduceRightLoopContinuation
code-creation,Builtin,2,15808,0x10c17d7c0,2032,ArrayReduceRight
code-creation,Builtin,2,15824,0x10c17dfc0,180,ArrayReducePreLoopEagerDeoptContinuation
code-creation,Builtin,2,15842,0x10c17e080,204,ArrayReduceLoopEagerDeoptContinuation
code-creation,Builtin,2,15860,0x10c17e180,204,ArrayReduceLoopLazyDeoptContinuation
code-creation,Builtin,2,15879,0x10c17e280,3288,ArrayReduceLoopContinuation
code-creation,Builtin,2,15896,0x10c17ef80,1636,ArrayReduce
code-creation,Builtin,2,15913,0x10c17f600,3244,ArrayPrototypeReverse
code-creation,Builtin,2,15929,0x10c1802c0,3664,ArrayPrototypeShift
code-creation,Builtin,2,15944,0x10c181140,5236,ArrayPrototypeSlice
code-creation,Builtin,2,15959,0x10c1825c0,220,ArraySomeLoopEagerDeoptContinuation
code-creation,Builtin,2,15977,0x10c1826c0,592,ArraySomeLoopLazyDeoptContinuation
code-creation,Builtin,2,15994,0x10c182940,3324,ArraySomeLoopContinuation
code-creation,Builtin,2,16010,0x10c183640,1484,ArraySome
code-creation,Builtin,2,16024,0x10c183c40,14324,ArrayPrototypeSplice
code-creation,Builtin,2,16041,0x10c187440,3288,ArrayPrototypeUnshift
code-creation,Builtin,2,16057,0x10c188140,332,ArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,16074,0x10c1882c0,348,ArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,16091,0x10c188440,216,ArrayBufferPrototypeGetResizable
code-creation,Builtin,2,16108,0x10c188540,332,SharedArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,16125,0x10c1886c0,216,SharedArrayBufferPrototypeGetGrowable
code-creation,Builtin,2,16140,0x10c1887c0,104,ArrayBufferIsView
code-creation,Builtin,2,16155,0x10c188840,396,ToInteger
code-creation,Builtin,2,16166,0x10c188a00,3104,FastCreateDataProperty
code-creation,Builtin,2,16181,0x10c189640,680,CheckNumberInRange
code-creation,Builtin,2,16197,0x10c189900,640,CheckSameObject
code-creation,Builtin,2,16212,0x10c189bc0,944,BooleanConstructor
code-creation,Builtin,2,16228,0x10c189f80,164,BooleanPrototypeToString
code-creation,Builtin,2,16243,0x10c18a040,156,BooleanPrototypeValueOf
code-creation,Builtin,2,16281,0x10c18a100,1216,BigIntAddNoThrow
code-creation,Builtin,2,16297,0x10c18a600,1312,BigIntAdd
code-creation,Builtin,2,16315,0x10c18ab40,1216,BigIntSubtractNoThrow
code-creation,Builtin,2,16332,0x10c18b040,1312,BigIntSubtract
code-creation,Builtin,2,16347,0x10c18b580,284,BigIntUnaryMinus
code-creation,Builtin,2,16363,0x10c18b6c0,1348,ToString
code-creation,Builtin,2,16378,0x10c18bc40,156,StringPrototypeToString
code-creation,Builtin,2,16397,0x10c18bd00,156,StringPrototypeValueOf
code-creation,Builtin,2,16411,0x10c18bdc0,2480,StringToList
code-creation,Builtin,2,16427,0x10c18c780,1028,StringPrototypeCharAt
code-creation,Builtin,2,16442,0x10c18cbc0,708,StringPrototypeCharCodeAt
code-creation,Builtin,2,16459,0x10c18cec0,1304,StringPrototypeCodePointAt
code-creation,Builtin,2,16481,0x10c18d400,412,StringPrototypeConcat
code-creation,Builtin,2,16498,0x10c18d5c0,1036,StringConstructor
code-creation,Builtin,2,16511,0x10c18da00,1404,StringAddConvertLeft
code-creation,Builtin,2,16524,0x10c18df80,1448,StringAddConvertRight
code-creation,Builtin,2,16538,0x10c18e540,824,StringCharAt
code-creation,Builtin,2,16553,0x10c18e880,16,FastNewClosureBaseline
code-creation,Builtin,2,16569,0x10c18e8c0,200,FastNewFunctionContextEval
code-creation,Builtin,2,16585,0x10c18e9c0,200,FastNewFunctionContextFunction
code-creation,Builtin,2,16601,0x10c18eac0,248,CreateRegExpLiteral
code-creation,Builtin,2,16620,0x10c18ebc0,1100,CreateShallowArrayLiteral
code-creation,Builtin,2,16638,0x10c18f040,496,CreateEmptyArrayLiteral
code-creation,Builtin,2,16655,0x10c18f240,1840,CreateShallowObjectLiteral
code-creation,Builtin,2,16688,0x10c18f980,400,ObjectConstructor
code-creation,Builtin,2,16709,0x10c18fb40,180,CreateEmptyLiteralObject
code-creation,Builtin,2,16726,0x10c18fc00,540,NumberConstructor
code-creation,Builtin,2,16741,0x10c18fe40,64,GenericLazyDeoptContinuation
code-creation,Builtin,2,16758,0x10c18fec0,64,StringToNumber
code-creation,Builtin,2,16781,0x10c18ff40,184,NonNumberToNumber
code-creation,Builtin,2,16797,0x10c190000,240,NonNumberToNumeric
code-creation,Builtin,2,16813,0x10c190100,36,ToNumeric
code-creation,Builtin,2,16829,0x10c190140,1188,NumberToString
code-creation,Builtin,2,16845,0x10c190600,104,ToBoolean
code-creation,Builtin,2,16860,0x10c190680,100,ToBooleanForBaselineJump
code-creation,Builtin,2,16877,0x10c190700,728,ToLength
code-creation,Builtin,2,16890,0x10c190a00,1316,ToName
code-creation,Builtin,2,16903,0x10c190f40,768,ToObject
code-creation,Builtin,2,16912,0x10c191280,236,NonPrimitiveToPrimitive_Default
code-creation,Builtin,2,16923,0x10c191380,236,NonPrimitiveToPrimitive_Number
code-creation,Builtin,2,16934,0x10c191480,236,NonPrimitiveToPrimitive_String
code-creation,Builtin,2,16944,0x10c191580,328,OrdinaryToPrimitive_Number
code-creation,Builtin,2,16954,0x10c191700,328,OrdinaryToPrimitive_String
code-creation,Builtin,2,16964,0x10c191880,232,FastConsoleAssert
code-creation,Builtin,2,16973,0x10c191980,160,DataViewPrototypeGetBuffer
code-creation,Builtin,2,16984,0x10c191a40,336,DataViewPrototypeGetByteLength
code-creation,Builtin,2,16994,0x10c191bc0,336,DataViewPrototypeGetByteOffset
code-creation,Builtin,2,17004,0x10c191d40,592,DataViewPrototypeGetUint8
code-creation,Builtin,2,17014,0x10c191fc0,592,DataViewPrototypeGetInt8
code-creation,Builtin,2,17024,0x10c192240,660,DataViewPrototypeGetUint16
code-creation,Builtin,2,17034,0x10c192500,656,DataViewPrototypeGetInt16
code-creation,Builtin,2,17044,0x10c1927c0,824,DataViewPrototypeGetUint32
code-creation,Builtin,2,17055,0x10c192b00,700,DataViewPrototypeGetInt32
code-creation,Builtin,2,17072,0x10c192dc0,860,DataViewPrototypeGetFloat32
code-creation,Builtin,2,17089,0x10c193140,924,DataViewPrototypeGetFloat64
code-creation,Builtin,2,17107,0x10c193500,1000,DataViewPrototypeGetBigUint64
code-creation,Builtin,2,17124,0x10c193900,1016,DataViewPrototypeGetBigInt64
code-creation,Builtin,2,17141,0x10c193d00,952,DataViewPrototypeSetUint8
code-creation,Builtin,2,17158,0x10c1940c0,952,DataViewPrototypeSetInt8
code-creation,Builtin,2,17174,0x10c194480,1048,DataViewPrototypeSetUint16
code-creation,Builtin,2,17213,0x10c1948c0,1048,DataViewPrototypeSetInt16
code-creation,Builtin,2,17230,0x10c194d00,1088,DataViewPrototypeSetUint32
code-creation,Builtin,2,17246,0x10c195180,1088,DataViewPrototypeSetInt32
code-creation,Builtin,2,17262,0x10c195600,1052,DataViewPrototypeSetFloat32
code-creation,Builtin,2,17278,0x10c195a40,1116,DataViewPrototypeSetFloat64
code-creation,Builtin,2,17292,0x10c195ec0,968,DataViewPrototypeSetBigUint64
code-creation,Builtin,2,17310,0x10c1962c0,968,DataViewPrototypeSetBigInt64
code-creation,Builtin,2,17327,0x10c1966c0,852,FinalizationRegistryConstructor
code-creation,Builtin,2,17344,0x10c196a40,1164,FinalizationRegistryRegister
code-creation,Builtin,2,17357,0x10c196f00,680,FinalizationRegistryPrototypeCleanupSome
code-creation,Builtin,2,17368,0x10c1971c0,340,FunctionPrototypeHasInstance
code-creation,Builtin,2,17378,0x10c197340,936,FastFunctionPrototypeBind
code-creation,Builtin,2,17388,0x10c197700,96,IncBlockCounter
code-creation,Builtin,2,17398,0x10c197780,236,GetTemplateObject
code-creation,Builtin,2,17409,0x10c197880,28,BytecodeBudgetInterruptFromCode
code-creation,Builtin,2,17422,0x10c1978c0,92,ForInNext
code-creation,Builtin,2,17437,0x10c197940,132,GetImportMetaObjectBaseline
code-creation,Builtin,2,17453,0x10c197a00,116,GetIteratorWithFeedback
code-creation,Builtin,2,17469,0x10c197a80,100,GetIteratorBaseline
code-creation,Builtin,2,17484,0x10c197b00,272,CreateAsyncFromSyncIteratorBaseline
code-creation,Builtin,2,17503,0x10c197c40,1072,CallIteratorWithFeedback
code-creation,Builtin,2,17516,0x10c198080,288,MathAbs
code-creation,Builtin,2,17528,0x10c1981c0,428,MathCeil
code-creation,Builtin,2,17541,0x10c198380,432,MathFloor
code-creation,Builtin,2,17553,0x10c198540,488,MathRound
code-creation,Builtin,2,17565,0x10c198740,428,MathTrunc
code-creation,Builtin,2,17579,0x10c198900,376,MathPow
code-creation,Builtin,2,17595,0x10c198a80,404,MathMax
code-creation,Builtin,2,17609,0x10c198c40,408,MathMin
code-creation,Builtin,2,17627,0x10c198e00,328,MathAcos
code-creation,Builtin,2,17642,0x10c198f80,328,MathAcosh
code-creation,Builtin,2,17657,0x10c199100,328,MathAsin
code-creation,Builtin,2,17671,0x10c199280,328,MathAsinh
code-creation,Builtin,2,17685,0x10c199400,328,MathAtan
code-creation,Builtin,2,17700,0x10c199580,424,MathAtan2
code-creation,Builtin,2,17713,0x10c199740,328,MathAtanh
code-creation,Builtin,2,17727,0x10c1998c0,328,MathCbrt
code-creation,Builtin,2,17741,0x10c199a40,168,MathClz32
code-creation,Builtin,2,17755,0x10c199b00,328,MathCos
code-creation,Builtin,2,17769,0x10c199c80,328,MathCosh
code-creation,Builtin,2,17780,0x10c199e00,328,MathExp
code-creation,Builtin,2,17811,0x10c199f80,328,MathExpm1
code-creation,Builtin,2,17829,0x10c19a100,272,MathFround
code-creation,Builtin,2,17839,0x10c19a240,304,MathImul
code-creation,Builtin,2,17848,0x10c19a380,328,MathLog
code-creation,Builtin,2,17858,0x10c19a500,328,MathLog1p
code-creation,Builtin,2,17867,0x10c19a680,328,MathLog10
code-creation,Builtin,2,17877,0x10c19a800,328,MathLog2
code-creation,Builtin,2,17891,0x10c19a980,328,MathSin
code-creation,Builtin,2,17904,0x10c19ab00,180,MathSign
code-creation,Builtin,2,17914,0x10c19abc0,328,MathSinh
code-creation,Builtin,2,17923,0x10c19ad40,268,MathSqrt
code-creation,Builtin,2,17933,0x10c19ae80,328,MathTan
code-creation,Builtin,2,17942,0x10c19b000,328,MathTanh
code-creation,Builtin,2,17957,0x10c19b180,1068,MathHypot
code-creation,Builtin,2,17971,0x10c19b5c0,336,MathRandom
code-creation,Builtin,2,17986,0x10c19b740,2976,NumberPrototypeToString
code-creation,Builtin,2,18002,0x10c19c300,156,NumberIsFinite
code-creation,Builtin,2,18014,0x10c19c3c0,344,NumberIsInteger
code-creation,Builtin,2,18028,0x10c19c540,128,NumberIsNaN
code-creation,Builtin,2,18040,0x10c19c600,376,NumberIsSafeInteger
code-creation,Builtin,2,18053,0x10c19c780,156,NumberPrototypeValueOf
code-creation,Builtin,2,18064,0x10c19c840,196,NumberParseFloat
code-creation,Builtin,2,18074,0x10c19c940,248,ParseInt
code-creation,Builtin,2,18084,0x10c19ca40,84,NumberParseInt
code-creation,Builtin,2,18093,0x10c19cac0,860,Add
code-creation,Builtin,2,18118,0x10c19ce40,424,Subtract
code-creation,Builtin,2,18128,0x10c19d000,608,Multiply
code-creation,Builtin,2,18138,0x10c19d280,532,Divide
code-creation,Builtin,2,18152,0x10c19d4c0,592,Modulus
code-creation,Builtin,2,18166,0x10c19d740,532,Exponentiate
code-creation,Builtin,2,18186,0x10c19d980,344,Negate
code-creation,Builtin,2,18205,0x10c19db00,112,BitwiseNot
code-creation,Builtin,2,18220,0x10c19db80,112,Decrement
code-creation,Builtin,2,18235,0x10c19dc00,112,Increment
code-creation,Builtin,2,18249,0x10c19dc80,392,ShiftLeft
code-creation,Builtin,2,18263,0x10c19de40,392,ShiftRight
code-creation,Builtin,2,18279,0x10c19e000,508,ShiftRightLogical
code-creation,Builtin,2,18296,0x10c19e200,388,BitwiseAnd
code-creation,Builtin,2,18311,0x10c19e3c0,388,BitwiseOr
code-creation,Builtin,2,18325,0x10c19e580,388,BitwiseXor
code-creation,Builtin,2,18342,0x10c19e740,804,LessThan
code-creation,Builtin,2,18357,0x10c19ea80,804,LessThanOrEqual
code-creation,Builtin,2,18373,0x10c19edc0,804,GreaterThan
code-creation,Builtin,2,18390,0x10c19f100,804,GreaterThanOrEqual
code-creation,Builtin,2,18406,0x10c19f440,864,Equal
code-creation,Builtin,2,18420,0x10c19f7c0,356,StrictEqual
code-creation,Builtin,2,18435,0x10c19f940,3248,ObjectFromEntries
code-creation,Builtin,2,18450,0x10c1a0600,772,CreateObjectWithoutProperties
code-creation,Builtin,2,18467,0x10c1a0940,144,ObjectIsExtensible
code-creation,Builtin,2,18483,0x10c1a0a00,152,ObjectPreventExtensions
code-creation,Builtin,2,18500,0x10c1a0ac0,144,ObjectGetPrototypeOf
code-creation,Builtin,2,18516,0x10c1a0b80,312,ObjectSetPrototypeOf
code-creation,Builtin,2,18532,0x10c1a0cc0,80,ObjectPrototypeToString
code-creation,Builtin,2,18548,0x10c1a0d40,96,ObjectPrototypeValueOf
code-creation,Builtin,2,18561,0x10c1a0dc0,176,ObjectPrototypeToLocaleString
code-creation,Builtin,2,18574,0x10c1a0e80,864,FulfillPromise
code-creation,Builtin,2,18586,0x10c1a1200,984,RejectPromise
code-creation,Builtin,2,18596,0x10c1a1600,2428,NewPromiseCapability
code-creation,Builtin,2,18605,0x10c1a1f80,172,PromiseCapabilityDefaultReject
code-creation,Builtin,2,18615,0x10c1a2040,156,PromiseCapabilityDefaultResolve
code-creation,Builtin,2,18627,0x10c1a2100,1412,PerformPromiseThen
code-creation,Builtin,2,18671,0x10c1a26c0,660,PromiseReject
code-creation,Builtin,2,18743,0x10c1a2980,300,PromiseGetCapabilitiesExecutor
code-creation,Builtin,2,18757,0x10c1a2ac0,112,PromiseConstructorLazyDeoptContinuation
code-creation,Builtin,2,18771,0x10c1a2b40,4612,PromiseAll
code-creation,Builtin,2,18782,0x10c1a3d80,4932,PromiseAllSettled
code-creation,Builtin,2,18792,0x10c1a5100,1112,PromiseAllResolveElementClosure
code-creation,Builtin,2,18807,0x10c1a5580,1404,PromiseAllSettledResolveElementClosure
code-creation,Builtin,2,18880,0x10c1a5b00,1412,PromiseAllSettledRejectElementClosure
code-creation,Builtin,2,18899,0x10c1a60c0,1188,PromiseAnyRejectElementClosure
code-creation,Builtin,2,18915,0x10c1a6580,2404,PromiseAny
code-creation,Builtin,2,18928,0x10c1a6f00,2964,PromiseConstructor
code-creation,Builtin,2,18943,0x10c1a7ac0,300,PromisePrototypeCatch
code-creation,Builtin,2,18958,0x10c1a7c00,88,PromiseValueThunkFinally
code-creation,Builtin,2,18973,0x10c1a7c80,84,PromiseThrowerFinally
code-creation,Builtin,2,18989,0x10c1a7d00,908,PromiseCatchFinally
code-creation,Builtin,2,19004,0x10c1a80c0,908,PromiseThenFinally
code-creation,Builtin,2,19018,0x10c1a8480,1740,PromisePrototypeFinally
code-creation,Builtin,2,19034,0x10c1a8b80,1372,PromiseRace
code-creation,Builtin,2,19048,0x10c1a9100,316,PromiseFulfillReactionJob
code-creation,Builtin,2,19064,0x10c1a9240,424,PromiseRejectReactionJob
code-creation,Builtin,2,19080,0x10c1a9400,156,PromiseResolveTrampoline
code-creation,Builtin,2,19097,0x10c1a94c0,668,PromiseResolve
code-creation,Builtin,2,19113,0x10c1a9780,712,ResolvePromise
code-creation,Builtin,2,19128,0x10c1a9a80,2248,PromisePrototypeThen
code-creation,Builtin,2,19145,0x10c1aa380,1152,PromiseResolveThenableJob
code-creation,Builtin,2,19165,0x10c1aa840,448,ProxyConstructor
code-creation,Builtin,2,19177,0x10c1aaa40,1796,ProxyDeleteProperty
code-creation,Builtin,2,19288,0x10c1ab180,2152,ProxyGetProperty
code-creation,Builtin,2,19313,0x10c1aba00,1084,ProxyGetPrototypeOf
code-creation,Builtin,2,19324,0x10c1abe40,1708,ProxyHasProperty
code-creation,Builtin,2,19338,0x10c1ac500,796,ProxyIsExtensible
code-creation,Builtin,2,19349,0x10c1ac840,840,ProxyPreventExtensions
code-creation,Builtin,2,19361,0x10c1acbc0,1152,ProxyRevocable
code-creation,Builtin,2,19373,0x10c1ad080,132,ProxyRevoke
code-creation,Builtin,2,19384,0x10c1ad140,2264,ProxySetProperty
code-creation,Builtin,2,19395,0x10c1ada40,1340,ProxySetPrototypeOf
code-creation,Builtin,2,19410,0x10c1adf80,212,ReflectIsExtensible
code-creation,Builtin,2,19421,0x10c1ae080,216,ReflectPreventExtensions
code-creation,Builtin,2,19437,0x10c1ae180,188,ReflectGetPrototypeOf
code-creation,Builtin,2,19452,0x10c1ae240,300,ReflectSetPrototypeOf
code-creation,Builtin,2,19466,0x10c1ae380,296,ReflectGet
code-creation,Builtin,2,19480,0x10c1ae4c0,160,ReflectDeleteProperty
code-creation,Builtin,2,19492,0x10c1ae580,148,ReflectHas
code-creation,Builtin,2,19502,0x10c1ae640,5184,RegExpPrototypeExecSlow
code-creation,Builtin,2,19515,0x10c1afac0,5176,RegExpPrototypeExec
code-creation,Builtin,2,19529,0x10c1b0f00,2400,RegExpPrototypeMatchAll
code-creation,Builtin,2,19541,0x10c1b1880,9496,RegExpStringIteratorPrototypeNext
code-creation,Builtin,2,19554,0x10c1b3dc0,8916,RegExpMatchFast
code-creation,Builtin,2,19566,0x10c1b60c0,3640,RegExpPrototypeMatch
code-creation,Builtin,2,19578,0x10c1b6f00,6356,RegExpReplace
code-creation,Builtin,2,19590,0x10c1b8800,528,RegExpPrototypeReplace
code-creation,Builtin,2,19608,0x10c1b8a40,1420,RegExpSearchFast
code-creation,Builtin,2,19622,0x10c1b9000,1652,RegExpPrototypeSearch
code-creation,Builtin,2,19635,0x10c1b9680,200,RegExpPrototypeSourceGetter
code-creation,Builtin,2,19649,0x10c1b9780,5892,RegExpSplit
code-creation,Builtin,2,19661,0x10c1baec0,480,RegExpPrototypeSplit
code-creation,Builtin,2,19674,0x10c1bb0c0,2276,RegExpPrototypeTest
code-creation,Builtin,2,19688,0x10c1bb9c0,1372,RegExpPrototypeTestFast
code-creation,Builtin,2,19701,0x10c1bbf40,236,RegExpPrototypeGlobalGetter
code-creation,Builtin,2,19716,0x10c1bc040,252,RegExpPrototypeIgnoreCaseGetter
code-creation,Builtin,2,19730,0x10c1bc140,252,RegExpPrototypeMultilineGetter
code-creation,Builtin,2,19745,0x10c1bc240,252,RegExpPrototypeHasIndicesGetter
code-creation,Builtin,2,19758,0x10c1bc340,252,RegExpPrototypeLinearGetter
code-creation,Builtin,2,19771,0x10c1bc440,252,RegExpPrototypeDotAllGetter
code-creation,Builtin,2,19818,0x10c1bc540,280,RegExpPrototypeStickyGetter
code-creation,Builtin,2,19833,0x10c1bc680,280,RegExpPrototypeUnicodeGetter
code-creation,Builtin,2,19847,0x10c1bc7c0,2316,RegExpPrototypeFlagsGetter
code-creation,Builtin,2,19871,0x10c1bd100,1516,StringPrototypeAt
code-creation,Builtin,2,19888,0x10c1bd700,3076,StringPrototypeEndsWith
code-creation,Builtin,2,19902,0x10c1be340,488,CreateHTML
code-creation,Builtin,2,19915,0x10c1be540,164,StringPrototypeAnchor
code-creation,Builtin,2,19932,0x10c1be600,132,StringPrototypeBig
code-creation,Builtin,2,19947,0x10c1be6c0,132,StringPrototypeBlink
code-creation,Builtin,2,19978,0x10c1be780,132,StringPrototypeBold
code-creation,Builtin,2,19999,0x10c1be840,172,StringPrototypeFontcolor
code-creation,Builtin,2,20015,0x10c1be900,172,StringPrototypeFontsize
code-creation,Builtin,2,20030,0x10c1be9c0,132,StringPrototypeFixed
code-creation,Builtin,2,20046,0x10c1bea80,132,StringPrototypeItalics
code-creation,Builtin,2,20067,0x10c1beb40,172,StringPrototypeLink
code-creation,Builtin,2,20097,0x10c1bec00,132,StringPrototypeSmall
code-creation,Builtin,2,20114,0x10c1becc0,132,StringPrototypeStrike
code-creation,Builtin,2,20145,0x10c1bed80,132,StringPrototypeSub
code-creation,Builtin,2,20161,0x10c1bee40,132,StringPrototypeSup
code-creation,Builtin,2,20174,0x10c1bef00,1060,StringPrototypeIncludes
code-creation,Builtin,2,20189,0x10c1bf340,644,StringPrototypeIndexOf
code-creation,Builtin,2,20204,0x10c1bf600,348,StringPrototypeIterator
code-creation,Builtin,2,20232,0x10c1bf780,2048,StringIteratorPrototypeNext
code-creation,Builtin,2,20307,0x10c1bffc0,1344,StringPrototypeMatch
code-creation,Builtin,2,20326,0x10c1c0540,1344,StringPrototypeSearch
code-creation,Builtin,2,20339,0x10c1c0ac0,836,StringPrototypePadStart
code-creation,Builtin,2,20354,0x10c1c0e40,840,StringPrototypePadEnd
code-creation,Builtin,2,20367,0x10c1c11c0,120,StringRepeat
code-creation,Builtin,2,20383,0x10c1c1240,408,StringPrototypeRepeat
code-creation,Builtin,2,20397,0x10c1c1400,11280,StringPrototypeReplaceAll
code-creation,Builtin,2,20411,0x10c1c4040,3440,StringPrototypeSlice
code-creation,Builtin,2,20424,0x10c1c4dc0,3092,StringPrototypeStartsWith
code-creation,Builtin,2,20438,0x10c1c5a00,3384,StringPrototypeSubstr
code-creation,Builtin,2,20456,0x10c1c6740,3312,StringPrototypeSubstring
code-creation,Builtin,2,20478,0x10c1c7440,7024,StringPrototypeTrim
code-creation,Builtin,2,20498,0x10c1c8fc0,6428,StringPrototypeTrimStart
code-creation,Builtin,2,20521,0x10c1ca900,5944,StringPrototypeTrimEnd
code-creation,Builtin,2,20541,0x10c1cc040,164,SymbolPrototypeDescriptionGetter
code-creation,Builtin,2,20560,0x10c1cc100,156,SymbolPrototypeToPrimitive
code-creation,Builtin,2,20578,0x10c1cc1c0,176,SymbolPrototypeToString
code-creation,Builtin,2,20591,0x10c1cc280,156,SymbolPrototypeValueOf
code-creation,Builtin,2,20603,0x10c1cc340,836,TypedArrayPrototypeAt
code-creation,Builtin,2,20617,0x10c1cc6c0,10168,CreateTypedArray
code-creation,Builtin,2,20636,0x10c1cee80,1044,TypedArrayPrototypeEvery
code-creation,Builtin,2,20652,0x10c1cf2c0,372,TypedArrayPrototypeEntries
code-creation,Builtin,2,20665,0x10c1cf440,3572,TypedArrayPrototypeFilter
code-creation,Builtin,2,20865,0x10c1d0240,1044,TypedArrayPrototypeFind
code-creation,Builtin,2,20904,0x10c1d0680,1048,TypedArrayPrototypeFindIndex
code-creation,Builtin,2,20917,0x10c1d0ac0,1036,TypedArrayPrototypeFindLast
code-creation,Builtin,2,20930,0x10c1d0f00,1040,TypedArrayPrototypeFindLastIndex
code-creation,Builtin,2,20944,0x10c1d1340,904,TypedArrayPrototypeForEach
code-creation,Builtin,2,20959,0x10c1d1700,2372,TypedArrayFrom
code-creation,Builtin,2,20989,0x10c1d2080,356,TypedArrayPrototypeKeys
code-creation,Builtin,2,21020,0x10c1d2200,1032,TypedArrayOf
code-creation,Builtin,2,21038,0x10c1d2640,1016,TypedArrayPrototypeReduce
code-creation,Builtin,2,21051,0x10c1d2a40,1012,TypedArrayPrototypeReduceRight
code-creation,Builtin,2,21108,0x10c1d2e40,2512,TypedArrayPrototypeSet
code-creation,Builtin,2,21123,0x10c1d3840,3100,TypedArrayPrototypeSlice
code-creation,Builtin,2,21141,0x10c1d4480,1044,TypedArrayPrototypeSome
code-creation,Builtin,2,21154,0x10c1d48c0,1056,TypedArrayMergeSort
code-creation,Builtin,2,21247,0x10c1d4d00,1644,TypedArrayPrototypeSort
code-creation,Builtin,2,21271,0x10c1d5380,2784,TypedArrayPrototypeSubArray
code-creation,Builtin,2,21279,0x10c1d5e80,372,TypedArrayPrototypeValues
code-creation,Builtin,2,21287,0x10c1d6000,980,WeakRefConstructor
code-creation,Builtin,2,21294,0x10c1d6400,184,WeakRefDeref
code-creation,Builtin,2,21301,0x10c1d64c0,696,NewSloppyArgumentsElements
code-creation,Builtin,2,21308,0x10c1d6780,308,NewStrictArgumentsElements
code-creation,Builtin,2,21315,0x10c1d68c0,336,NewRestArgumentsElements
code-creation,Builtin,2,21323,0x10c1d6a40,1404,FastNewSloppyArguments
code-creation,Builtin,2,21330,0x10c1d6fc0,528,FastNewStrictArguments
code-creation,Builtin,2,21338,0x10c1d7200,560,FastNewRestArguments
code-creation,Builtin,2,21345,0x10c1d7440,700,StringSlowFlatten
code-creation,Builtin,2,21352,0x10c1d7700,2096,StringIndexOf
code-creation,Builtin,2,21359,0x10c1d7f40,4,GenericBuiltinTest_JSAny_0
code-creation,Builtin,2,21366,0x10c1d7f80,20,TestHelperPlus1
code-creation,Builtin,2,21381,0x10c1d7fc0,20,TestHelperPlus2
code-creation,Builtin,2,21388,0x10c1d8000,96,NewSmiBox
code-creation,Builtin,2,21394,0x10c1d8080,24,ReturnTwoValues
code-creation,Builtin,2,21404,0x10c1d80c0,32,Load_FastSmiElements_0
code-creation,Builtin,2,21419,0x10c1d8100,32,Load_FastObjectElements_0
code-creation,Builtin,2,21435,0x10c1d8140,148,Load_FastDoubleElements_0
code-creation,Builtin,2,21451,0x10c1d8200,32,Store_FastSmiElements_0
code-creation,Builtin,2,21466,0x10c1d8240,92,Store_FastObjectElements_0
code-creation,Builtin,2,21528,0x10c1d82c0,48,Store_FastDoubleElements_0
code-creation,Builtin,2,21545,0x10c1d8300,40,Delete_FastSmiElements_0
code-creation,Builtin,2,21562,0x10c1d8340,40,Delete_FastObjectElements_0
code-creation,Builtin,2,21578,0x10c1d8380,44,Delete_FastDoubleElements_0
code-creation,Builtin,2,21594,0x10c1d83c0,324,SortCompareDefault
code-creation,Builtin,2,21609,0x10c1d8540,96,SortCompareUserFn
code-creation,Builtin,2,21624,0x10c1d85c0,12,CanUseSameAccessor_GenericElementsAccessor_0
code-creation,Builtin,2,21640,0x10c1d8600,308,Copy
code-creation,Builtin,2,21653,0x10c1d8740,5756,MergeAt
code-creation,Builtin,2,21666,0x10c1d9dc0,792,GallopLeft
code-creation,Builtin,2,21679,0x10c1da100,832,GallopRight
code-creation,Builtin,2,21694,0x10c1da480,3836,ArrayTimSort
code-creation,Builtin,2,21708,0x10c1db380,2144,ArrayPrototypeSort
code-creation,Builtin,2,21723,0x10c1dbc00,100,WasmInt32ToHeapNumber
code-creation,Builtin,2,21739,0x10c1dbc80,124,WasmTaggedNonSmiToInt32
code-creation,Builtin,2,21755,0x10c1dbd00,76,WasmTaggedToFloat64
code-creation,Builtin,2,21770,0x10c1dbd80,72,WasmMemoryGrow
code-creation,Builtin,2,21785,0x10c1dbe00,100,WasmTableInit
code-creation,Builtin,2,21800,0x10c1dbe80,100,WasmTableCopy
code-creation,Builtin,2,21816,0x10c1dbf00,84,WasmTableFill
code-creation,Builtin,2,21832,0x10c1dbf80,72,WasmTableGrow
code-creation,Builtin,2,21847,0x10c1dc000,144,WasmTableGet
code-creation,Builtin,2,21899,0x10c1dc0c0,236,WasmTableSet
code-creation,Builtin,2,21925,0x10c1dc1c0,96,WasmRefFunc
code-creation,Builtin,2,21940,0x10c1dc240,148,WasmAllocateFixedArray
code-creation,Builtin,2,21954,0x10c1dc300,44,WasmThrow
code-creation,Builtin,2,21968,0x10c1dc340,56,WasmRethrow
code-creation,Builtin,2,21982,0x10c1dc380,44,WasmTriggerTierUp
code-creation,Builtin,2,21996,0x10c1dc3c0,32,WasmStackGuard
code-creation,Builtin,2,22011,0x10c1dc400,32,WasmStackOverflow
code-creation,Builtin,2,22024,0x10c1dc440,40,WasmTraceMemory
code-creation,Builtin,2,22039,0x10c1dc480,32,WasmTraceEnter
tick,0x7fff2029a527,22069,0,0x0,6
tick,0x7fff20385289,22085,0,0x0,6
tick,0x7fff203565fe,22097,0,0x0,6
tick,0x7fff203572be,22121,0,0x0,6
tick,0x7fff203572be,22141,0,0x0,6
tick,0x7fff2038537c,22152,0,0x0,6
tick,0x7fff202f5d79,22162,0,0x0,6
tick,0x7fff203572be,22173,0,0x0,6
code-creation,Builtin,2,22186,0x10c1dc4c0,40,WasmTraceExit
code-creation,Builtin,2,22206,0x10c1dc500,344,WasmAllocateJSArray
code-creation,Builtin,2,22236,0x10c1dc680,104,WasmAllocatePair
code-creation,Builtin,2,22249,0x10c1dc700,64,WasmAllocateRtt
code-creation,Builtin,2,22256,0x10c1dc780,72,WasmAllocateFreshRtt
code-creation,Builtin,2,22286,0x10c1dc800,124,WasmAllocateStructWithRtt
code-creation,Builtin,2,22298,0x10c1dc880,140,WasmAllocateArray_Uninitialized
code-creation,Builtin,2,22308,0x10c1dc940,176,WasmAllocateArray_InitZero
code-creation,Builtin,2,22318,0x10c1dca00,180,WasmAllocateArray_InitNull
code-creation,Builtin,2,22327,0x10c1dcac0,120,WasmArrayCopyWithChecks
code-creation,Builtin,2,22336,0x10c1dcb40,248,WasmAllocateObjectWrapper
code-creation,Builtin,2,22346,0x10c1dcc40,52,WasmSubtypeCheck
code-creation,Builtin,2,22353,0x10c1dcc80,8,WasmInt32ToNumber
code-creation,Builtin,2,22362,0x10c1dccc0,116,WasmUint32ToNumber
code-creation,Builtin,2,22370,0x10c1dcd40,144,UintPtr53ToNumber
code-creation,Builtin,2,22379,0x10c1dce00,96,WasmAtomicNotify
code-creation,Builtin,2,22388,0x10c1dce80,116,WasmI32AtomicWait64
code-creation,Builtin,2,22397,0x10c1dcf00,116,WasmI64AtomicWait64
code-creation,Builtin,2,22406,0x10c1dcf80,596,WasmGetOwnProperty
code-creation,Builtin,2,22415,0x10c1dd200,40,WasmTrap
code-creation,Builtin,2,22424,0x10c1dd240,16,ThrowWasmTrapUnreachable
code-creation,Builtin,2,22433,0x10c1dd280,16,ThrowWasmTrapMemOutOfBounds
code-creation,Builtin,2,22442,0x10c1dd2c0,16,ThrowWasmTrapUnalignedAccess
code-creation,Builtin,2,22452,0x10c1dd300,16,ThrowWasmTrapDivByZero
code-creation,Builtin,2,22461,0x10c1dd340,16,ThrowWasmTrapDivUnrepresentable
code-creation,Builtin,2,22470,0x10c1dd380,16,ThrowWasmTrapRemByZero
code-creation,Builtin,2,22498,0x10c1dd3c0,16,ThrowWasmTrapFloatUnrepresentable
code-creation,Builtin,2,22508,0x10c1dd400,16,ThrowWasmTrapFuncSigMismatch
code-creation,Builtin,2,22518,0x10c1dd440,16,ThrowWasmTrapDataSegmentDropped
code-creation,Builtin,2,22528,0x10c1dd480,16,ThrowWasmTrapElemSegmentDropped
code-creation,Builtin,2,22537,0x10c1dd4c0,16,ThrowWasmTrapTableOutOfBounds
code-creation,Builtin,2,22547,0x10c1dd500,16,ThrowWasmTrapRethrowNull
code-creation,Builtin,2,22557,0x10c1dd540,16,ThrowWasmTrapNullDereference
code-creation,Builtin,2,22567,0x10c1dd580,16,ThrowWasmTrapIllegalCast
code-creation,Builtin,2,22576,0x10c1dd5c0,16,ThrowWasmTrapArrayOutOfBounds
code-creation,Builtin,2,22587,0x10c1dd600,16,ThrowWasmTrapArrayTooLarge
code-creation,Builtin,2,22597,0x10c1dd640,172,LoadJoinElement_GenericElementsAccessor_0
code-creation,Builtin,2,22609,0x10c1dd700,24,LoadJoinTypedElement_Int32Elements_0
code-creation,Builtin,2,22620,0x10c1dd740,116,LoadJoinTypedElement_Float32Elements_0
code-creation,Builtin,2,22630,0x10c1dd7c0,112,LoadJoinTypedElement_Float64Elements_0
code-creation,Builtin,2,22641,0x10c1dd840,24,LoadJoinTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,22651,0x10c1dd880,220,LoadJoinTypedElement_BigUint64Elements_0
code-creation,Builtin,2,22662,0x10c1dd980,248,LoadJoinTypedElement_BigInt64Elements_0
code-creation,Builtin,2,22672,0x10c1dda80,24,LoadJoinTypedElement_Uint8Elements_0
code-creation,Builtin,2,22683,0x10c1ddac0,24,LoadJoinTypedElement_Int8Elements_0
code-creation,Builtin,2,22719,0x10c1ddb00,24,LoadJoinTypedElement_Uint16Elements_0
code-creation,Builtin,2,22734,0x10c1ddb40,24,LoadJoinTypedElement_Int16Elements_0
code-creation,Builtin,2,22742,0x10c1ddb80,132,LoadJoinTypedElement_Uint32Elements_0
code-creation,Builtin,2,22750,0x10c1ddc40,12,GenericBuiltinTest_Smi_0
code-creation,Builtin,2,22758,0x10c1ddc80,40,CanUseSameAccessor_FastDoubleElements_0
code-creation,Builtin,2,22765,0x10c1ddcc0,40,CanUseSameAccessor_FastSmiElements_0
code-creation,Builtin,2,22773,0x10c1ddd00,40,CanUseSameAccessor_FastObjectElements_0
code-creation,Builtin,2,22844,0x10c1ddd40,2740,Load_GenericElementsAccessor_0
code-creation,Builtin,2,22871,0x10c1de800,24,Store_GenericElementsAccessor_0
code-creation,Builtin,2,22887,0x10c1de840,36,Delete_GenericElementsAccessor_0
code-creation,Builtin,2,22910,0x10c1de880,24,LoadTypedElement_Int32Elements_0
code-creation,Builtin,2,22921,0x10c1de8c0,164,StoreTypedElementNumeric_Int32Elements_0
code-creation,Builtin,2,22934,0x10c1de980,180,StoreTypedElementJSAny_Int32Elements_0
code-creation,Builtin,2,22946,0x10c1dea40,116,LoadTypedElement_Float32Elements_0
code-creation,Builtin,2,22986,0x10c1deac0,32,StoreTypedElementNumeric_Float32Elements_0
code-creation,Builtin,2,22998,0x10c1deb00,156,StoreTypedElementJSAny_Float32Elements_0
code-creation,Builtin,2,23010,0x10c1debc0,112,LoadTypedElement_Float64Elements_0
code-creation,Builtin,2,23022,0x10c1dec40,28,StoreTypedElementNumeric_Float64Elements_0
code-creation,Builtin,2,23038,0x10c1dec80,152,StoreTypedElementJSAny_Float64Elements_0
code-creation,Builtin,2,23051,0x10c1ded40,24,LoadTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,23074,0x10c1ded80,24,StoreTypedElementNumeric_Uint8ClampedElements_0
code-creation,Builtin,2,23123,0x10c1dedc0,620,StoreTypedElementJSAny_Uint8ClampedElements_0
code-creation,Builtin,2,23137,0x10c1df040,220,LoadTypedElement_BigUint64Elements_0
code-creation,Builtin,2,23152,0x10c1df140,56,StoreTypedElementNumeric_BigUint64Elements_0
code-creation,Builtin,2,23181,0x10c1df180,200,StoreTypedElementJSAny_BigUint64Elements_0
code-creation,Builtin,2,23197,0x10c1df280,248,LoadTypedElement_BigInt64Elements_0
code-creation,Builtin,2,23212,0x10c1df380,56,StoreTypedElementNumeric_BigInt64Elements_0
code-creation,Builtin,2,23228,0x10c1df3c0,200,StoreTypedElementJSAny_BigInt64Elements_0
code-creation,Builtin,2,23243,0x10c1df4c0,24,LoadTypedElement_Uint8Elements_0
code-creation,Builtin,2,23262,0x10c1df500,24,StoreTypedElementNumeric_Uint8Elements_0
code-creation,Builtin,2,23286,0x10c1df540,180,StoreTypedElementJSAny_Uint8Elements_0
code-creation,Builtin,2,23328,0x10c1df600,24,LoadTypedElement_Int8Elements_0
code-creation,Builtin,2,23347,0x10c1df640,24,StoreTypedElementNumeric_Int8Elements_0
code-creation,Builtin,2,23368,0x10c1df680,180,StoreTypedElementJSAny_Int8Elements_0
code-creation,Builtin,2,23398,0x10c1df740,24,LoadTypedElement_Uint16Elements_0
code-creation,Builtin,2,23424,0x10c1df780,24,StoreTypedElementNumeric_Uint16Elements_0
code-creation,Builtin,2,23447,0x10c1df7c0,180,StoreTypedElementJSAny_Uint16Elements_0
code-creation,Builtin,2,23467,0x10c1df880,24,LoadTypedElement_Int16Elements_0
code-creation,Builtin,2,23486,0x10c1df8c0,24,StoreTypedElementNumeric_Int16Elements_0
code-creation,Builtin,2,23510,0x10c1df900,180,StoreTypedElementJSAny_Int16Elements_0
code-creation,Builtin,2,23525,0x10c1df9c0,132,LoadTypedElement_Uint32Elements_0
code-creation,Builtin,2,23539,0x10c1dfa80,164,StoreTypedElementNumeric_Uint32Elements_0
code-creation,Builtin,2,23558,0x10c1dfb40,180,StoreTypedElementJSAny_Uint32Elements_0
code-creation,Builtin,2,23577,0x10c1dfc00,12,CollatorConstructor
code-creation,Builtin,2,23593,0x10c1dfc40,12,CollatorInternalCompare
code-creation,Builtin,2,23605,0x10c1dfc80,12,CollatorPrototypeCompare
code-creation,Builtin,2,23621,0x10c1dfcc0,12,CollatorSupportedLocalesOf
code-creation,Builtin,2,23686,0x10c1dfd00,12,CollatorPrototypeResolvedOptions
code-creation,Builtin,2,23741,0x10c1dfd40,12,DatePrototypeToLocaleDateString
code-creation,Builtin,2,23755,0x10c1dfd80,12,DatePrototypeToLocaleString
code-creation,Builtin,2,23766,0x10c1dfdc0,12,DatePrototypeToLocaleTimeString
code-creation,Builtin,2,23776,0x10c1dfe00,12,DateTimeFormatConstructor
code-creation,Builtin,2,23786,0x10c1dfe40,12,DateTimeFormatInternalFormat
code-creation,Builtin,2,23798,0x10c1dfe80,12,DateTimeFormatPrototypeFormat
code-creation,Builtin,2,23808,0x10c1dfec0,12,DateTimeFormatPrototypeFormatRange
code-creation,Builtin,2,23819,0x10c1dff00,12,DateTimeFormatPrototypeFormatRangeToParts
code-creation,Builtin,2,23830,0x10c1dff40,12,DateTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,23840,0x10c1dff80,12,DateTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,23850,0x10c1dffc0,12,DateTimeFormatSupportedLocalesOf
code-creation,Builtin,2,23861,0x10c1e0000,12,DisplayNamesConstructor
code-creation,Builtin,2,23872,0x10c1e0040,12,DisplayNamesPrototypeOf
code-creation,Builtin,2,23883,0x10c1e0080,12,DisplayNamesPrototypeResolvedOptions
code-creation,Builtin,2,23893,0x10c1e00c0,12,DisplayNamesSupportedLocalesOf
code-creation,Builtin,2,23904,0x10c1e0100,12,IntlGetCanonicalLocales
code-creation,Builtin,2,23916,0x10c1e0140,12,IntlSupportedValuesOf
code-creation,Builtin,2,23924,0x10c1e0180,12,ListFormatConstructor
code-creation,Builtin,2,23933,0x10c1e01c0,228,ListFormatPrototypeFormat
code-creation,Builtin,2,23943,0x10c1e02c0,228,ListFormatPrototypeFormatToParts
code-creation,Builtin,2,23954,0x10c1e03c0,12,ListFormatPrototypeResolvedOptions
code-creation,Builtin,2,23965,0x10c1e0400,12,ListFormatSupportedLocalesOf
code-creation,Builtin,2,23976,0x10c1e0440,12,LocaleConstructor
code-creation,Builtin,2,23986,0x10c1e0480,12,LocalePrototypeBaseName
code-creation,Builtin,2,23998,0x10c1e04c0,12,LocalePrototypeCalendar
code-creation,Builtin,2,24009,0x10c1e0500,12,LocalePrototypeCalendars
code-creation,Builtin,2,24021,0x10c1e0540,12,LocalePrototypeCaseFirst
code-creation,Builtin,2,24031,0x10c1e0580,12,LocalePrototypeCollation
code-creation,Builtin,2,24041,0x10c1e05c0,12,LocalePrototypeCollations
code-creation,Builtin,2,24051,0x10c1e0600,12,LocalePrototypeHourCycle
code-creation,Builtin,2,24061,0x10c1e0640,12,LocalePrototypeHourCycles
code-creation,Builtin,2,24071,0x10c1e0680,12,LocalePrototypeLanguage
code-creation,Builtin,2,24082,0x10c1e06c0,12,LocalePrototypeMaximize
code-creation,Builtin,2,24091,0x10c1e0700,12,LocalePrototypeMinimize
code-creation,Builtin,2,24100,0x10c1e0740,12,LocalePrototypeNumeric
code-creation,Builtin,2,24108,0x10c1e0780,12,LocalePrototypeNumberingSystem
code-creation,Builtin,2,24120,0x10c1e07c0,12,LocalePrototypeNumberingSystems
code-creation,Builtin,2,24168,0x10c1e0800,12,LocalePrototypeRegion
code-creation,Builtin,2,24177,0x10c1e0840,12,LocalePrototypeScript
code-creation,Builtin,2,24187,0x10c1e0880,12,LocalePrototypeTextInfo
code-creation,Builtin,2,24198,0x10c1e08c0,12,LocalePrototypeTimeZones
code-creation,Builtin,2,24209,0x10c1e0900,12,LocalePrototypeToString
code-creation,Builtin,2,24219,0x10c1e0940,12,LocalePrototypeWeekInfo
code-creation,Builtin,2,24230,0x10c1e0980,12,NumberFormatConstructor
code-creation,Builtin,2,24241,0x10c1e09c0,12,NumberFormatInternalFormatNumber
code-creation,Builtin,2,24252,0x10c1e0a00,12,NumberFormatPrototypeFormatNumber
code-creation,Builtin,2,24262,0x10c1e0a40,12,NumberFormatPrototypeFormatToParts
code-creation,Builtin,2,24275,0x10c1e0a80,12,NumberFormatPrototypeResolvedOptions
code-creation,Builtin,2,24286,0x10c1e0ac0,12,NumberFormatSupportedLocalesOf
code-creation,Builtin,2,24297,0x10c1e0b00,12,PluralRulesConstructor
code-creation,Builtin,2,24307,0x10c1e0b40,12,PluralRulesPrototypeResolvedOptions
code-creation,Builtin,2,24318,0x10c1e0b80,12,PluralRulesPrototypeSelect
code-creation,Builtin,2,24328,0x10c1e0bc0,12,PluralRulesSupportedLocalesOf
code-creation,Builtin,2,24339,0x10c1e0c00,12,RelativeTimeFormatConstructor
code-creation,Builtin,2,24351,0x10c1e0c40,12,RelativeTimeFormatPrototypeFormat
code-creation,Builtin,2,24362,0x10c1e0c80,12,RelativeTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,24373,0x10c1e0cc0,12,RelativeTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,24385,0x10c1e0d00,12,RelativeTimeFormatSupportedLocalesOf
code-creation,Builtin,2,24395,0x10c1e0d40,12,SegmenterConstructor
code-creation,Builtin,2,24406,0x10c1e0d80,12,SegmenterPrototypeResolvedOptions
code-creation,Builtin,2,24415,0x10c1e0dc0,12,SegmenterPrototypeSegment
code-creation,Builtin,2,24424,0x10c1e0e00,12,SegmenterSupportedLocalesOf
code-creation,Builtin,2,24433,0x10c1e0e40,12,SegmentIteratorPrototypeNext
code-creation,Builtin,2,24442,0x10c1e0e80,12,SegmentsPrototypeContaining
code-creation,Builtin,2,24450,0x10c1e0ec0,12,SegmentsPrototypeIterator
code-creation,Builtin,2,24458,0x10c1e0f00,12,StringPrototypeNormalizeIntl
code-creation,Builtin,2,24466,0x10c1e0f40,12,StringPrototypeToLocaleLowerCase
code-creation,Builtin,2,24478,0x10c1e0f80,12,StringPrototypeToLocaleUpperCase
code-creation,Builtin,2,24527,0x10c1e0fc0,204,StringPrototypeToLowerCaseIntl
code-creation,Builtin,2,24705,0x10c1e10c0,12,StringPrototypeToUpperCaseIntl
code-creation,Builtin,2,24735,0x10c1e1100,648,StringToLowerCaseIntl
code-creation,Builtin,2,24748,0x10c1e13c0,12,V8BreakIteratorConstructor
code-creation,Builtin,2,24762,0x10c1e1400,12,V8BreakIteratorInternalAdoptText
code-creation,Builtin,2,24776,0x10c1e1440,12,V8BreakIteratorInternalBreakType
code-creation,Builtin,2,24790,0x10c1e1480,12,V8BreakIteratorInternalCurrent
tick,0x7fff2035476a,24829,0,0x0,6
tick,0x7fff203572be,24847,0,0x0,6
tick,0x10c4cccbc,24860,0,0x0,6
code-creation,Builtin,2,24871,0x10c1e14c0,12,V8BreakIteratorInternalFirst
code-creation,Builtin,2,24885,0x10c1e1500,12,V8BreakIteratorInternalNext
code-creation,Builtin,2,24898,0x10c1e1540,12,V8BreakIteratorPrototypeAdoptText
code-creation,Builtin,2,24912,0x10c1e1580,12,V8BreakIteratorPrototypeBreakType
code-creation,Builtin,2,24926,0x10c1e15c0,12,V8BreakIteratorPrototypeCurrent
code-creation,Builtin,2,24939,0x10c1e1600,12,V8BreakIteratorPrototypeFirst
code-creation,Builtin,2,24953,0x10c1e1640,12,V8BreakIteratorPrototypeNext
code-creation,Builtin,2,24966,0x10c1e1680,12,V8BreakIteratorPrototypeResolvedOptions
code-creation,Builtin,2,24980,0x10c1e16c0,12,V8BreakIteratorSupportedLocalesOf
code-creation,BytecodeHandler,0,25006,0x10c1e1700,24,Wide
code-creation,BytecodeHandler,0,25020,0x10c1e1740,24,ExtraWide
code-creation,BytecodeHandler,0,25034,0x10c1e1780,104,DebugBreakWide
code-creation,BytecodeHandler,0,25047,0x10c1e1800,104,DebugBreakExtraWide
code-creation,BytecodeHandler,0,25061,0x10c1e1880,164,DebugBreak0
code-creation,BytecodeHandler,0,25073,0x10c1e1940,104,DebugBreak1
code-creation,BytecodeHandler,0,25086,0x10c1e19c0,104,DebugBreak2
code-creation,BytecodeHandler,0,25189,0x10c1e1a40,104,DebugBreak3
code-creation,BytecodeHandler,0,25222,0x10c1e1ac0,104,DebugBreak4
code-creation,BytecodeHandler,0,25237,0x10c1e1b40,104,DebugBreak5
code-creation,BytecodeHandler,0,25326,0x10c1e1bc0,104,DebugBreak6
code-creation,BytecodeHandler,0,25354,0x10c1e1c40,32,Ldar
code-creation,BytecodeHandler,0,25368,0x10c1e1c80,68,LdaZero
code-creation,BytecodeHandler,0,25381,0x10c1e1d00,76,LdaSmi
code-creation,BytecodeHandler,0,25397,0x10c1e1d80,72,LdaUndefined
code-creation,BytecodeHandler,0,25409,0x10c1e1e00,72,LdaNull
code-creation,BytecodeHandler,0,25420,0x10c1e1e80,72,LdaTheHole
code-creation,BytecodeHandler,0,25432,0x10c1e1f00,24,LdaTrue
code-creation,BytecodeHandler,0,25442,0x10c1e1f40,24,LdaFalse
code-creation,BytecodeHandler,0,25454,0x10c1e1f80,76,LdaConstant
code-creation,BytecodeHandler,0,25466,0x10c1e2000,132,LdaContextSlot
code-creation,BytecodeHandler,0,25477,0x10c1e20c0,132,LdaImmutableContextSlot
code-creation,BytecodeHandler,0,25490,0x10c1e2180,88,LdaCurrentContextSlot
code-creation,BytecodeHandler,0,25506,0x10c1e2200,88,LdaImmutableCurrentContextSlot
code-creation,BytecodeHandler,0,25522,0x10c1e2280,32,Star
code-creation,BytecodeHandler,0,25537,0x10c1e22c0,40,Mov
code-creation,BytecodeHandler,0,25549,0x10c1e2300,40,PushContext
code-creation,BytecodeHandler,0,25561,0x10c1e2340,36,PopContext
code-creation,BytecodeHandler,0,25575,0x10c1e2380,56,TestReferenceEqual
code-creation,BytecodeHandler,0,25588,0x10c1e23c0,60,TestUndetectable
code-creation,BytecodeHandler,0,25601,0x10c1e2400,44,TestNull
code-creation,BytecodeHandler,0,25614,0x10c1e2440,44,TestUndefined
code-creation,BytecodeHandler,0,25627,0x10c1e2480,360,TestTypeOf
code-creation,BytecodeHandler,0,25641,0x10c1e2600,6092,LdaGlobal
code-creation,BytecodeHandler,0,25655,0x10c1e3e00,4596,LdaGlobalInsideTypeof
code-creation,BytecodeHandler,0,25675,0x10c1e5000,160,StaGlobal
code-creation,BytecodeHandler,0,25687,0x10c1e50c0,156,StaContextSlot
code-creation,BytecodeHandler,0,25701,0x10c1e5180,112,StaCurrentContextSlot
code-creation,BytecodeHandler,0,25716,0x10c1e5200,124,LdaLookupSlot
code-creation,BytecodeHandler,0,25743,0x10c1e5280,244,LdaLookupContextSlot
code-creation,BytecodeHandler,0,25770,0x10c1e5380,4840,LdaLookupGlobalSlot
code-creation,BytecodeHandler,0,25783,0x10c1e6680,124,LdaLookupSlotInsideTypeof
code-creation,BytecodeHandler,0,25796,0x10c1e6700,244,LdaLookupContextSlotInsideTypeof
code-creation,BytecodeHandler,0,25836,0x10c1e6800,4808,LdaLookupGlobalSlotInsideTypeof
code-creation,BytecodeHandler,0,25856,0x10c1e7b00,220,StaLookupSlot
code-creation,BytecodeHandler,0,25872,0x10c1e7c00,5284,LdaNamedProperty
code-creation,BytecodeHandler,0,25887,0x10c1e90c0,184,LdaNamedPropertyFromSuper
code-creation,BytecodeHandler,0,25904,0x10c1e9180,216,LdaKeyedProperty
code-creation,BytecodeHandler,0,25917,0x10c1e9280,160,LdaModuleVariable
code-creation,BytecodeHandler,0,25930,0x10c1e9340,292,StaModuleVariable
code-creation,BytecodeHandler,0,25945,0x10c1e9480,176,StaNamedProperty
code-creation,BytecodeHandler,0,25959,0x10c1e9540,176,StaNamedOwnProperty
code-creation,BytecodeHandler,0,25970,0x10c1e9600,168,StaKeyedProperty
code-creation,BytecodeHandler,0,26004,0x10c1e96c0,168,StaInArrayLiteral
code-creation,BytecodeHandler,0,26015,0x10c1e9780,200,StaDataPropertyInLiteral
code-creation,BytecodeHandler,0,26023,0x10c1e9880,164,CollectTypeProfile
code-creation,BytecodeHandler,0,26031,0x10c1e9940,1036,Add
code-creation,BytecodeHandler,0,26037,0x10c1e9d80,1072,Sub
code-creation,BytecodeHandler,0,26044,0x10c1ea1c0,1032,Mul
code-creation,BytecodeHandler,0,26051,0x10c1ea600,992,Div
code-creation,BytecodeHandler,0,26057,0x10c1eaa00,920,Mod
code-creation,BytecodeHandler,0,26064,0x10c1eadc0,984,Exp
code-creation,BytecodeHandler,0,26071,0x10c1eb1c0,884,BitwiseOr
code-creation,BytecodeHandler,0,26078,0x10c1eb540,892,BitwiseXor
code-creation,BytecodeHandler,0,26087,0x10c1eb8c0,892,BitwiseAnd
code-creation,BytecodeHandler,0,26096,0x10c1ebc40,904,ShiftLeft
code-creation,BytecodeHandler,0,26105,0x10c1ec000,904,ShiftRight
code-creation,BytecodeHandler,0,26114,0x10c1ec3c0,1028,ShiftRightLogical
code-creation,BytecodeHandler,0,26137,0x10c1ec800,964,AddSmi
code-creation,BytecodeHandler,0,26145,0x10c1ecc00,1008,SubSmi
code-creation,BytecodeHandler,0,26151,0x10c1ed000,920,MulSmi
code-creation,BytecodeHandler,0,26158,0x10c1ed3c0,928,DivSmi
code-creation,BytecodeHandler,0,26165,0x10c1ed780,824,ModSmi
code-creation,BytecodeHandler,0,26172,0x10c1edac0,892,ExpSmi
code-creation,BytecodeHandler,0,26179,0x10c1ede40,492,BitwiseOrSmi
code-creation,BytecodeHandler,0,26188,0x10c1ee040,492,BitwiseXorSmi
code-creation,BytecodeHandler,0,26197,0x10c1ee240,492,BitwiseAndSmi
code-creation,BytecodeHandler,0,26204,0x10c1ee440,492,ShiftLeftSmi
code-creation,BytecodeHandler,0,26211,0x10c1ee640,492,ShiftRightSmi
code-creation,BytecodeHandler,0,26218,0x10c1ee840,644,ShiftRightLogicalSmi
code-creation,BytecodeHandler,0,26225,0x10c1eeb00,664,Inc
code-creation,BytecodeHandler,0,26232,0x10c1eedc0,664,Dec
code-creation,BytecodeHandler,0,26239,0x10c1ef080,648,Negate
code-creation,BytecodeHandler,0,26245,0x10c1ef340,488,BitwiseNot
code-creation,BytecodeHandler,0,26252,0x10c1ef540,120,ToBooleanLogicalNot
code-creation,BytecodeHandler,0,26262,0x10c1ef5c0,44,LogicalNot
code-creation,BytecodeHandler,0,26271,0x10c1ef600,208,TypeOf
code-creation,BytecodeHandler,0,26280,0x10c1ef700,120,DeletePropertyStrict
code-creation,BytecodeHandler,0,26289,0x10c1ef780,112,DeletePropertySloppy
code-creation,BytecodeHandler,0,26300,0x10c1ef800,40,GetSuperConstructor
code-creation,BytecodeHandler,0,26309,0x10c1ef840,1120,CallAnyReceiver
code-creation,BytecodeHandler,0,26316,0x10c1efcc0,1120,CallProperty
code-creation,BytecodeHandler,0,26323,0x10c1f0140,1004,CallProperty0
code-creation,BytecodeHandler,0,26330,0x10c1f0540,1020,CallProperty1
code-creation,BytecodeHandler,0,26338,0x10c1f0940,1032,CallProperty2
code-creation,BytecodeHandler,0,26345,0x10c1f0d80,1004,CallUndefinedReceiver
code-creation,BytecodeHandler,0,26352,0x10c1f1180,1048,CallUndefinedReceiver0
code-creation,BytecodeHandler,0,26360,0x10c1f15c0,1020,CallUndefinedReceiver1
code-creation,BytecodeHandler,0,26371,0x10c1f19c0,1040,CallUndefinedReceiver2
code-creation,BytecodeHandler,0,26381,0x10c1f1e00,1120,CallWithSpread
code-creation,BytecodeHandler,0,26389,0x10c1f2280,124,CallRuntime
code-creation,BytecodeHandler,0,26396,0x10c1f2300,156,CallRuntimeForPair
code-creation,BytecodeHandler,0,26404,0x10c1f23c0,80,CallJSRuntime
code-creation,BytecodeHandler,0,26411,0x10c1f2440,1248,InvokeIntrinsic
code-creation,BytecodeHandler,0,26418,0x10c1f2940,1020,Construct
code-creation,BytecodeHandler,0,26425,0x10c1f2d40,544,ConstructWithSpread
code-creation,BytecodeHandler,0,26433,0x10c1f2f80,1948,TestEqual
code-creation,BytecodeHandler,0,26440,0x10c1f3740,1076,TestEqualStrict
code-creation,BytecodeHandler,0,26447,0x10c1f3b80,1636,TestLessThan
code-creation,BytecodeHandler,0,26456,0x10c1f4200,1636,TestGreaterThan
code-creation,BytecodeHandler,0,26465,0x10c1f4880,1636,TestLessThanOrEqual
code-creation,BytecodeHandler,0,26473,0x10c1f4f00,1636,TestGreaterThanOrEqual
code-creation,BytecodeHandler,0,26480,0x10c1f5580,884,TestInstanceOf
code-creation,BytecodeHandler,0,26488,0x10c1f5900,160,TestIn
code-creation,BytecodeHandler,0,26494,0x10c1f59c0,112,ToName
code-creation,BytecodeHandler,0,26501,0x10c1f5a40,220,ToNumber
code-creation,BytecodeHandler,0,26508,0x10c1f5b40,240,ToNumeric
code-creation,BytecodeHandler,0,26515,0x10c1f5c40,112,ToObject
code-creation,BytecodeHandler,0,26522,0x10c1f5cc0,116,ToString
code-creation,BytecodeHandler,0,26530,0x10c1f5d40,404,CreateRegExpLiteral
code-creation,BytecodeHandler,0,26538,0x10c1f5f00,1488,CreateArrayLiteral
code-creation,BytecodeHandler,0,26546,0x10c1f6500,92,CreateArrayFromIterable
code-creation,BytecodeHandler,0,26555,0x10c1f6580,796,CreateEmptyArrayLiteral
code-creation,BytecodeHandler,0,26565,0x10c1f68c0,2256,CreateObjectLiteral
code-creation,BytecodeHandler,0,26574,0x10c1f71c0,228,CreateEmptyObjectLiteral
code-creation,BytecodeHandler,0,26584,0x10c1f72c0,172,CloneObject
code-creation,BytecodeHandler,0,26594,0x10c1f7380,216,GetTemplateObject
code-creation,BytecodeHandler,0,26612,0x10c1f7480,328,CreateClosure
code-creation,BytecodeHandler,0,26621,0x10c1f7600,120,CreateBlockContext
code-creation,BytecodeHandler,0,26628,0x10c1f7680,132,CreateCatchContext
code-creation,BytecodeHandler,0,26636,0x10c1f7740,260,CreateFunctionContext
code-creation,BytecodeHandler,0,26644,0x10c1f7880,260,CreateEvalContext
code-creation,BytecodeHandler,0,26651,0x10c1f79c0,132,CreateWithContext
code-creation,BytecodeHandler,0,26659,0x10c1f7a80,1584,CreateMappedArguments
code-creation,BytecodeHandler,0,26670,0x10c1f80c0,596,CreateUnmappedArguments
code-creation,BytecodeHandler,0,26679,0x10c1f8340,636,CreateRestParameter
code-creation,BytecodeHandler,0,26687,0x10c1f85c0,424,JumpLoop
code-creation,BytecodeHandler,0,26694,0x10c1f8780,44,Jump
code-creation,BytecodeHandler,0,26701,0x10c1f87c0,56,JumpConstant
code-creation,BytecodeHandler,0,26708,0x10c1f8800,80,JumpIfNullConstant
code-creation,BytecodeHandler,0,26715,0x10c1f8880,80,JumpIfNotNullConstant
code-creation,BytecodeHandler,0,26723,0x10c1f8900,80,JumpIfUndefinedConstant
code-creation,BytecodeHandler,0,26731,0x10c1f8980,80,JumpIfNotUndefinedConstant
code-creation,BytecodeHandler,0,26739,0x10c1f8a00,92,JumpIfUndefinedOrNullConstant
code-creation,BytecodeHandler,0,26749,0x10c1f8a80,80,JumpIfTrueConstant
code-creation,BytecodeHandler,0,26759,0x10c1f8b00,80,JumpIfFalseConstant
code-creation,BytecodeHandler,0,26768,0x10c1f8b80,88,JumpIfJSReceiverConstant
code-creation,BytecodeHandler,0,26778,0x10c1f8c00,156,JumpIfToBooleanTrueConstant
code-creation,BytecodeHandler,0,26789,0x10c1f8cc0,156,JumpIfToBooleanFalseConstant
code-creation,BytecodeHandler,0,26799,0x10c1f8d80,144,JumpIfToBooleanTrue
code-creation,BytecodeHandler,0,26808,0x10c1f8e40,144,JumpIfToBooleanFalse
code-creation,BytecodeHandler,0,26818,0x10c1f8f00,68,JumpIfTrue
code-creation,BytecodeHandler,0,26827,0x10c1f8f80,68,JumpIfFalse
code-creation,BytecodeHandler,0,26836,0x10c1f9000,68,JumpIfNull
code-creation,BytecodeHandler,0,26846,0x10c1f9080,68,JumpIfNotNull
code-creation,BytecodeHandler,0,26856,0x10c1f9100,68,JumpIfUndefined
code-creation,BytecodeHandler,0,26865,0x10c1f9180,68,JumpIfNotUndefined
code-creation,BytecodeHandler,0,26874,0x10c1f9200,76,JumpIfUndefinedOrNull
code-creation,BytecodeHandler,0,26883,0x10c1f9280,76,JumpIfJSReceiver
code-creation,BytecodeHandler,0,26891,0x10c1f9300,108,SwitchOnSmiNoFeedback
code-creation,BytecodeHandler,0,26899,0x10c1f9380,468,ForInEnumerate
code-creation,BytecodeHandler,0,26906,0x10c1f9580,264,ForInPrepare
code-creation,BytecodeHandler,0,26914,0x10c1f96c0,64,ForInContinue
code-creation,BytecodeHandler,0,26921,0x10c1f9740,264,ForInNext
code-creation,BytecodeHandler,0,26929,0x10c1f9880,48,ForInStep
code-creation,BytecodeHandler,0,26938,0x10c1f98c0,36,SetPendingMessage
tick,0x7fff203066eb,26957,0,0x0,6
code-creation,BytecodeHandler,0,27026,0x10c1f9900,116,Throw
code-creation,BytecodeHandler,0,27073,0x10c1f9980,116,ReThrow
code-creation,BytecodeHandler,0,27089,0x10c1f9a00,112,Return
code-creation,BytecodeHandler,0,27103,0x10c1f9a80,200,ThrowReferenceErrorIfHole
code-creation,BytecodeHandler,0,27122,0x10c1f9b80,136,ThrowSuperNotCalledIfHole
code-creation,BytecodeHandler,0,27134,0x10c1f9c40,136,ThrowSuperAlreadyCalledIfNotHole
code-creation,BytecodeHandler,0,27146,0x10c1f9d00,156,ThrowIfNotSuperConstructor
code-creation,BytecodeHandler,0,27162,0x10c1f9dc0,124,SwitchOnGeneratorState
code-creation,BytecodeHandler,0,27175,0x10c1f9e40,500,SuspendGenerator
code-creation,BytecodeHandler,0,27185,0x10c1fa040,128,ResumeGenerator
code-creation,BytecodeHandler,0,27197,0x10c1fa100,156,GetIterator
code-creation,BytecodeHandler,0,27213,0x10c1fa1c0,116,Debugger
code-creation,BytecodeHandler,0,27223,0x10c1fa240,124,IncBlockCounter
code-creation,BytecodeHandler,0,27232,0x10c1fa2c0,56,Abort
code-creation,BytecodeHandler,0,27241,0x10c1fa300,32,Star0
code-creation,BytecodeHandler,0,27250,0x10c1fa340,60,Illegal
code-creation,BytecodeHandler,0,27260,0x10c1fa380,108,DebugBreak1.Wide
code-creation,BytecodeHandler,0,27269,0x10c1fa400,108,DebugBreak2.Wide
code-creation,BytecodeHandler,0,27295,0x10c1fa480,108,DebugBreak3.Wide
code-creation,BytecodeHandler,0,27305,0x10c1fa500,108,DebugBreak4.Wide
code-creation,BytecodeHandler,0,27315,0x10c1fa580,108,DebugBreak5.Wide
code-creation,BytecodeHandler,0,27324,0x10c1fa600,108,DebugBreak6.Wide
code-creation,BytecodeHandler,0,27334,0x10c1fa680,32,Ldar.Wide
code-creation,BytecodeHandler,0,27343,0x10c1fa6c0,32,LdaSmi.Wide
code-creation,BytecodeHandler,0,27352,0x10c1fa700,32,LdaConstant.Wide
code-creation,BytecodeHandler,0,27363,0x10c1fa740,92,LdaContextSlot.Wide
code-creation,BytecodeHandler,0,27373,0x10c1fa7c0,92,LdaImmutableContextSlot.Wide
tick,0x7fff203564ca,27398,0,0x0,6
code-creation,BytecodeHandler,0,27423,0x10c1fa840,48,LdaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,27439,0x10c1fa880,48,LdaImmutableCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,27447,0x10c1fa8c0,32,Star.Wide
code-creation,BytecodeHandler,0,27454,0x10c1fa900,40,Mov.Wide
code-creation,BytecodeHandler,0,27461,0x10c1fa940,40,PushContext.Wide
code-creation,BytecodeHandler,0,27469,0x10c1fa980,36,PopContext.Wide
code-creation,BytecodeHandler,0,27477,0x10c1fa9c0,56,TestReferenceEqual.Wide
code-creation,BytecodeHandler,0,27485,0x10c1faa00,4724,LdaGlobal.Wide
code-creation,BytecodeHandler,0,27493,0x10c1fbc80,4660,LdaGlobalInsideTypeof.Wide
code-creation,BytecodeHandler,0,27501,0x10c1fcec0,164,StaGlobal.Wide
code-creation,BytecodeHandler,0,27508,0x10c1fcf80,156,StaContextSlot.Wide
code-creation,BytecodeHandler,0,27516,0x10c1fd040,112,StaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,27525,0x10c1fd0c0,128,LdaLookupSlot.Wide
code-creation,BytecodeHandler,0,27532,0x10c1fd180,248,LdaLookupContextSlot.Wide
code-creation,BytecodeHandler,0,27541,0x10c1fd280,4912,LdaLookupGlobalSlot.Wide
code-creation,BytecodeHandler,0,27549,0x10c1fe5c0,128,LdaLookupSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,27557,0x10c1fe680,248,LdaLookupContextSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,27566,0x10c1fe780,4876,LdaLookupGlobalSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,27575,0x10c1ffac0,220,StaLookupSlot.Wide
code-creation,BytecodeHandler,0,27583,0x10c1ffbc0,5284,LdaNamedProperty.Wide
code-creation,BytecodeHandler,0,27591,0x10c201080,192,LdaNamedPropertyFromSuper.Wide
code-creation,BytecodeHandler,0,27600,0x10c201180,164,LdaKeyedProperty.Wide
code-creation,BytecodeHandler,0,27607,0x10c201240,160,LdaModuleVariable.Wide
code-creation,BytecodeHandler,0,27616,0x10c201300,296,StaModuleVariable.Wide
code-creation,BytecodeHandler,0,27624,0x10c201440,180,StaNamedProperty.Wide
code-creation,BytecodeHandler,0,27632,0x10c201500,180,StaNamedOwnProperty.Wide
code-creation,BytecodeHandler,0,27640,0x10c2015c0,172,StaKeyedProperty.Wide
code-creation,BytecodeHandler,0,27648,0x10c201680,172,StaInArrayLiteral.Wide
code-creation,BytecodeHandler,0,27656,0x10c201740,204,StaDataPropertyInLiteral.Wide
code-creation,BytecodeHandler,0,27665,0x10c201840,168,CollectTypeProfile.Wide
code-creation,BytecodeHandler,0,27674,0x10c201900,988,Add.Wide
code-creation,BytecodeHandler,0,27681,0x10c201d00,1024,Sub.Wide
code-creation,BytecodeHandler,0,27688,0x10c202140,980,Mul.Wide
code-creation,BytecodeHandler,0,27696,0x10c202540,996,Div.Wide
code-creation,BytecodeHandler,0,27703,0x10c202940,924,Mod.Wide
code-creation,BytecodeHandler,0,27710,0x10c202d00,1008,Exp.Wide
code-creation,BytecodeHandler,0,27718,0x10c203100,916,BitwiseOr.Wide
code-creation,BytecodeHandler,0,27726,0x10c2034c0,924,BitwiseXor.Wide
code-creation,BytecodeHandler,0,27733,0x10c203880,924,BitwiseAnd.Wide
code-creation,BytecodeHandler,0,27740,0x10c203c40,936,ShiftLeft.Wide
code-creation,BytecodeHandler,0,27748,0x10c204000,936,ShiftRight.Wide
code-creation,BytecodeHandler,0,27756,0x10c2043c0,1056,ShiftRightLogical.Wide
code-creation,BytecodeHandler,0,27764,0x10c204800,924,AddSmi.Wide
code-creation,BytecodeHandler,0,27771,0x10c204bc0,968,SubSmi.Wide
code-creation,BytecodeHandler,0,27830,0x10c204fc0,920,MulSmi.Wide
code-creation,BytecodeHandler,0,27857,0x10c205380,924,DivSmi.Wide
code-creation,BytecodeHandler,0,27871,0x10c205740,824,ModSmi.Wide
code-creation,BytecodeHandler,0,27903,0x10c205a80,892,ExpSmi.Wide
code-creation,BytecodeHandler,0,27913,0x10c205e00,500,BitwiseOrSmi.Wide
code-creation,BytecodeHandler,0,27921,0x10c206000,500,BitwiseXorSmi.Wide
code-creation,BytecodeHandler,0,27929,0x10c206200,500,BitwiseAndSmi.Wide
code-creation,BytecodeHandler,0,27936,0x10c206400,500,ShiftLeftSmi.Wide
code-creation,BytecodeHandler,0,27944,0x10c206600,500,ShiftRightSmi.Wide
code-creation,BytecodeHandler,0,27952,0x10c206800,652,ShiftRightLogicalSmi.Wide
code-creation,BytecodeHandler,0,27960,0x10c206ac0,624,Inc.Wide
code-creation,BytecodeHandler,0,27967,0x10c206d40,624,Dec.Wide
code-creation,BytecodeHandler,0,27974,0x10c206fc0,652,Negate.Wide
code-creation,BytecodeHandler,0,27984,0x10c207280,496,BitwiseNot.Wide
code-creation,BytecodeHandler,0,27996,0x10c207480,124,DeletePropertyStrict.Wide
code-creation,BytecodeHandler,0,28005,0x10c207500,116,DeletePropertySloppy.Wide
code-creation,BytecodeHandler,0,28013,0x10c207580,40,GetSuperConstructor.Wide
code-creation,BytecodeHandler,0,28021,0x10c2075c0,1120,CallAnyReceiver.Wide
code-creation,BytecodeHandler,0,28028,0x10c207a40,1120,CallProperty.Wide
code-creation,BytecodeHandler,0,28036,0x10c207ec0,1008,CallProperty0.Wide
code-creation,BytecodeHandler,0,28044,0x10c2082c0,1024,CallProperty1.Wide
code-creation,BytecodeHandler,0,28052,0x10c208700,1036,CallProperty2.Wide
code-creation,BytecodeHandler,0,28066,0x10c208b40,1004,CallUndefinedReceiver.Wide
code-creation,BytecodeHandler,0,28077,0x10c208f40,1052,CallUndefinedReceiver0.Wide
code-creation,BytecodeHandler,0,28128,0x10c209380,1024,CallUndefinedReceiver1.Wide
code-creation,BytecodeHandler,0,28138,0x10c2097c0,1044,CallUndefinedReceiver2.Wide
code-creation,BytecodeHandler,0,28147,0x10c209c00,1120,CallWithSpread.Wide
code-creation,BytecodeHandler,0,28155,0x10c20a080,128,CallRuntime.Wide
code-creation,BytecodeHandler,0,28162,0x10c20a140,168,CallRuntimeForPair.Wide
code-creation,BytecodeHandler,0,28170,0x10c20a200,84,CallJSRuntime.Wide
code-creation,BytecodeHandler,0,28178,0x10c20a280,1252,InvokeIntrinsic.Wide
code-creation,BytecodeHandler,0,28189,0x10c20a780,968,Construct.Wide
code-creation,BytecodeHandler,0,28198,0x10c20ab80,484,ConstructWithSpread.Wide
code-creation,BytecodeHandler,0,28206,0x10c20ad80,1976,TestEqual.Wide
code-creation,BytecodeHandler,0,28213,0x10c20b540,1080,TestEqualStrict.Wide
code-creation,BytecodeHandler,0,28223,0x10c20b980,1524,TestLessThan.Wide
code-creation,BytecodeHandler,0,28236,0x10c20bf80,1524,TestGreaterThan.Wide
code-creation,BytecodeHandler,0,28243,0x10c20c580,1524,TestLessThanOrEqual.Wide
code-creation,BytecodeHandler,0,28254,0x10c20cb80,1524,TestGreaterThanOrEqual.Wide
code-creation,BytecodeHandler,0,28263,0x10c20d180,892,TestInstanceOf.Wide
code-creation,BytecodeHandler,0,28271,0x10c20d500,164,TestIn.Wide
code-creation,BytecodeHandler,0,28278,0x10c20d5c0,116,ToName.Wide
code-creation,BytecodeHandler,0,28285,0x10c20d640,224,ToNumber.Wide
code-creation,BytecodeHandler,0,28292,0x10c20d740,240,ToNumeric.Wide
code-creation,BytecodeHandler,0,28299,0x10c20d840,116,ToObject.Wide
code-creation,BytecodeHandler,0,28307,0x10c20d8c0,408,CreateRegExpLiteral.Wide
code-creation,BytecodeHandler,0,28315,0x10c20da80,1400,CreateArrayLiteral.Wide
code-creation,BytecodeHandler,0,28325,0x10c20e000,796,CreateEmptyArrayLiteral.Wide
code-creation,BytecodeHandler,0,28334,0x10c20e340,2168,CreateObjectLiteral.Wide
code-creation,BytecodeHandler,0,28343,0x10c20ebc0,176,CloneObject.Wide
code-creation,BytecodeHandler,0,28350,0x10c20ec80,164,GetTemplateObject.Wide
code-creation,BytecodeHandler,0,28357,0x10c20ed40,320,CreateClosure.Wide
code-creation,BytecodeHandler,0,28365,0x10c20eec0,124,CreateBlockContext.Wide
code-creation,BytecodeHandler,0,28373,0x10c20ef40,136,CreateCatchContext.Wide
code-creation,BytecodeHandler,0,28381,0x10c20f000,260,CreateFunctionContext.Wide
code-creation,BytecodeHandler,0,28389,0x10c20f140,260,CreateEvalContext.Wide
code-creation,BytecodeHandler,0,28401,0x10c20f280,136,CreateWithContext.Wide
code-creation,BytecodeHandler,0,28410,0x10c20f340,440,JumpLoop.Wide
code-creation,BytecodeHandler,0,28434,0x10c20f500,44,Jump.Wide
code-creation,BytecodeHandler,0,28441,0x10c20f540,56,JumpConstant.Wide
code-creation,BytecodeHandler,0,28449,0x10c20f580,80,JumpIfNullConstant.Wide
code-creation,BytecodeHandler,0,28458,0x10c20f600,80,JumpIfNotNullConstant.Wide
code-creation,BytecodeHandler,0,28466,0x10c20f680,80,JumpIfUndefinedConstant.Wide
code-creation,BytecodeHandler,0,28474,0x10c20f700,80,JumpIfNotUndefinedConstant.Wide
code-creation,BytecodeHandler,0,28483,0x10c20f780,92,JumpIfUndefinedOrNullConstant.Wide
code-creation,BytecodeHandler,0,28493,0x10c20f800,80,JumpIfTrueConstant.Wide
code-creation,BytecodeHandler,0,28503,0x10c20f880,80,JumpIfFalseConstant.Wide
code-creation,BytecodeHandler,0,28514,0x10c20f900,88,JumpIfJSReceiverConstant.Wide
code-creation,BytecodeHandler,0,28524,0x10c20f980,156,JumpIfToBooleanTrueConstant.Wide
code-creation,BytecodeHandler,0,28535,0x10c20fa40,156,JumpIfToBooleanFalseConstant.Wide
code-creation,BytecodeHandler,0,28546,0x10c20fb00,144,JumpIfToBooleanTrue.Wide
code-creation,BytecodeHandler,0,28556,0x10c20fbc0,144,JumpIfToBooleanFalse.Wide
code-creation,BytecodeHandler,0,28565,0x10c20fc80,68,JumpIfTrue.Wide
code-creation,BytecodeHandler,0,28573,0x10c20fd00,68,JumpIfFalse.Wide
code-creation,BytecodeHandler,0,28581,0x10c20fd80,68,JumpIfNull.Wide
code-creation,BytecodeHandler,0,28588,0x10c20fe00,68,JumpIfNotNull.Wide
code-creation,BytecodeHandler,0,28596,0x10c20fe80,68,JumpIfUndefined.Wide
code-creation,BytecodeHandler,0,28604,0x10c20ff00,68,JumpIfNotUndefined.Wide
code-creation,BytecodeHandler,0,28611,0x10c20ff80,76,JumpIfUndefinedOrNull.Wide
code-creation,BytecodeHandler,0,28620,0x10c210000,76,JumpIfJSReceiver.Wide
code-creation,BytecodeHandler,0,28630,0x10c210080,108,SwitchOnSmiNoFeedback.Wide
code-creation,BytecodeHandler,0,28640,0x10c210100,472,ForInEnumerate.Wide
code-creation,BytecodeHandler,0,28649,0x10c210300,264,ForInPrepare.Wide
code-creation,BytecodeHandler,0,28659,0x10c210440,64,ForInContinue.Wide
code-creation,BytecodeHandler,0,28668,0x10c2104c0,268,ForInNext.Wide
code-creation,BytecodeHandler,0,28675,0x10c210600,48,ForInStep.Wide
code-creation,BytecodeHandler,0,28682,0x10c210640,160,ThrowReferenceErrorIfHole.Wide
code-creation,BytecodeHandler,0,28691,0x10c210700,160,ThrowIfNotSuperConstructor.Wide
code-creation,BytecodeHandler,0,28699,0x10c2107c0,124,SwitchOnGeneratorState.Wide
code-creation,BytecodeHandler,0,28707,0x10c210840,516,SuspendGenerator.Wide
code-creation,BytecodeHandler,0,28715,0x10c210a80,128,ResumeGenerator.Wide
code-creation,BytecodeHandler,0,28722,0x10c210b40,160,GetIterator.Wide
code-creation,BytecodeHandler,0,28732,0x10c210c00,128,IncBlockCounter.Wide
code-creation,BytecodeHandler,0,28742,0x10c210cc0,56,Abort.Wide
code-creation,BytecodeHandler,0,28751,0x10c210d00,108,DebugBreak1.ExtraWide
code-creation,BytecodeHandler,0,28759,0x10c210d80,108,DebugBreak2.ExtraWide
code-creation,BytecodeHandler,0,28767,0x10c210e00,108,DebugBreak3.ExtraWide
code-creation,BytecodeHandler,0,28774,0x10c210e80,108,DebugBreak4.ExtraWide
code-creation,BytecodeHandler,0,28782,0x10c210f00,108,DebugBreak5.ExtraWide
code-creation,BytecodeHandler,0,28790,0x10c210f80,108,DebugBreak6.ExtraWide
code-creation,BytecodeHandler,0,28798,0x10c211000,32,Ldar.ExtraWide
code-creation,BytecodeHandler,0,28805,0x10c211040,28,LdaSmi.ExtraWide
tick,0x7fff20385158,28819,0,0x0,6
code-creation,BytecodeHandler,0,28843,0x10c211080,32,LdaConstant.ExtraWide
code-creation,BytecodeHandler,0,28854,0x10c2110c0,88,LdaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,28862,0x10c211140,88,LdaImmutableContextSlot.ExtraWide
code-creation,BytecodeHandler,0,28871,0x10c2111c0,48,LdaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,28879,0x10c211200,48,LdaImmutableCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,28888,0x10c211240,28,Star.ExtraWide
code-creation,BytecodeHandler,0,28895,0x10c211280,40,Mov.ExtraWide
code-creation,BytecodeHandler,0,28902,0x10c2112c0,36,PushContext.ExtraWide
code-creation,BytecodeHandler,0,28910,0x10c211300,32,PopContext.ExtraWide
code-creation,BytecodeHandler,0,28926,0x10c211340,52,TestReferenceEqual.ExtraWide
code-creation,BytecodeHandler,0,28934,0x10c211380,4712,LdaGlobal.ExtraWide
code-creation,BytecodeHandler,0,28942,0x10c212600,4648,LdaGlobalInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,28950,0x10c213840,164,StaGlobal.ExtraWide
code-creation,BytecodeHandler,0,28958,0x10c213900,152,StaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,28966,0x10c2139c0,108,StaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,28974,0x10c213a40,128,LdaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,28982,0x10c213b00,244,LdaLookupContextSlot.ExtraWide
code-creation,BytecodeHandler,0,28991,0x10c213c00,4900,LdaLookupGlobalSlot.ExtraWide
code-creation,BytecodeHandler,0,28999,0x10c214f40,128,LdaLookupSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,29008,0x10c215000,244,LdaLookupContextSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,29017,0x10c215100,4864,LdaLookupGlobalSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,29026,0x10c216440,220,StaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,29034,0x10c216540,5268,LdaNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,29042,0x10c217a00,188,LdaNamedPropertyFromSuper.ExtraWide
code-creation,BytecodeHandler,0,29077,0x10c217ac0,160,LdaKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,29085,0x10c217b80,160,LdaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,29093,0x10c217c40,292,StaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,29101,0x10c217d80,176,StaNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,29109,0x10c217e40,176,StaNamedOwnProperty.ExtraWide
code-creation,BytecodeHandler,0,29118,0x10c217f00,168,StaKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,29126,0x10c217fc0,168,StaInArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,29134,0x10c218080,200,StaDataPropertyInLiteral.ExtraWide
code-creation,BytecodeHandler,0,29150,0x10c218180,168,CollectTypeProfile.ExtraWide
code-creation,BytecodeHandler,0,29173,0x10c218240,988,Add.ExtraWide
code-creation,BytecodeHandler,0,29188,0x10c218640,1024,Sub.ExtraWide
code-creation,BytecodeHandler,0,29200,0x10c218a80,976,Mul.ExtraWide
tick,0x7fff203572be,29237,0,0x0,6
code-creation,BytecodeHandler,0,29260,0x10c218e80,992,Div.ExtraWide
code-creation,BytecodeHandler,0,29293,0x10c219280,920,Mod.ExtraWide
code-creation,BytecodeHandler,0,29307,0x10c219640,1004,Exp.ExtraWide
code-creation,BytecodeHandler,0,29315,0x10c219a40,912,BitwiseOr.ExtraWide
code-creation,BytecodeHandler,0,29322,0x10c219e00,924,BitwiseXor.ExtraWide
code-creation,BytecodeHandler,0,29330,0x10c21a1c0,924,BitwiseAnd.ExtraWide
code-creation,BytecodeHandler,0,29337,0x10c21a580,936,ShiftLeft.ExtraWide
code-creation,BytecodeHandler,0,29345,0x10c21a940,936,ShiftRight.ExtraWide
code-creation,BytecodeHandler,0,29353,0x10c21ad00,1056,ShiftRightLogical.ExtraWide
code-creation,BytecodeHandler,0,29361,0x10c21b140,920,AddSmi.ExtraWide
code-creation,BytecodeHandler,0,29368,0x10c21b500,964,SubSmi.ExtraWide
code-creation,BytecodeHandler,0,29375,0x10c21b900,916,MulSmi.ExtraWide
code-creation,BytecodeHandler,0,29383,0x10c21bcc0,924,DivSmi.ExtraWide
code-creation,BytecodeHandler,0,29390,0x10c21c080,820,ModSmi.ExtraWide
code-creation,BytecodeHandler,0,29397,0x10c21c3c0,892,ExpSmi.ExtraWide
code-creation,BytecodeHandler,0,29404,0x10c21c740,500,BitwiseOrSmi.ExtraWide
code-creation,BytecodeHandler,0,29412,0x10c21c940,500,BitwiseXorSmi.ExtraWide
code-creation,BytecodeHandler,0,29420,0x10c21cb40,500,BitwiseAndSmi.ExtraWide
code-creation,BytecodeHandler,0,29428,0x10c21cd40,500,ShiftLeftSmi.ExtraWide
code-creation,BytecodeHandler,0,29435,0x10c21cf40,500,ShiftRightSmi.ExtraWide
code-creation,BytecodeHandler,0,29443,0x10c21d140,652,ShiftRightLogicalSmi.ExtraWide
code-creation,BytecodeHandler,0,29451,0x10c21d400,624,Inc.ExtraWide
code-creation,BytecodeHandler,0,29458,0x10c21d680,620,Dec.ExtraWide
code-creation,BytecodeHandler,0,29465,0x10c21d900,652,Negate.ExtraWide
code-creation,BytecodeHandler,0,29473,0x10c21dbc0,496,BitwiseNot.ExtraWide
code-creation,BytecodeHandler,0,29493,0x10c21ddc0,124,DeletePropertyStrict.ExtraWide
code-creation,BytecodeHandler,0,29501,0x10c21de40,116,DeletePropertySloppy.ExtraWide
code-creation,BytecodeHandler,0,29509,0x10c21dec0,36,GetSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,29518,0x10c21df00,1116,CallAnyReceiver.ExtraWide
code-creation,BytecodeHandler,0,29525,0x10c21e380,1116,CallProperty.ExtraWide
code-creation,BytecodeHandler,0,29533,0x10c21e800,1004,CallProperty0.ExtraWide
code-creation,BytecodeHandler,0,29541,0x10c21ec00,1016,CallProperty1.ExtraWide
code-creation,BytecodeHandler,0,29549,0x10c21f000,1028,CallProperty2.ExtraWide
code-creation,BytecodeHandler,0,29559,0x10c21f440,1000,CallUndefinedReceiver.ExtraWide
code-creation,BytecodeHandler,0,29567,0x10c21f840,1048,CallUndefinedReceiver0.ExtraWide
code-creation,BytecodeHandler,0,29576,0x10c21fc80,1020,CallUndefinedReceiver1.ExtraWide
code-creation,BytecodeHandler,0,29585,0x10c220080,1040,CallUndefinedReceiver2.ExtraWide
code-creation,BytecodeHandler,0,29593,0x10c2204c0,1116,CallWithSpread.ExtraWide
code-creation,BytecodeHandler,0,29601,0x10c220940,128,CallRuntime.ExtraWide
code-creation,BytecodeHandler,0,29609,0x10c220a00,164,CallRuntimeForPair.ExtraWide
code-creation,BytecodeHandler,0,29617,0x10c220ac0,80,CallJSRuntime.ExtraWide
code-creation,BytecodeHandler,0,29625,0x10c220b40,1252,InvokeIntrinsic.ExtraWide
code-creation,BytecodeHandler,0,29633,0x10c221040,964,Construct.ExtraWide
code-creation,BytecodeHandler,0,29641,0x10c221440,480,ConstructWithSpread.ExtraWide
code-creation,BytecodeHandler,0,29649,0x10c221640,1976,TestEqual.ExtraWide
code-creation,BytecodeHandler,0,29657,0x10c221e00,1080,TestEqualStrict.ExtraWide
code-creation,BytecodeHandler,0,29665,0x10c222240,1520,TestLessThan.ExtraWide
code-creation,BytecodeHandler,0,29672,0x10c222840,1520,TestGreaterThan.ExtraWide
code-creation,BytecodeHandler,0,29680,0x10c222e40,1520,TestLessThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,29689,0x10c223440,1520,TestGreaterThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,29697,0x10c223a40,888,TestInstanceOf.ExtraWide
code-creation,BytecodeHandler,0,29705,0x10c223dc0,160,TestIn.ExtraWide
code-creation,BytecodeHandler,0,29712,0x10c223e80,116,ToName.ExtraWide
code-creation,BytecodeHandler,0,29720,0x10c223f00,220,ToNumber.ExtraWide
code-creation,BytecodeHandler,0,29727,0x10c224000,240,ToNumeric.ExtraWide
code-creation,BytecodeHandler,0,29734,0x10c224100,116,ToObject.ExtraWide
code-creation,BytecodeHandler,0,29742,0x10c224180,408,CreateRegExpLiteral.ExtraWide
code-creation,BytecodeHandler,0,29750,0x10c224340,1396,CreateArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,29759,0x10c2248c0,796,CreateEmptyArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,29767,0x10c224c00,2168,CreateObjectLiteral.ExtraWide
code-creation,BytecodeHandler,0,29775,0x10c225480,172,CloneObject.ExtraWide
code-creation,BytecodeHandler,0,29783,0x10c225540,164,GetTemplateObject.ExtraWide
code-creation,BytecodeHandler,0,29791,0x10c225600,320,CreateClosure.ExtraWide
code-creation,BytecodeHandler,0,29799,0x10c225780,124,CreateBlockContext.ExtraWide
code-creation,BytecodeHandler,0,29807,0x10c225800,132,CreateCatchContext.ExtraWide
code-creation,BytecodeHandler,0,29815,0x10c2258c0,256,CreateFunctionContext.ExtraWide
code-creation,BytecodeHandler,0,29824,0x10c225a00,256,CreateEvalContext.ExtraWide
code-creation,BytecodeHandler,0,29832,0x10c225b40,132,CreateWithContext.ExtraWide
code-creation,BytecodeHandler,0,29840,0x10c225c00,436,JumpLoop.ExtraWide
code-creation,BytecodeHandler,0,29847,0x10c225dc0,44,Jump.ExtraWide
code-creation,BytecodeHandler,0,29854,0x10c225e00,56,JumpConstant.ExtraWide
code-creation,BytecodeHandler,0,29862,0x10c225e40,80,JumpIfNullConstant.ExtraWide
code-creation,BytecodeHandler,0,29870,0x10c225ec0,80,JumpIfNotNullConstant.ExtraWide
code-creation,BytecodeHandler,0,29878,0x10c225f40,80,JumpIfUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,29887,0x10c225fc0,80,JumpIfNotUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,29896,0x10c226040,88,JumpIfUndefinedOrNullConstant.ExtraWide
code-creation,BytecodeHandler,0,29923,0x10c2260c0,80,JumpIfTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,29940,0x10c226140,80,JumpIfFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,29954,0x10c2261c0,88,JumpIfJSReceiverConstant.ExtraWide
code-creation,BytecodeHandler,0,29963,0x10c226240,156,JumpIfToBooleanTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,29973,0x10c226300,156,JumpIfToBooleanFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,29982,0x10c2263c0,140,JumpIfToBooleanTrue.ExtraWide
code-creation,BytecodeHandler,0,29991,0x10c226480,140,JumpIfToBooleanFalse.ExtraWide
code-creation,BytecodeHandler,0,29999,0x10c226540,68,JumpIfTrue.ExtraWide
code-creation,BytecodeHandler,0,30007,0x10c2265c0,68,JumpIfFalse.ExtraWide
code-creation,BytecodeHandler,0,30016,0x10c226640,68,JumpIfNull.ExtraWide
code-creation,BytecodeHandler,0,30024,0x10c2266c0,68,JumpIfNotNull.ExtraWide
code-creation,BytecodeHandler,0,30033,0x10c226740,68,JumpIfUndefined.ExtraWide
code-creation,BytecodeHandler,0,30041,0x10c2267c0,68,JumpIfNotUndefined.ExtraWide
code-creation,BytecodeHandler,0,30051,0x10c226840,76,JumpIfUndefinedOrNull.ExtraWide
code-creation,BytecodeHandler,0,30060,0x10c2268c0,72,JumpIfJSReceiver.ExtraWide
code-creation,BytecodeHandler,0,30070,0x10c226940,108,SwitchOnSmiNoFeedback.ExtraWide
code-creation,BytecodeHandler,0,30079,0x10c2269c0,472,ForInEnumerate.ExtraWide
code-creation,BytecodeHandler,0,30088,0x10c226bc0,264,ForInPrepare.ExtraWide
code-creation,BytecodeHandler,0,30096,0x10c226d00,64,ForInContinue.ExtraWide
code-creation,BytecodeHandler,0,30105,0x10c226d80,264,ForInNext.ExtraWide
code-creation,BytecodeHandler,0,30113,0x10c226ec0,44,ForInStep.ExtraWide
code-creation,BytecodeHandler,0,30122,0x10c226f00,160,ThrowReferenceErrorIfHole.ExtraWide
code-creation,BytecodeHandler,0,30131,0x10c226fc0,160,ThrowIfNotSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,30142,0x10c227080,124,SwitchOnGeneratorState.ExtraWide
code-creation,BytecodeHandler,0,30151,0x10c227100,512,SuspendGenerator.ExtraWide
code-creation,BytecodeHandler,0,30160,0x10c227340,124,ResumeGenerator.ExtraWide
code-creation,BytecodeHandler,0,30173,0x10c2273c0,156,GetIterator.ExtraWide
code-creation,BytecodeHandler,0,30188,0x10c227480,124,IncBlockCounter.ExtraWide
code-creation,BytecodeHandler,0,30205,0x10c227500,56,Abort.ExtraWide
new,MemoryChunk,0x24b33ec80000,262144
new,MemoryChunk,0x24b3d4800000,262144
tick,0x10ca96f4f,31866,0,0x0,5
tick,0x10c8557d8,33062,0,0x0,5
new,MemoryChunk,0x24b396bc0000,262144
new,MemoryChunk,0x24b357d80000,262144
tick,0x10c8585c5,34374,0,0x0,5
tick,0x10c583942,35487,0,0x0,5
code-creation,Eval,10,36191,0x24b357dbd256,5, node:internal/main/run_main_module:1:1,0x24b357dbd110,~
script-source,92,node:internal/main/run_main_module,'use strict';\n\nconst {\n  prepareMainThreadExecution\n} = require('internal/bootstrap/pre_execution');\n\nprepareMainThreadExecution(true);\n\nmarkBootstrapComplete();\n\n// Note: this loads the module through the ESM loader if the module is\n// determined to be an ES module. This hangs from the CJS module loader\n// because we currently allow monkey-patching of the module loaders\n// in the preloaded scripts through require('module').\n// runMain here might be monkey-patched by users in --require.\n// XXX: the monkey-patchability here should probably be deprecated.\nrequire('internal/modules/cjs/loader').Module.runMain(process.argv[1]);\n
code-source-info,0x24b357dbd256,92,0,632,C0O0C4O632,,
code-creation,Function,10,36293,0x24b357dbd2fe,58, node:internal/main/run_main_module:1:1,0x24b357dbd1d0,~
code-source-info,0x24b357dbd2fe,92,0,632,C0O56C3O56C8O25C13O102C15O102C19O137C22O560C25O560C30O598C35O605C40O622C47O626C51O606C57O631,,
code-creation,LazyCompile,10,36587,0x24b357dbd53e,76,nativeModuleRequire node:internal/bootstrap/loaders:332:29,0x24b3c058f908,~
script-source,9,node:internal/bootstrap/loaders,// This file creates the internal module & binding loaders used by built-in\n// modules. In contrast\x2C user land modules are loaded using\n// lib/internal/modules/cjs/loader.js (CommonJS Modules) or\n// lib/internal/modules/esm/* (ES Modules).\n//\n// This file is compiled and run by node.cc before bootstrap/node.js\n// was called\x2C therefore the loaders are bootstrapped before we start to\n// actually bootstrap Node.js. It creates the following objects:\n//\n// C++ binding loaders:\n// - process.binding(): the legacy C++ binding loader\x2C accessible from user land\n//   because it is an object attached to the global process object.\n//   These C++ bindings are created using NODE_BUILTIN_MODULE_CONTEXT_AWARE()\n//   and have their nm_flags set to NM_F_BUILTIN. We do not make any guarantees\n//   about the stability of these bindings\x2C but still have to take care of\n//   compatibility issues caused by them from time to time.\n// - process._linkedBinding(): intended to be used by embedders to add\n//   additional C++ bindings in their applications. These C++ bindings\n//   can be created using NODE_MODULE_CONTEXT_AWARE_CPP() with the flag\n//   NM_F_LINKED.\n// - internalBinding(): the private internal C++ binding loader\x2C inaccessible\n//   from user land unless through `require('internal/test/binding')`.\n//   These C++ bindings are created using NODE_MODULE_CONTEXT_AWARE_INTERNAL()\n//   and have their nm_flags set to NM_F_INTERNAL.\n//\n// Internal JavaScript module loader:\n// - NativeModule: a minimal module system used to load the JavaScript core\n//   modules found in lib/**/*.js and deps/**/*.js. All core modules are\n//   compiled into the node binary via node_javascript.cc generated by js2c.py\x2C\n//   so they can be loaded faster without the cost of I/O. This class makes the\n//   lib/internal/*\x2C deps/internal/* modules and internalBinding() available by\n//   default to core modules\x2C and lets the core modules require itself via\n//   require('internal/bootstrap/loaders') even when this file is not written in\n//   CommonJS style.\n//\n// Other objects:\n// - process.moduleLoadList: an array recording the bindings and the modules\n//   loaded in the process and the order in which they are loaded.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by node::RunBootstrapping()\n/* global process\x2C getLinkedBinding\x2C getInternalBinding\x2C primordials */\n\nconst {\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ReflectGet\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeStartsWith\x2C\n  TypeError\x2C\n} = primordials;\n\n// Set up process.moduleLoadList.\nconst moduleLoadList = [];\nObjectDefineProperty(process\x2C 'moduleLoadList'\x2C {\n  value: moduleLoadList\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n  writable: false\n});\n\n\n// internalBindingAllowlist contains the name of internalBinding modules\n// that are allowed for access via process.binding()... This is used\n// to provide a transition path for modules that are being moved over to\n// internalBinding.\nconst internalBindingAllowlist = new SafeSet([\n  'async_wrap'\x2C\n  'buffer'\x2C\n  'cares_wrap'\x2C\n  'config'\x2C\n  'constants'\x2C\n  'contextify'\x2C\n  'crypto'\x2C\n  'fs'\x2C\n  'fs_event_wrap'\x2C\n  'http_parser'\x2C\n  'icu'\x2C\n  'inspector'\x2C\n  'js_stream'\x2C\n  'natives'\x2C\n  'os'\x2C\n  'pipe_wrap'\x2C\n  'process_wrap'\x2C\n  'signal_wrap'\x2C\n  'spawn_sync'\x2C\n  'stream_wrap'\x2C\n  'tcp_wrap'\x2C\n  'tls_wrap'\x2C\n  'tty_wrap'\x2C\n  'udp_wrap'\x2C\n  'url'\x2C\n  'util'\x2C\n  'uv'\x2C\n  'v8'\x2C\n  'zlib'\x2C\n]);\n\nconst runtimeDeprecatedList = new SafeSet([\n  'async_wrap'\x2C\n  'crypto'\x2C\n  'http_parser'\x2C\n  'signal_wrap'\x2C\n  'url'\x2C\n  'v8'\x2C\n]);\n\nconst legacyWrapperList = new SafeSet([\n  'util'\x2C\n]);\n\n// Set up process.binding() and process._linkedBinding().\n{\n  const bindingObj = ObjectCreate(null);\n\n  process.binding = function binding(module) {\n    module = String(module);\n    // Deprecated specific process.binding() modules\x2C but not all\x2C allow\n    // selective fallback to internalBinding for the deprecated ones.\n    if (internalBindingAllowlist.has(module)) {\n      if (runtimeDeprecatedList.has(module)) {\n        runtimeDeprecatedList.delete(module);\n        process.emitWarning(\n          `Access to process.binding('${module}') is deprecated.`\x2C\n          'DeprecationWarning'\x2C\n          'DEP0111');\n      }\n      if (legacyWrapperList.has(module)) {\n        return nativeModuleRequire('internal/legacy/processbinding')[module]();\n      }\n      return internalBinding(module);\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    throw new Error(`No such module: ${module}`);\n  };\n\n  process._linkedBinding = function _linkedBinding(module) {\n    module = String(module);\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object')\n      mod = bindingObj[module] = getLinkedBinding(module);\n    return mod;\n  };\n}\n\n// Set up internalBinding() in the closure.\n/**\n * @type {InternalBinding}\n */\nlet internalBinding;\n{\n  const bindingObj = ObjectCreate(null);\n  // eslint-disable-next-line no-global-assign\n  internalBinding = function internalBinding(module) {\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object') {\n      mod = bindingObj[module] = getInternalBinding(module);\n      ArrayPrototypePush(moduleLoadList\x2C `Internal Binding ${module}`);\n    }\n    return mod;\n  };\n}\n\nconst loaderId = 'internal/bootstrap/loaders';\nconst {\n  moduleIds\x2C\n  compileFunction\n} = internalBinding('native_module');\n\nconst getOwn = (target\x2C property\x2C receiver) => {\n  return ObjectPrototypeHasOwnProperty(target\x2C property) ?\n    ReflectGet(target\x2C property\x2C receiver) :\n    undefined;\n};\n\n/**\n * An internal abstraction for the built-in JavaScript modules of Node.js.\n * Be careful not to expose this to user land unless --expose-internals is\n * used\x2C in which case there is no compatibility guarantee about this class.\n */\nclass NativeModule {\n  /**\n   * A map from the module IDs to the module instances.\n   * @type {Map<string\x2C NativeModule>}\n  */\n  static map = new SafeMap(\n    ArrayPrototypeMap(moduleIds\x2C (id) => [id\x2C new NativeModule(id)])\n  );\n\n  constructor(id) {\n    this.filename = `${id}.js`;\n    this.id = id;\n    this.canBeRequiredByUsers = !StringPrototypeStartsWith(id\x2C 'internal/');\n\n    // The CJS exports object of the module.\n    this.exports = {};\n    // States used to work around circular dependencies.\n    this.loaded = false;\n    this.loading = false;\n\n    // The following properties are used by the ESM implementation and only\n    // initialized when the native module is loaded by users.\n    /**\n     * The C++ ModuleWrap binding used to interface with the ESM implementation.\n     * @type {ModuleWrap|undefined}\n     */\n    this.module = undefined;\n    /**\n     * Exported names for the ESM imports.\n     * @type {string[]|undefined}\n     */\n    this.exportKeys = undefined;\n  }\n\n  // To be called during pre-execution when --expose-internals is on.\n  // Enables the user-land module loader to access internal modules.\n  static exposeInternals() {\n    for (const { 0: id\x2C 1: mod } of NativeModule.map) {\n      // Do not expose this to user land even with --expose-internals.\n      if (id !== loaderId) {\n        mod.canBeRequiredByUsers = true;\n      }\n    }\n  }\n\n  static exists(id) {\n    return NativeModule.map.has(id);\n  }\n\n  static canBeRequiredByUsers(id) {\n    const mod = NativeModule.map.get(id);\n    return mod && mod.canBeRequiredByUsers;\n  }\n\n  // Used by user-land module loaders to compile and load builtins.\n  compileForPublicLoader() {\n    if (!this.canBeRequiredByUsers) {\n      // No code because this is an assertion against bugs\n      // eslint-disable-next-line no-restricted-syntax\n      throw new Error(`Should not compile ${this.id} for public use`);\n    }\n    this.compileForInternalLoader();\n    if (!this.exportKeys) {\n      // When using --expose-internals\x2C we do not want to reflect the named\n      // exports from core modules as this can trigger unnecessary getters.\n      const internal = StringPrototypeStartsWith(this.id\x2C 'internal/');\n      this.exportKeys = internal ? [] : ObjectKeys(this.exports);\n    }\n    this.getESMFacade();\n    this.syncExports();\n    return this.exports;\n  }\n\n  getESMFacade() {\n    if (this.module) return this.module;\n    const { ModuleWrap } = internalBinding('module_wrap');\n    const url = `node:${this.id}`;\n    const nativeModule = this;\n    const exportsKeys = ArrayPrototypeSlice(this.exportKeys);\n    ArrayPrototypePush(exportsKeys\x2C 'default');\n    this.module = new ModuleWrap(\n      url\x2C undefined\x2C exportsKeys\x2C\n      function() {\n        nativeModule.syncExports();\n        this.setExport('default'\x2C nativeModule.exports);\n      });\n    // Ensure immediate sync execution to capture exports now\n    this.module.instantiate();\n    this.module.evaluate(-1\x2C false);\n    return this.module;\n  }\n\n  // Provide named exports for all builtin libraries so that the libraries\n  // may be imported in a nicer way for ESM users. The default export is left\n  // as the entire namespace (module.exports) and updates when this function is\n  // called so that APMs and other behavior are supported.\n  syncExports() {\n    const names = this.exportKeys;\n    if (this.module) {\n      for (let i = 0; i < names.length; i++) {\n        const exportName = names[i];\n        if (exportName === 'default') continue;\n        this.module.setExport(exportName\x2C\n                              getOwn(this.exports\x2C exportName\x2C this.exports));\n      }\n    }\n  }\n\n  compileForInternalLoader() {\n    if (this.loaded || this.loading) {\n      return this.exports;\n    }\n\n    const id = this.id;\n    this.loading = true;\n\n    try {\n      const requireFn = StringPrototypeStartsWith(this.id\x2C 'internal/deps/') ?\n        requireWithFallbackInDeps : nativeModuleRequire;\n\n      const fn = compileFunction(id);\n      fn(this.exports\x2C requireFn\x2C this\x2C process\x2C internalBinding\x2C primordials);\n\n      this.loaded = true;\n    } finally {\n      this.loading = false;\n    }\n\n    ArrayPrototypePush(moduleLoadList\x2C `NativeModule ${id}`);\n    return this.exports;\n  }\n}\n\n// Think of this as module.exports in this file even though it is not\n// written in CommonJS style.\nconst loaderExports = {\n  internalBinding\x2C\n  NativeModule\x2C\n  require: nativeModuleRequire\n};\n\nfunction nativeModuleRequire(id) {\n  if (id === loaderId) {\n    return loaderExports;\n  }\n\n  const mod = NativeModule.map.get(id);\n  // Can't load the internal errors module from here\x2C have to use a raw error.\n  // eslint-disable-next-line no-restricted-syntax\n  if (!mod) throw new TypeError(`Missing internal module '${id}'`);\n  return mod.compileForInternalLoader();\n}\n\n// Allow internal modules from dependencies to require\n// other modules from dependencies by providing fallbacks.\nfunction requireWithFallbackInDeps(request) {\n  if (!NativeModule.map.has(request)) {\n    request = `internal/deps/${request}`;\n  }\n  return nativeModuleRequire(request);\n}\n\n// Pass the exports back to C++ land for C++ internals to use.\nreturn loaderExports;\n
code-source-info,0x24b357dbd53e,9,10315,10658,C0O10324C2O10335C4O10331C9O10351C13O10372C14O10392C19O10405C24O10409C29O10409C35O10550C37O10560C47O10608C60O10566C65O10560C66O10629C71O10629C75O10656,,
tick,0x7fff20385358,37570,0,0x0,3,0x10c825337,0x24b357dbd301
code-creation,LazyCompile,10,37794,0x24b357dbe24e,175,compileForInternalLoader node:internal/bootstrap/loaders:299:27,0x24b3c058f838,~
code-source-info,0x24b357dbe24e,9,9528,10089,C0O9546C6O9561C12O9590C16O9598C17O9626C22O9634C23O9647C30O9690C37O9721C45O9690C63O9820C70O9820C75O9855C89O9890C103O9847C108O9928C109O9940C124O9970C126O9983C141O10003C152O10022C160O10054C165O10003C170O10077C174O10085,,
tick,0x7fff203572be,37916,0,0x0,3,0x10c825337,0x24b357dbd585,0x24b357dbd301
new,MemoryChunk,0x24b326940000,262144
code-creation,Eval,10,38439,0x24b357dbf196,5, node:internal/bootstrap/pre_execution:1:1,0x24b357dbee00,~
script-source,93,node:internal/bootstrap/pre_execution,'use strict';\n\nconst {\n  NumberParseInt\x2C\n  ObjectDefineProperty\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  StringPrototypeStartsWith\x2C\n  globalThis\x2C\n} = primordials;\n\nconst {\n  getOptionValue\x2C\n  getEmbedderOptions\x2C\n} = require('internal/options');\nconst { reconnectZeroFillToggle } = require('internal/buffer');\n\nconst { Buffer } = require('buffer');\nconst { ERR_MANIFEST_ASSERT_INTEGRITY } = require('internal/errors').codes;\nconst assert = require('internal/assert');\n\nfunction prepareMainThreadExecution(expandArgv1 = false) {\n  // TODO(joyeecheung): this is also necessary for workers when they deserialize\n  // this toggle from the snapshot.\n  reconnectZeroFillToggle();\n\n  // Patch the process object with legacy properties and normalizations\n  patchProcessObject(expandArgv1);\n  setupTraceCategoryState();\n  setupPerfHooks();\n  setupInspectorHooks();\n  setupWarningHandler();\n\n  // Resolve the coverage directory to an absolute path\x2C and\n  // overwrite process.env so that the original path gets passed\n  // to child processes even when they switch cwd.\n  if (process.env.NODE_V8_COVERAGE) {\n    process.env.NODE_V8_COVERAGE =\n      setupCoverageHooks(process.env.NODE_V8_COVERAGE);\n  }\n\n\n  setupDebugEnv();\n\n  // Print stack trace on `SIGINT` if option `--trace-sigint` presents.\n  setupStacktracePrinterOnSigint();\n\n  // Process initial diagnostic reporting configuration\x2C if present.\n  initializeReport();\n  initializeReportSignalHandlers();  // Main-thread-only.\n\n  initializeHeapSnapshotSignalHandlers();\n\n  // If the process is spawned with env NODE_CHANNEL_FD\x2C it's probably\n  // spawned by our child_process module\x2C then initialize IPC.\n  // This attaches some internal event listeners and creates:\n  // process.send()\x2C process.channel\x2C process.connected\x2C\n  // process.disconnect().\n  setupChildProcessIpcChannel();\n\n  // Load policy from disk and parse it.\n  initializePolicy();\n\n  // If this is a worker in cluster mode\x2C start up the communication\n  // channel. This needs to be done before any user code gets executed\n  // (including preload modules).\n  initializeClusterIPC();\n\n  initializeSourceMapsHandlers();\n  initializeDeprecations();\n  initializeWASI();\n  initializeCJSLoader();\n  initializeESMLoader();\n\n  const CJSLoader = require('internal/modules/cjs/loader');\n  assert(!CJSLoader.hasLoadedAnyUserCJSModule);\n  loadPreloadModules();\n  initializeFrozenIntrinsics();\n}\n\nfunction patchProcessObject(expandArgv1) {\n  const binding = internalBinding('process_methods');\n  binding.patchProcessObject(process);\n\n  // TODO(joyeecheung): snapshot fast APIs (which need to work with\n  // array buffers\x2C whose connection with C++ needs to be rebuilt after\n  // deserialization).\n  const {\n    hrtime\x2C\n    hrtimeBigInt\n  } = require('internal/process/per_thread').getFastAPIs(binding);\n\n  process.hrtime = hrtime;\n  process.hrtime.bigint = hrtimeBigInt;\n\n  ObjectDefineProperty(process\x2C 'argv0'\x2C {\n    enumerable: true\x2C\n    configurable: false\x2C\n    value: process.argv[0]\n  });\n  process.argv[0] = process.execPath;\n\n  if (expandArgv1 && process.argv[1] &&\n      !StringPrototypeStartsWith(process.argv[1]\x2C '-')) {\n    // Expand process.argv[1] into a full path.\n    const path = require('path');\n    try {\n      process.argv[1] = path.resolve(process.argv[1]);\n    } catch {}\n  }\n\n  // TODO(joyeecheung): most of these should be deprecated and removed\x2C\n  // except some that we need to be able to mutate during run time.\n  addReadOnlyProcessAlias('_eval'\x2C '--eval');\n  addReadOnlyProcessAlias('_print_eval'\x2C '--print');\n  addReadOnlyProcessAlias('_syntax_check_only'\x2C '--check');\n  addReadOnlyProcessAlias('_forceRepl'\x2C '--interactive');\n  addReadOnlyProcessAlias('_preload_modules'\x2C '--require');\n  addReadOnlyProcessAlias('noDeprecation'\x2C '--no-deprecation');\n  addReadOnlyProcessAlias('noProcessWarnings'\x2C '--no-warnings');\n  addReadOnlyProcessAlias('traceProcessWarnings'\x2C '--trace-warnings');\n  addReadOnlyProcessAlias('throwDeprecation'\x2C '--throw-deprecation');\n  addReadOnlyProcessAlias('profProcess'\x2C '--prof-process');\n  addReadOnlyProcessAlias('traceDeprecation'\x2C '--trace-deprecation');\n  addReadOnlyProcessAlias('_breakFirstLine'\x2C '--inspect-brk'\x2C false);\n  addReadOnlyProcessAlias('_breakNodeFirstLine'\x2C '--inspect-brk-node'\x2C false);\n}\n\nfunction addReadOnlyProcessAlias(name\x2C option\x2C enumerable = true) {\n  const value = getOptionValue(option);\n  if (value) {\n    ObjectDefineProperty(process\x2C name\x2C {\n      writable: false\x2C\n      configurable: true\x2C\n      enumerable\x2C\n      value\n    });\n  }\n}\n\nfunction setupWarningHandler() {\n  const {\n    onWarning\n  } = require('internal/process/warning');\n  if (getOptionValue('--warnings') &&\n    process.env.NODE_NO_WARNINGS !== '1') {\n    process.on('warning'\x2C onWarning);\n  }\n}\n\n// Setup User-facing NODE_V8_COVERAGE environment variable that writes\n// ScriptCoverage to a specified file.\nfunction setupCoverageHooks(dir) {\n  const cwd = require('internal/process/execution').tryGetCwd();\n  const { resolve } = require('path');\n  const coverageDirectory = resolve(cwd\x2C dir);\n  const { sourceMapCacheToObject } =\n    require('internal/source_map/source_map_cache');\n\n  if (process.features.inspector) {\n    internalBinding('profiler').setCoverageDirectory(coverageDirectory);\n    internalBinding('profiler').setSourceMapCacheGetter(sourceMapCacheToObject);\n  } else {\n    process.emitWarning('The inspector is disabled\x2C ' +\n                        'coverage could not be collected'\x2C\n                        'Warning');\n    return '';\n  }\n  return coverageDirectory;\n}\n\nfunction setupStacktracePrinterOnSigint() {\n  if (!getOptionValue('--trace-sigint')) {\n    return;\n  }\n  const { SigintWatchdog } = require('internal/watchdog');\n\n  const watchdog = new SigintWatchdog();\n  watchdog.start();\n}\n\nfunction initializeReport() {\n  const { report } = require('internal/process/report');\n  ObjectDefineProperty(process\x2C 'report'\x2C {\n    enumerable: false\x2C\n    configurable: true\x2C\n    get() {\n      return report;\n    }\n  });\n}\n\nfunction setupDebugEnv() {\n  require('internal/util/debuglog').initializeDebugEnv(process.env.NODE_DEBUG);\n  if (getOptionValue('--expose-internals')) {\n    require('internal/bootstrap/loaders').NativeModule.exposeInternals();\n  }\n}\n\n// This has to be called after initializeReport() is called\nfunction initializeReportSignalHandlers() {\n  const { addSignalHandler } = require('internal/process/report');\n\n  addSignalHandler();\n}\n\nfunction initializeHeapSnapshotSignalHandlers() {\n  const signal = getOptionValue('--heapsnapshot-signal');\n\n  if (!signal)\n    return;\n\n  require('internal/validators').validateSignalName(signal);\n  const { writeHeapSnapshot } = require('v8');\n\n  process.on(signal\x2C () => {\n    writeHeapSnapshot();\n  });\n}\n\nfunction setupTraceCategoryState() {\n  const { isTraceCategoryEnabled } = internalBinding('trace_events');\n  const { toggleTraceCategoryState } = require('internal/process/per_thread');\n  toggleTraceCategoryState(isTraceCategoryEnabled('node.async_hooks'));\n}\n\nfunction setupPerfHooks() {\n  require('internal/perf/performance').refreshTimeOrigin();\n  require('internal/perf/utils').refreshTimeOrigin();\n}\n\nfunction setupInspectorHooks() {\n  // If Debugger.setAsyncCallStackDepth is sent during bootstrap\x2C\n  // we cannot immediately call into JS to enable the hooks\x2C which could\n  // interrupt the JS execution of bootstrap. So instead we save the\n  // notification in the inspector agent if it's sent in the middle of\n  // bootstrap\x2C and process the notification later here.\n  if (internalBinding('config').hasInspector) {\n    const {\n      enable\x2C\n      disable\n    } = require('internal/inspector_async_hook');\n    internalBinding('inspector').registerAsyncHook(enable\x2C disable);\n  }\n}\n\n// In general deprecations are initialized wherever the APIs are implemented\x2C\n// this is used to deprecate APIs implemented in C++ where the deprecation\n// utilities are not easily accessible.\nfunction initializeDeprecations() {\n  const { deprecate } = require('internal/util');\n  const pendingDeprecation = getOptionValue('--pending-deprecation');\n\n  // DEP0103: access to `process.binding('util').isX` type checkers\n  // TODO(addaleax): Turn into a full runtime deprecation.\n  const utilBinding = internalBinding('util');\n  const types = require('internal/util/types');\n  for (const name of [\n    'isArrayBuffer'\x2C\n    'isArrayBufferView'\x2C\n    'isAsyncFunction'\x2C\n    'isDataView'\x2C\n    'isDate'\x2C\n    'isExternal'\x2C\n    'isMap'\x2C\n    'isMapIterator'\x2C\n    'isNativeError'\x2C\n    'isPromise'\x2C\n    'isRegExp'\x2C\n    'isSet'\x2C\n    'isSetIterator'\x2C\n    'isTypedArray'\x2C\n    'isUint8Array'\x2C\n    'isAnyArrayBuffer'\x2C\n  ]) {\n    utilBinding[name] = pendingDeprecation ?\n      deprecate(types[name]\x2C\n                'Accessing native typechecking bindings of Node ' +\n                'directly is deprecated. ' +\n                `Please use \\`util.types.${name}\\` instead.`\x2C\n                'DEP0103') :\n      types[name];\n  }\n\n  // TODO(joyeecheung): this is a legacy property exposed to process.\n  // Now that we use the config binding to carry this information\x2C remove\n  // it from the process. We may consider exposing it properly in\n  // process.features.\n  const { noBrowserGlobals } = internalBinding('config');\n  if (noBrowserGlobals) {\n    ObjectDefineProperty(process\x2C '_noBrowserGlobals'\x2C {\n      writable: false\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: noBrowserGlobals\n    });\n  }\n\n  if (pendingDeprecation) {\n    process.binding = deprecate(process.binding\x2C\n                                'process.binding() is deprecated. ' +\n                                'Please use public APIs instead.'\x2C 'DEP0111');\n\n    process._tickCallback = deprecate(process._tickCallback\x2C\n                                      'process._tickCallback() is deprecated'\x2C\n                                      'DEP0134');\n  }\n\n  // Create global.process and global.Buffer as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _process = process;\n  ObjectDefineProperty(globalThis\x2C 'process'\x2C {\n    get() {\n      return _process;\n    }\x2C\n    set(value) {\n      _process = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\n  });\n\n  let _Buffer = Buffer;\n  ObjectDefineProperty(globalThis\x2C 'Buffer'\x2C {\n    get() {\n      return _Buffer;\n    }\x2C\n    set(value) {\n      _Buffer = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\n  });\n}\n\nfunction setupChildProcessIpcChannel() {\n  if (process.env.NODE_CHANNEL_FD) {\n    const assert = require('internal/assert');\n\n    const fd = NumberParseInt(process.env.NODE_CHANNEL_FD\x2C 10);\n    assert(fd >= 0);\n\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_CHANNEL_FD;\n\n    const serializationMode =\n      process.env.NODE_CHANNEL_SERIALIZATION_MODE || 'json';\n    delete process.env.NODE_CHANNEL_SERIALIZATION_MODE;\n\n    require('child_process')._forkChild(fd\x2C serializationMode);\n    assert(process.send);\n  }\n}\n\nfunction initializeClusterIPC() {\n  if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n    const cluster = require('cluster');\n    cluster._setupWorker();\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_UNIQUE_ID;\n  }\n}\n\nfunction initializePolicy() {\n  const experimentalPolicy = getOptionValue('--experimental-policy');\n  if (experimentalPolicy) {\n    process.emitWarning('Policies are experimental.'\x2C\n                        'ExperimentalWarning');\n    const { pathToFileURL\x2C URL } = require('internal/url');\n    // URL here as it is slightly different parsing\n    // no bare specifiers for now\n    let manifestURL;\n    if (require('path').isAbsolute(experimentalPolicy)) {\n      manifestURL = new URL(`file://${experimentalPolicy}`);\n    } else {\n      const cwdURL = pathToFileURL(process.cwd());\n      cwdURL.pathname += '/';\n      manifestURL = new URL(experimentalPolicy\x2C cwdURL);\n    }\n    const fs = require('fs');\n    const src = fs.readFileSync(manifestURL\x2C 'utf8');\n    const experimentalPolicyIntegrity = getOptionValue('--policy-integrity');\n    if (experimentalPolicyIntegrity) {\n      const SRI = require('internal/policy/sri');\n      const { createHash\x2C timingSafeEqual } = require('crypto');\n      const realIntegrities = new SafeMap();\n      const integrityEntries = SRI.parse(experimentalPolicyIntegrity);\n      let foundMatch = false;\n      for (let i = 0; i < integrityEntries.length; i++) {\n        const {\n          algorithm\x2C\n          value: expected\n        } = integrityEntries[i];\n        const hash = createHash(algorithm);\n        hash.update(src);\n        const digest = hash.digest();\n        if (digest.length === expected.length &&\n          timingSafeEqual(digest\x2C expected)) {\n          foundMatch = true;\n          break;\n        }\n        realIntegrities.set(algorithm\x2C digest.toString('base64'));\n      }\n      if (!foundMatch) {\n        throw new ERR_MANIFEST_ASSERT_INTEGRITY(manifestURL\x2C realIntegrities);\n      }\n    }\n    require('internal/process/policy')\n      .setup(src\x2C manifestURL.href);\n  }\n}\n\nfunction initializeWASI() {\n  const { NativeModule } = require('internal/bootstrap/loaders');\n  const mod = NativeModule.map.get('wasi');\n  mod.canBeRequiredByUsers =\n    getOptionValue('--experimental-wasi-unstable-preview1');\n}\n\nfunction initializeCJSLoader() {\n  const CJSLoader = require('internal/modules/cjs/loader');\n  if (!getEmbedderOptions().noGlobalSearchPaths) {\n    CJSLoader.Module._initPaths();\n  }\n  // TODO(joyeecheung): deprecate this in favor of a proper hook?\n  CJSLoader.Module.runMain =\n    require('internal/modules/run_main').executeUserEntryPoint;\n}\n\nfunction initializeESMLoader() {\n  // Create this WeakMap in js-land because V8 has no C++ API for WeakMap.\n  internalBinding('module_wrap').callbackMap = new SafeWeakMap();\n\n  if (getEmbedderOptions().shouldNotRegisterESMLoader) return;\n\n  const {\n    setImportModuleDynamicallyCallback\x2C\n    setInitializeImportMetaObjectCallback\n  } = internalBinding('module_wrap');\n  const esm = require('internal/process/esm_loader');\n  // Setup per-isolate callbacks that locate data or callbacks that we keep\n  // track of for different ESM modules.\n  setInitializeImportMetaObjectCallback(esm.initializeImportMetaObject);\n  setImportModuleDynamicallyCallback(esm.importModuleDynamicallyCallback);\n\n  // Patch the vm module when --experimental-vm-modules is on.\n  // Please update the comments in vm.js when this block changes.\n  if (getOptionValue('--experimental-vm-modules')) {\n    const {\n      Module\x2C SourceTextModule\x2C SyntheticModule\x2C\n    } = require('internal/vm/module');\n    const vm = require('vm');\n    vm.Module = Module;\n    vm.SourceTextModule = SourceTextModule;\n    vm.SyntheticModule = SyntheticModule;\n  }\n}\n\nfunction initializeSourceMapsHandlers() {\n  const { setSourceMapsEnabled } =\n    require('internal/source_map/source_map_cache');\n  process.setSourceMapsEnabled = setSourceMapsEnabled;\n}\n\nfunction initializeFrozenIntrinsics() {\n  if (getOptionValue('--frozen-intrinsics')) {\n    process.emitWarning('The --frozen-intrinsics flag is experimental'\x2C\n                        'ExperimentalWarning');\n    require('internal/freeze_intrinsics')();\n  }\n}\n\nfunction loadPreloadModules() {\n  // For user code\x2C we preload modules if `-r` is passed\n  const preloadModules = getOptionValue('--require');\n  if (preloadModules && preloadModules.length > 0) {\n    const {\n      Module: {\n        _preloadModules\n      }\x2C\n    } = require('internal/modules/cjs/loader');\n    _preloadModules(preloadModules);\n  }\n}\n\nmodule.exports = {\n  patchProcessObject\x2C\n  setupCoverageHooks\x2C\n  setupWarningHandler\x2C\n  setupDebugEnv\x2C\n  setupPerfHooks\x2C\n  prepareMainThreadExecution\x2C\n  initializeDeprecations\x2C\n  initializeESMLoader\x2C\n  initializeFrozenIntrinsics\x2C\n  initializeSourceMapsHandlers\x2C\n  loadPreloadModules\x2C\n  setupTraceCategoryState\x2C\n  setupInspectorHooks\x2C\n  initializeReport\x2C\n  initializeCJSLoader\x2C\n  initializeWASI\n};\n
code-source-info,0x24b357dbf196,93,0,15986,C0O0C4O15986,,
code-creation,Function,10,39765,0x24b357dbfc96,426, node:internal/bootstrap/pre_execution:1:1,0x24b357dbf110,~
code-source-info,0x24b357dbfc96,93,0,15986,C0O0C190O25C196O43C202O67C208O78C214O93C220O122C226O204C232O204C237O162C243O180C249O269C255O269C260O241C266O317C272O317C277O306C283O378C289O378C294O404C299O344C305O427C311O427C315O427C317O15589C324O15610C330O15632C336O15654C342O15677C348O15694C354O15712C360O15742C366O15768C372O15791C378O15821C384O15853C390O15875C396O15902C402O15925C408O15945C414O15968C420O15604C425O15985,,
tick,0x10c2653c0,39835,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b357dbd301
code-creation,Eval,10,40130,0x24b32694283e,5, node:internal/options:1:1,0x24b326942668,~
script-source,94,node:internal/options,'use strict';\n\nconst {\n  getCLIOptions\x2C\n  getEmbedderOptions: getEmbedderOptionsFromBinding\x2C\n} = internalBinding('options');\n\nlet warnOnAllowUnauthorized = true;\n\nlet optionsMap;\nlet aliasesMap;\nlet embedderOptions;\n\n// getCLIOptions() would serialize the option values from C++ land.\n// It would error if the values are queried before bootstrap is\n// complete so that we don't accidentally include runtime-dependent\n// states into a runtime-independent snapshot.\nfunction getCLIOptionsFromBinding() {\n  if (!optionsMap) {\n    ({ options: optionsMap } = getCLIOptions());\n  }\n  return optionsMap;\n}\n\nfunction getAliasesFromBinding() {\n  if (!aliasesMap) {\n    ({ aliases: aliasesMap } = getCLIOptions());\n  }\n  return aliasesMap;\n}\n\nfunction getEmbedderOptions() {\n  if (!embedderOptions) {\n    embedderOptions = getEmbedderOptionsFromBinding();\n  }\n  return embedderOptions;\n}\n\nfunction getOptionValue(optionName) {\n  const options = getCLIOptionsFromBinding();\n  if (optionName.startsWith('--no-')) {\n    const option = options.get('--' + optionName.slice(5));\n    return option && !option.value;\n  }\n  return options.get(optionName)?.value;\n}\n\nfunction getAllowUnauthorized() {\n  const allowUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0';\n\n  if (allowUnauthorized && warnOnAllowUnauthorized) {\n    warnOnAllowUnauthorized = false;\n    process.emitWarning(\n      'Setting the NODE_TLS_REJECT_UNAUTHORIZED ' +\n      'environment variable to \\'0\\' makes TLS connections ' +\n      'and HTTPS requests insecure by disabling ' +\n      'certificate verification.');\n  }\n  return allowUnauthorized;\n}\n\nmodule.exports = {\n  get options() {\n    return getCLIOptionsFromBinding();\n  }\x2C\n  get aliases() {\n    return getAliasesFromBinding();\n  }\x2C\n  getOptionValue\x2C\n  getAllowUnauthorized\x2C\n  getEmbedderOptions\n};\n
code-source-info,0x24b32694283e,94,0,1820,C0O0C4O1820,,
code-creation,Function,10,40353,0x24b326942c0e,154, node:internal/options:1:1,0x24b3269427b8,~
code-source-info,0x24b326942c0e,94,0,1820,C0O0C54O97C57O97C62O25C68O62C74O156C75O156C77O167C78O167C80O183C81O183C83O199C84O199C86O1614C93O1756C99O1774C105O1798C148O1629C153O1819,,
tick,0x7fff201b5045,40475,0,0x0,2,0x10c825337,0x24b326942c47,0x24b357dbe2b5,0x24b357dbd585,0x24b357dbfd7e,0x24b357dbe2b5,0x24b357dbd585,0x24b357dbd301
code-creation,LazyCompile,10,40500,0x24b32694311e,69,internalBinding node:internal/bootstrap/loaders:164:45,0x24b3c058f388,~
code-source-info,0x24b32694311e,9,5115,5353,C0O5140C7O5150C11O5164C15O5201C25O5228C30O5226C37O5262C48O5281C56O5317C61O5262C66O5338C68O5349,,
code-creation,LazyCompile,10,40815,0x24b32694394e,213,prepareMainThreadExecution node:internal/bootstrap/pre_execution:22:36,0x24b357dbf1c8,~
code-source-info,0x24b32694394e,93,491,2380,C10O634C15O634C18O736C21O736C25O771C28O771C31O800C34O800C37O820C40O820C43O845C46O845C49O1048C52O1060C57O1064C63O1088C66O1096C77O1152C82O1156C87O1125C91O1117C95O1183C98O1183C101O1275C104O1275C107O1381C110O1381C113O1403C116O1403C119O1462C122O1462C125O1785C128O1785C131O1860C134O1860C137O2057C140O2057C143O2084C146O2084C149O2118C152O2118C155O2146C158O2146C161O2166C164O2166C167O2191C170O2191C173O2235C179O2235C184O2277C189O2295C195O2277C199O2325C202O2325C205O2349C208O2349C212O2379,,
code-creation,LazyCompile,10,40935,0x24b326944b76,19,reconnectZeroFillToggle node:internal/buffer:1072:33,0x24b3608b1cd0,~
script-source,19,node:internal/buffer,'use strict';\n\nconst {\n  BigInt\x2C\n  Float32Array\x2C\n  Float64Array\x2C\n  MathFloor\x2C\n  Number\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\n} = require('internal/errors').codes;\nconst { validateNumber } = require('internal/validators');\nconst {\n  asciiSlice\x2C\n  base64Slice\x2C\n  base64urlSlice\x2C\n  latin1Slice\x2C\n  hexSlice\x2C\n  ucs2Slice\x2C\n  utf8Slice\x2C\n  asciiWrite\x2C\n  base64Write\x2C\n  base64urlWrite\x2C\n  latin1Write\x2C\n  hexWrite\x2C\n  ucs2Write\x2C\n  utf8Write\x2C\n  getZeroFillToggle\n} = internalBinding('buffer');\nconst {\n  untransferable_object_private_symbol\x2C\n  setHiddenValue\x2C\n} = internalBinding('util');\n\n// Temporary buffers to convert numbers.\nconst float32Array = new Float32Array(1);\nconst uInt8Float32Array = new Uint8Array(float32Array.buffer);\nconst float64Array = new Float64Array(1);\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer);\n\n// Check endianness.\nfloat32Array[0] = -1; // 0xBF800000\n// Either it is [0\x2C 0\x2C 128\x2C 191] or [191\x2C 128\x2C 0\x2C 0]. It is not possible to\n// check this with `os.endianness()` because that is determined at compile time.\nconst bigEndian = uInt8Float32Array[3] === 0;\n\nfunction checkBounds(buf\x2C offset\x2C byteLength) {\n  validateNumber(offset\x2C 'offset');\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined)\n    boundsError(offset\x2C buf.length - (byteLength + 1));\n}\n\nfunction checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : '';\n    let range;\n    if (byteLength > 3) {\n      if (min === 0 || min === 0n) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` +\n                `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`;\n    }\n    throw new ERR_OUT_OF_RANGE('value'\x2C range\x2C value);\n  }\n  checkBounds(buf\x2C offset\x2C byteLength);\n}\n\nfunction boundsError(value\x2C length\x2C type) {\n  if (MathFloor(value) !== value) {\n    validateNumber(value\x2C type);\n    throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C 'an integer'\x2C value);\n  }\n\n  if (length < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n  throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C\n                             `>= ${type ? 1 : 0} and <= ${length}`\x2C\n                             value);\n}\n\n// Read integers.\nfunction readBigUInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24;\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n\n  return BigInt(lo) + (BigInt(hi) << 32n);\n}\n\nfunction readBigUInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n\n  return (BigInt(hi) << 32n) + BigInt(lo);\n}\n\nfunction readBigInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24); // Overflow\n  return (BigInt(val) << 32n) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24);\n}\n\nfunction readBigInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n  return (BigInt(val) << 32n) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last);\n}\n\nfunction readUIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32LE(offset);\n  if (byteLength === 2)\n    return this.readUInt16LE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    (buf[++offset] + last * 2 ** 8) * 2 ** 32;\n}\n\nfunction readUInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    last * 2 ** 32;\n}\n\nfunction readUInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n}\n\nfunction readUInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n}\n\nfunction readUInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first + last * 2 ** 8;\n}\n\nfunction readUInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val;\n}\n\nfunction readUIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32BE(offset);\n  if (byteLength === 2)\n    return this.readUInt16BE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\n\nfunction readUInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first * 2 ** 8 + last;\n}\n\nfunction readIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32LE(offset);\n  if (byteLength === 2)\n    return this.readInt16LE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[offset + 4] + last * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    (last << 24); // Overflow\n}\n\nfunction readInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first + last * 2 ** 8;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\nfunction readInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val | (val & 2 ** 7) * 0x1fffffe;\n}\n\nfunction readIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32BE(offset);\n  if (byteLength === 2)\n    return this.readInt16BE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[++offset] + first * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first * 2 ** 8 + last;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\n// Read floats\nfunction readFloatBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[3] = first;\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[0] = last;\n  return float32Array[0];\n}\n\nfunction readFloatForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[0] = first;\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[3] = last;\n  return float32Array[0];\n}\n\nfunction readDoubleBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[7] = first;\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[0] = last;\n  return float64Array[0];\n}\n\nfunction readDoubleForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[0] = first;\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[7] = last;\n  return float64Array[0];\n}\n\n// Write integers.\nfunction writeBigU_Int64LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  return offset;\n}\n\nfunction writeBigUInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigU_Int64BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset + 7] = lo;\n  lo = lo >> 8;\n  buf[offset + 6] = lo;\n  lo = lo >> 8;\n  buf[offset + 5] = lo;\n  lo = lo >> 8;\n  buf[offset + 4] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset + 3] = hi;\n  hi = hi >> 8;\n  buf[offset + 2] = hi;\n  hi = hi >> 8;\n  buf[offset + 1] = hi;\n  hi = hi >> 8;\n  buf[offset] = hi;\n  return offset + 8;\n}\n\nfunction writeBigUInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeBigInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeUIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = newVal;\n  buf[offset++] = (newVal >>> 8);\n  return offset;\n}\n\nfunction writeU_Int40LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  const newVal = value;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = MathFloor(newVal * 2 ** -32);\n  return offset;\n}\n\nfunction writeU_Int32LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeU_Int16LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = value;\n  buf[offset++] = (value >>> 8);\n  return offset;\n}\n\nfunction writeUInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeU_Int8(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  // `checkInt()` can not be used here because it checks two entries.\n  validateNumber(offset\x2C 'offset');\n  if (value > max || value < min) {\n    throw new ERR_OUT_OF_RANGE('value'\x2C `>= ${min} and <= ${max}`\x2C value);\n  }\n  if (buf[offset] === undefined)\n    boundsError(offset\x2C buf.length - 1);\n\n  buf[offset] = value;\n  return offset + 1;\n}\n\nfunction writeUInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n}\n\nfunction writeUIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = (newVal >>> 8);\n  buf[offset++] = newVal;\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int40BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  buf[offset++] = MathFloor(value * 2 ** -32);\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int32BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeUInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 3;\n}\n\nfunction writeU_Int16BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = (value >>> 8);\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\nfunction writeInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n}\n\nfunction writeIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\n// Write floats.\nfunction writeDoubleForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[0];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[7];\n  return offset;\n}\n\nfunction writeDoubleBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[7];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[0];\n  return offset;\n}\n\nfunction writeFloatForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[0];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[3];\n  return offset;\n}\n\nfunction writeFloatBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[3];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[0];\n  return offset;\n}\n\nclass FastBuffer extends Uint8Array {\n  // Using an explicit constructor here is necessary to avoid relying on\n  // `Array.prototype[Symbol.iterator]`\x2C which can be mutated by users.\n  // eslint-disable-next-line no-useless-constructor\n  constructor(bufferOrLength\x2C byteOffset\x2C length) {\n    super(bufferOrLength\x2C byteOffset\x2C length);\n  }\n}\n\nfunction addBufferPrototypeMethods(proto) {\n  proto.readBigUInt64LE = readBigUInt64LE;\n  proto.readBigUInt64BE = readBigUInt64BE;\n  proto.readBigUint64LE = readBigUInt64LE;\n  proto.readBigUint64BE = readBigUInt64BE;\n  proto.readBigInt64LE = readBigInt64LE;\n  proto.readBigInt64BE = readBigInt64BE;\n  proto.writeBigUInt64LE = writeBigUInt64LE;\n  proto.writeBigUInt64BE = writeBigUInt64BE;\n  proto.writeBigUint64LE = writeBigUInt64LE;\n  proto.writeBigUint64BE = writeBigUInt64BE;\n  proto.writeBigInt64LE = writeBigInt64LE;\n  proto.writeBigInt64BE = writeBigInt64BE;\n\n  proto.readUIntLE = readUIntLE;\n  proto.readUInt32LE = readUInt32LE;\n  proto.readUInt16LE = readUInt16LE;\n  proto.readUInt8 = readUInt8;\n  proto.readUIntBE = readUIntBE;\n  proto.readUInt32BE = readUInt32BE;\n  proto.readUInt16BE = readUInt16BE;\n  proto.readUintLE = readUIntLE;\n  proto.readUint32LE = readUInt32LE;\n  proto.readUint16LE = readUInt16LE;\n  proto.readUint8 = readUInt8;\n  proto.readUintBE = readUIntBE;\n  proto.readUint32BE = readUInt32BE;\n  proto.readUint16BE = readUInt16BE;\n  proto.readIntLE = readIntLE;\n  proto.readInt32LE = readInt32LE;\n  proto.readInt16LE = readInt16LE;\n  proto.readInt8 = readInt8;\n  proto.readIntBE = readIntBE;\n  proto.readInt32BE = readInt32BE;\n  proto.readInt16BE = readInt16BE;\n\n  proto.writeUIntLE = writeUIntLE;\n  proto.writeUInt32LE = writeUInt32LE;\n  proto.writeUInt16LE = writeUInt16LE;\n  proto.writeUInt8 = writeUInt8;\n  proto.writeUIntBE = writeUIntBE;\n  proto.writeUInt32BE = writeUInt32BE;\n  proto.writeUInt16BE = writeUInt16BE;\n  proto.writeUintLE = writeUIntLE;\n  proto.writeUint32LE = writeUInt32LE;\n  proto.writeUint16LE = writeUInt16LE;\n  proto.writeUint8 = writeUInt8;\n  proto.writeUintBE = writeUIntBE;\n  proto.writeUint32BE = writeUInt32BE;\n  proto.writeUint16BE = writeUInt16BE;\n  proto.writeIntLE = writeIntLE;\n  proto.writeInt32LE = writeInt32LE;\n  proto.writeInt16LE = writeInt16LE;\n  proto.writeInt8 = writeInt8;\n  proto.writeIntBE = writeIntBE;\n  proto.writeInt32BE = writeInt32BE;\n  proto.writeInt16BE = writeInt16BE;\n\n  proto.readFloatLE = bigEndian ? readFloatBackwards : readFloatForwards;\n  proto.readFloatBE = bigEndian ? readFloatForwards : readFloatBackwards;\n  proto.readDoubleLE = bigEndian ? readDoubleBackwards : readDoubleForwards;\n  proto.readDoubleBE = bigEndian ? readDoubleForwards : readDoubleBackwards;\n  proto.writeFloatLE = bigEndian ? writeFloatBackwards : writeFloatForwards;\n  proto.writeFloatBE = bigEndian ? writeFloatForwards : writeFloatBackwards;\n  proto.writeDoubleLE = bigEndian ? writeDoubleBackwards : writeDoubleForwards;\n  proto.writeDoubleBE = bigEndian ? writeDoubleForwards : writeDoubleBackwards;\n\n  proto.asciiSlice = asciiSlice;\n  proto.base64Slice = base64Slice;\n  proto.base64urlSlice = base64urlSlice;\n  proto.latin1Slice = latin1Slice;\n  proto.hexSlice = hexSlice;\n  proto.ucs2Slice = ucs2Slice;\n  proto.utf8Slice = utf8Slice;\n  proto.asciiWrite = asciiWrite;\n  proto.base64Write = base64Write;\n  proto.base64urlWrite = base64urlWrite;\n  proto.latin1Write = latin1Write;\n  proto.hexWrite = hexWrite;\n  proto.ucs2Write = ucs2Write;\n  proto.utf8Write = utf8Write;\n}\n\n// This would better be placed in internal/worker/io.js\x2C but that doesn't work\n// because Buffer needs this and that would introduce a cyclic dependency.\nfunction markAsUntransferable(obj) {\n  if ((typeof obj !== 'object' && typeof obj !== 'function') || obj === null)\n    return;  // This object is a primitive and therefore already untransferable.\n  setHiddenValue(obj\x2C untransferable_object_private_symbol\x2C true);\n}\n\n// A toggle used to access the zero fill setting of the array buffer allocator\n// in C++.\n// |zeroFill| can be undefined when running inside an isolate where we\n// do not own the ArrayBuffer allocator.  Zero fill is always on in that case.\nlet zeroFill = getZeroFillToggle();\nfunction createUnsafeBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new FastBuffer(size);\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\n\n// The connection between the JS land zero fill toggle and the\n// C++ one in the NodeArrayBufferAllocator gets lost if the toggle\n// is deserialized from the snapshot\x2C because V8 owns the underlying\n// memory of this toggle. This resets the connection.\nfunction reconnectZeroFillToggle() {\n  zeroFill = getZeroFillToggle();\n}\n\nmodule.exports = {\n  FastBuffer\x2C\n  addBufferPrototypeMethods\x2C\n  markAsUntransferable\x2C\n  createUnsafeBuffer\x2C\n  readUInt16BE\x2C\n  readUInt32BE\x2C\n  reconnectZeroFillToggle\n};\n
code-source-info,0x24b326944b76,19,30717,30757,C0O30724C5O30735C11O30733C18O30756,,
tick,0x7fff20385158,43011,0,0x0,3,0x10c825337,0x24b32694395d,0x24b357dbd30d
tick,0x10c2db3e3,43034,1,0x10c2db3e3,6,0x10c4a5769,0x24b326944b7b,0x24b32694395d,0x24b357dbd30d
code-creation,LazyCompile,10,43151,0x24b3269473c6,432,patchProcessObject node:internal/bootstrap/pre_execution:81:28,0x24b357dbf218,~
code-source-info,0x24b3269473c6,93,2409,4251,C0O2443C6O2443C11O2489C19O2489C24O2727C30O2727C35O2765C40O2766C46O2696C51O2708C56O2791C61O2806C65O2818C68O2826C75O2840C79O2859C90O2880C98O2966C104O2970C111O2859C116O2982C119O2990C129O3008C133O2998C137O3021C144O3048C151O3052C158O3066C164O3100C171O3104C178O3066C185O3182C191O3182C199O3215C202O3223C210O3238C218O3254C225O3258C229O3238C234O3231C244O3426C253O3426C258O3472C267O3472C272O3525C281O3525C286O3585C295O3585C300O3643C309O3643C314O3703C323O3703C328O3767C337O3767C342O3832C351O3832C356O3903C365O3903C370O3973C379O3973C384O4033C393O4033C398O4103C409O4103C414O4173C425O4173C431O4250,,
code-creation,LazyCompile,10,43352,0x24b326947a66,113,getFastAPIs node:internal/process/per_thread:57:21,0x24b3608bde80,~
script-source,23,node:internal/process/per_thread,'use strict';\n\n// This files contains process bootstrappers that can be\n// run when setting up each thread\x2C including the main\n// thread and the worker threads.\n\nconst {\n  ArrayPrototypeEvery\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSplice\x2C\n  BigUint64Array\x2C\n  Float64Array\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  ObjectFreeze\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  Set\x2C\n  SetPrototypeEntries\x2C\n  SetPrototypeValues\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  Uint32Array\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_ASSERTION\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\n  }\n} = require('internal/errors');\nconst format = require('internal/util/inspect').format;\nconst {\n  validateArray\x2C\n  validateNumber\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst constants = internalBinding('constants').os.signals;\n\nconst kInternal = Symbol('internal properties');\n\nfunction assert(x\x2C msg) {\n  if (!x) throw new ERR_ASSERTION(msg || 'assertion error');\n}\n\nfunction getFastAPIs(binding) {\n  const {\n    hrtime: _hrtime\n  } = binding.getFastAPIs();\n\n  // The 3 entries filled in by the original process.hrtime contains\n  // the upper/lower 32 bits of the second part of the value\x2C\n  // and the remaining nanoseconds of the value.\n  const hrValues = new Uint32Array(_hrtime.buffer);\n\n  function hrtime(time) {\n    _hrtime.hrtime();\n\n    if (time !== undefined) {\n      validateArray(time\x2C 'time');\n      if (time.length !== 2) {\n        throw new ERR_OUT_OF_RANGE('time'\x2C 2\x2C time.length);\n      }\n\n      const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];\n      const nsec = hrValues[2] - time[1];\n      const needsBorrow = nsec < 0;\n      return [needsBorrow ? sec - 1 : sec\x2C needsBorrow ? nsec + 1e9 : nsec];\n    }\n\n    return [\n      hrValues[0] * 0x100000000 + hrValues[1]\x2C\n      hrValues[2]\x2C\n    ];\n  }\n\n  // Use a BigUint64Array in the closure because this is actually a bit\n  // faster than simply returning a BigInt from C++ in V8 7.1.\n  const hrBigintValues = new BigUint64Array(_hrtime.buffer\x2C 0\x2C 1);\n  function hrtimeBigInt() {\n    _hrtime.hrtimeBigInt();\n    return hrBigintValues[0];\n  }\n\n  return {\n    hrtime\x2C\n    hrtimeBigInt\x2C\n  };\n}\n\n// The execution of this function itself should not cause any side effects.\nfunction wrapProcessMethods(binding) {\n  const {\n    cpuUsage: _cpuUsage\x2C\n    memoryUsage: _memoryUsage\x2C\n    rss\x2C\n    resourceUsage: _resourceUsage\n  } = binding;\n\n  function _rawDebug(...args) {\n    binding._rawDebug(ReflectApply(format\x2C null\x2C args));\n  }\n\n  // Create the argument array that will be passed to the native function.\n  const cpuValues = new Float64Array(2);\n\n  // Replace the native function with the JS version that calls the native\n  // function.\n  function cpuUsage(prevValue) {\n    // If a previous value was passed in\x2C ensure it has the correct shape.\n    if (prevValue) {\n      if (!previousValueIsValid(prevValue.user)) {\n        validateObject(prevValue\x2C 'prevValue');\n\n        validateNumber(prevValue.user\x2C 'prevValue.user');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.user'\x2C\n                                                   prevValue.user);\n      }\n\n      if (!previousValueIsValid(prevValue.system)) {\n        validateNumber(prevValue.system\x2C 'prevValue.system');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.system'\x2C\n                                                   prevValue.system);\n      }\n    }\n\n    // Call the native function to get the current values.\n    _cpuUsage(cpuValues);\n\n    // If a previous value was passed in\x2C return diff of current from previous.\n    if (prevValue) {\n      return {\n        user: cpuValues[0] - prevValue.user\x2C\n        system: cpuValues[1] - prevValue.system\n      };\n    }\n\n    // If no previous value passed in\x2C return current value.\n    return {\n      user: cpuValues[0]\x2C\n      system: cpuValues[1]\n    };\n  }\n\n  // Ensure that a previously passed in value is valid. Currently\x2C the native\n  // implementation always returns numbers <= Number.MAX_SAFE_INTEGER.\n  function previousValueIsValid(num) {\n    return typeof num === 'number' &&\n        num <= NumberMAX_SAFE_INTEGER &&\n        num >= 0;\n  }\n\n  const memValues = new Float64Array(5);\n  function memoryUsage() {\n    _memoryUsage(memValues);\n    return {\n      rss: memValues[0]\x2C\n      heapTotal: memValues[1]\x2C\n      heapUsed: memValues[2]\x2C\n      external: memValues[3]\x2C\n      arrayBuffers: memValues[4]\n    };\n  }\n\n  memoryUsage.rss = rss;\n\n  function exit(code) {\n    if (code || code === 0)\n      process.exitCode = code;\n\n    if (!process._exiting) {\n      process._exiting = true;\n      process.emit('exit'\x2C process.exitCode || 0);\n    }\n    // FIXME(joyeecheung): This is an undocumented API that gets monkey-patched\n    // in the user land. Either document it\x2C or deprecate it in favor of a\n    // better public alternative.\n    process.reallyExit(process.exitCode || 0);\n  }\n\n  function kill(pid\x2C sig) {\n    let err;\n\n    // eslint-disable-next-line eqeqeq\n    if (pid != (pid | 0)) {\n      throw new ERR_INVALID_ARG_TYPE('pid'\x2C 'number'\x2C pid);\n    }\n\n    // Preserve null signal\n    if (sig === (sig | 0)) {\n      // XXX(joyeecheung): we have to use process._kill here because\n      // it's monkey-patched by tests.\n      err = process._kill(pid\x2C sig);\n    } else {\n      sig = sig || 'SIGTERM';\n      if (constants[sig]) {\n        err = process._kill(pid\x2C constants[sig]);\n      } else {\n        throw new ERR_UNKNOWN_SIGNAL(sig);\n      }\n    }\n\n    if (err)\n      throw errnoException(err\x2C 'kill');\n\n    return true;\n  }\n\n  const resourceValues = new Float64Array(16);\n  function resourceUsage() {\n    _resourceUsage(resourceValues);\n    return {\n      userCPUTime: resourceValues[0]\x2C\n      systemCPUTime: resourceValues[1]\x2C\n      maxRSS: resourceValues[2]\x2C\n      sharedMemorySize: resourceValues[3]\x2C\n      unsharedDataSize: resourceValues[4]\x2C\n      unsharedStackSize: resourceValues[5]\x2C\n      minorPageFault: resourceValues[6]\x2C\n      majorPageFault: resourceValues[7]\x2C\n      swappedOut: resourceValues[8]\x2C\n      fsRead: resourceValues[9]\x2C\n      fsWrite: resourceValues[10]\x2C\n      ipcSent: resourceValues[11]\x2C\n      ipcReceived: resourceValues[12]\x2C\n      signalsCount: resourceValues[13]\x2C\n      voluntaryContextSwitches: resourceValues[14]\x2C\n      involuntaryContextSwitches: resourceValues[15]\n    };\n  }\n\n\n  return {\n    _rawDebug\x2C\n    cpuUsage\x2C\n    resourceUsage\x2C\n    memoryUsage\x2C\n    kill\x2C\n    exit\n  };\n}\n\nconst replaceUnderscoresRegex = /_/g;\nconst leadingDashesRegex = /^--?/;\nconst trailingValuesRegex = /=.*$/;\n\n// This builds the initial process.allowedNodeEnvironmentFlags\n// from data in the config binding.\nfunction buildAllowedFlags() {\n  const {\n    envSettings: { kAllowedInEnvironment }\x2C\n    types: { kBoolean }\x2C\n  } = internalBinding('options');\n  const { options\x2C aliases } = require('internal/options');\n\n  const allowedNodeEnvironmentFlags = [];\n  for (const { 0: name\x2C 1: info } of options) {\n    if (info.envVarSettings === kAllowedInEnvironment) {\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C name);\n      if (info.type === kBoolean) {\n        const negatedName = `--no-${name.slice(2)}`;\n        ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C negatedName);\n      }\n    }\n  }\n\n  function isAccepted(to) {\n    if (!StringPrototypeStartsWith(to\x2C '-') || to === '--') return true;\n    const recursiveExpansion = aliases.get(to);\n    if (recursiveExpansion) {\n      if (recursiveExpansion[0] === to)\n        ArrayPrototypeSplice(recursiveExpansion\x2C 0\x2C 1);\n      return ArrayPrototypeEvery(recursiveExpansion\x2C isAccepted);\n    }\n    return options.get(to).envVarSettings === kAllowedInEnvironment;\n  }\n  for (const { 0: from\x2C 1: expansion } of aliases) {\n    if (ArrayPrototypeEvery(expansion\x2C isAccepted)) {\n      let canonical = from;\n      if (StringPrototypeEndsWith(canonical\x2C '='))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 1);\n      if (StringPrototypeEndsWith(canonical\x2C ' <arg>'))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 4);\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C canonical);\n    }\n  }\n\n  const trimLeadingDashes =\n    (flag) => StringPrototypeReplace(flag\x2C leadingDashesRegex\x2C '');\n\n  // Save these for comparison against flags provided to\n  // process.allowedNodeEnvironmentFlags.has() which lack leading dashes.\n  const nodeFlags = ArrayPrototypeMap(allowedNodeEnvironmentFlags\x2C\n                                      trimLeadingDashes);\n\n  class NodeEnvironmentFlagsSet extends Set {\n    constructor(array) {\n      super();\n      this[kInternal] = { array };\n    }\n\n    add() {\n      // No-op\x2C `Set` API compatible\n      return this;\n    }\n\n    delete() {\n      // No-op\x2C `Set` API compatible\n      return false;\n    }\n\n    clear() {\n      // No-op\x2C `Set` API compatible\n    }\n\n    has(key) {\n      // This will return `true` based on various possible\n      // permutations of a flag\x2C including present/missing leading\n      // dash(es) and/or underscores-for-dashes.\n      // Strips any values after `=`\x2C inclusive.\n      // TODO(addaleax): It might be more flexible to run the option parser\n      // on a dummy option set and see whether it rejects the argument or\n      // not.\n      if (typeof key === 'string') {\n        key = StringPrototypeReplace(key\x2C replaceUnderscoresRegex\x2C '-');\n        if (RegExpPrototypeTest(leadingDashesRegex\x2C key)) {\n          key = StringPrototypeReplace(key\x2C trailingValuesRegex\x2C '');\n          return ArrayPrototypeIncludes(this[kInternal].array\x2C key);\n        }\n        return ArrayPrototypeIncludes(nodeFlags\x2C key);\n      }\n      return false;\n    }\n\n    entries() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeEntries(this[kInternal].set);\n    }\n\n    forEach(callback\x2C thisArg = undefined) {\n      ArrayPrototypeForEach(\n        this[kInternal].array\x2C\n        (v) => ReflectApply(callback\x2C thisArg\x2C [v\x2C v\x2C this])\n      );\n    }\n\n    get size() {\n      return this[kInternal].array.length;\n    }\n\n    values() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeValues(this[kInternal].set);\n    }\n  }\n  NodeEnvironmentFlagsSet.prototype.keys =\n  NodeEnvironmentFlagsSet.prototype[SymbolIterator] =\n    NodeEnvironmentFlagsSet.prototype.values;\n\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype.constructor);\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype);\n\n  return ObjectFreeze(new NodeEnvironmentFlagsSet(\n    allowedNodeEnvironmentFlags\n  ));\n}\n\n// Lazy load internal/trace_events_async_hooks only if the async_hooks\n// trace event category is enabled.\nlet traceEventsAsyncHook;\n// Dynamically enable/disable the traceEventsAsyncHook\nfunction toggleTraceCategoryState(asyncHooksEnabled) {\n  if (asyncHooksEnabled) {\n    if (!traceEventsAsyncHook) {\n      traceEventsAsyncHook =\n        require('internal/trace_events_async_hooks').createHook();\n    }\n    traceEventsAsyncHook.enable();\n  } else if (traceEventsAsyncHook) {\n    traceEventsAsyncHook.disable();\n  }\n}\n\nmodule.exports = {\n  toggleTraceCategoryState\x2C\n  getFastAPIs\x2C\n  assert\x2C\n  buildAllowedFlags\x2C\n  wrapProcessMethods\n};\n
code-source-info,0x24b326947a66,23,1229,2412,C0O1229C24O1285C29O1285C34O1263C40O1500C50O1524C57O1500C62O1500C64O2232C74O2259C86O2232C91O2232C93O2367C100O2380C106O2392C112O2410,,
tick,0x7fff2038537c,44384,0,0x0,3,0x10c825337,0x24b3269473ee,0x24b326943963,0x24b357dbd30d
code-creation,LazyCompile,10,44685,0x24b326949136,175,resolve node:path:1091:10,0x24b3bc5a8b98,~
script-source,35,node:path,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst {\n  CHAR_UPPERCASE_A\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_UPPERCASE_Z\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_DOT\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\x2C\n  CHAR_QUESTION_MARK\x2C\n} = require('internal/constants');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path\x2C allowAboveRoot\x2C separator\x2C isPathSeparator) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = StringPrototypeCharCodeAt(path\x2C i);\n    else if (isPathSeparator(code))\n      break;\n    else\n      code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 1) !== CHAR_DOT ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = StringPrototypeLastIndexOf(res\x2C separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = StringPrototypeSlice(res\x2C 0\x2C lastSlashIndex);\n              lastSegmentLength =\n                res.length - 1 - StringPrototypeLastIndexOf(res\x2C separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += `${separator}${StringPrototypeSlice(path\x2C lastSlash + 1\x2C i)}`;\n        else\n          res = StringPrototypeSlice(path\x2C lastSlash + 1\x2C i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\n/**\n * @param {string} sep\n * @param {{\n *  dir?: string;\n *  root?: string;\n *  base?: string;\n *  name?: string;\n *  ext?: string;\n *  }} pathObject\n * @returns {string}\n */\nfunction _format(sep\x2C pathObject) {\n  validateObject(pathObject\x2C 'pathObject');\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nconst win32 = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedDevice = '';\n    let resolvedTail = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = args[i];\n        validateString(path\x2C 'path');\n\n        // Skip empty entries\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path\x2C get cwd for that drive\x2C or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points\x2C because UNC paths are always absolute.\n        path = process.env[`=${resolvedDevice}`] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not\x2C default to the drive's root.\n        if (path === undefined ||\n            (StringPrototypeToLowerCase(StringPrototypeSlice(path\x2C 0\x2C 2)) !==\n            StringPrototypeToLowerCase(resolvedDevice) &&\n            StringPrototypeCharCodeAt(path\x2C 2) === CHAR_BACKWARD_SLASH)) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n\n      const len = path.length;\n      let rootEnd = 0;\n      let device = '';\n      let isAbsolute = false;\n      const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n      // Try to match a root\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          // `path` contains just a path separator\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator\x2C we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          while (j < len &&\n                 !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            while (j < len &&\n                   isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              while (j < len &&\n                     !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                // We matched a UNC root\n                device =\n                  `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) &&\n                  StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n        // Possible device root\n        device = StringPrototypeSlice(path\x2C 0\x2C 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n          // Treat separator following drive name as an absolute path\n          // indicator\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (StringPrototypeToLowerCase(device) !==\n              StringPrototypeToLowerCase(resolvedDevice))\n            // This path points to another device so it is not applicable\n            continue;\n        } else {\n          resolvedDevice = device;\n        }\n      }\n\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0)\n          break;\n      } else {\n        resolvedTail =\n          `${StringPrototypeSlice(path\x2C rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeString(resolvedTail\x2C !resolvedAbsolute\x2C '\\\\'\x2C\n                                   isPathSeparator);\n\n    return resolvedAbsolute ?\n      `${resolvedDevice}\\\\${resolvedTail}` :\n      `${resolvedDevice}${resolvedTail}` || '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    // Try to match a root\n    if (len === 1) {\n      // `path` contains just a single char\x2C exit early to avoid\n      // unnecessary work\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator\x2C we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last)}\\\\`;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              device =\n                `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      device = StringPrototypeSlice(path\x2C 0\x2C 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        // Treat separator following drive name as an absolute path\n        // indicator\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n\n    let tail = rootEnd < len ?\n      normalizeString(StringPrototypeSlice(path\x2C rootEnd)\x2C\n                      !isAbsolute\x2C '\\\\'\x2C isPathSeparator) :\n      '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 &&\n        isPathSeparator(StringPrototypeCharCodeAt(path\x2C len - 1)))\n      tail += '\\\\';\n    if (device === undefined) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return false;\n\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n    return isPathSeparator(code) ||\n      // Possible device root\n      (len > 2 &&\n      isWindowsDeviceRoot(code) &&\n      StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n      isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)));\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n\n    let joined;\n    let firstPart;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += `\\\\${arg}`;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes\x2C because\n    // normalize() will mistake it for a UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at a UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as a UNC path it needs to\n    // have at least 2 components\x2C so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server'\x2C 'share') -> '\\\\\\\\server\\\\share\\\\')\n    let needsReplace = true;\n    let slashCount = 0;\n    if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 &&\n          isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 2)))\n            ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      while (slashCount < joined.length &&\n             isPathSeparator(StringPrototypeCharCodeAt(joined\x2C slashCount))) {\n        slashCount++;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = `\\\\${StringPrototypeSlice(joined\x2C slashCount)}`;\n    }\n\n    return win32.normalize(joined);\n  }\x2C\n\n  /**\n   * It will solve the relative path from `from` to `to`\x2C for instancee\n   * from = 'C:\\\\orandea\\\\test\\\\aaa'\n   * to = 'C:\\\\orandea\\\\impl\\\\bbb'\n   * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = StringPrototypeToLowerCase(fromOrig);\n    to = StringPrototypeToLowerCase(toOrig);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    let fromStart = 0;\n    while (fromStart < from.length &&\n           StringPrototypeCharCodeAt(from\x2C fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let fromEnd = from.length;\n    while (\n      fromEnd - 1 > fromStart &&\n      StringPrototypeCharCodeAt(from\x2C fromEnd - 1) === CHAR_BACKWARD_SLASH\n    ) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    let toStart = 0;\n    while (toStart < to.length &&\n           StringPrototypeCharCodeAt(to\x2C toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart &&\n           StringPrototypeCharCodeAt(to\x2C toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_BACKWARD_SLASH)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen\x2C so\n    // return the original `to`.\n    if (i !== length) {\n      if (lastCommonSep === -1)\n        return toOrig;\n    } else {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return StringPrototypeSlice(toOrig\x2C toStart + i + 1);\n        }\n        if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return StringPrototypeSlice(toOrig\x2C toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1)\n        lastCommonSep = 0;\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n\n    toStart += lastCommonSep;\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return `${out}${StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd)}`;\n\n    if (StringPrototypeCharCodeAt(toOrig\x2C toStart) === CHAR_BACKWARD_SLASH)\n      ++toStart;\n    return StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string' || path.length === 0)\n      return path;\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length <= 2)\n      return path;\n\n    if (StringPrototypeCharCodeAt(resolvedPath\x2C 0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_BACKWARD_SLASH) {\n        const code = StringPrototypeCharCodeAt(resolvedPath\x2C 2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root\x2C convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${StringPrototypeSlice(resolvedPath\x2C 2)}`;\n        }\n      }\n    } else if (\n      isWindowsDeviceRoot(StringPrototypeCharCodeAt(resolvedPath\x2C 0)) &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_COLON &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 2) === CHAR_BACKWARD_SLASH\n    ) {\n      // Matched device root\x2C convert the path to a long UNC path\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = -1;\n    let offset = 0;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      // `path` contains just a path separator\x2C exit early to avoid\n      // unnecessary work or a dot.\n      return isPathSeparator(code) ? path : '.';\n    }\n\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a "normal root" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    // Possible device root\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      rootEnd =\n        len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n\n      end = rootEnd;\n    }\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [ext]\n   * @returns {string}\n   */\n  basename(path\x2C ext) {\n    if (ext !== undefined)\n      validateString(ext\x2C 'ext');\n    validateString(path\x2C 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0)) &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      start = 2;\n    }\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= start; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0))) {\n      start = startPart = 2;\n    }\n\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '\\\\')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *  dir: string;\n   *  root: string;\n   *  base: string;\n   *  name: string;\n   *  ext: string;\n   *  }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n\n    const len = path.length;\n    let rootEnd = 0;\n    let code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        // `path` contains just a path separator\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      if (len <= 2) {\n        // `path` contains just a drive root\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        if (len === 3) {\n          // `path` contains just a drive root\x2C exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0)\n      ret.root = StringPrototypeSlice(path\x2C 0\x2C rootEnd);\n\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n           startDot === end - 1 &&\n           startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C startPart\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C startPart\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C startPart\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    // If the directory is the root\x2C use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise\x2C strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n    if (startPart > 0 && startPart !== rootEnd)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else\n      ret.dir = ret.root;\n\n    return ret;\n  }\x2C\n\n  sep: '\\\\'\x2C\n  delimiter: ';'\x2C\n  win32: null\x2C\n  posix: null\n};\n\nconst posixCwd = (() => {\n  if (platformIsWin32) {\n    // Converts Windows' backslash path separators to POSIX forward slashes\n    // and truncates any drive indicator\n    const regexp = /\\\\/g;\n    return () => {\n      const cwd = StringPrototypeReplace(process.cwd()\x2C regexp\x2C '/');\n      return StringPrototypeSlice(cwd\x2C StringPrototypeIndexOf(cwd\x2C '/'));\n    };\n  }\n\n  // We're already on POSIX\x2C no need for any transformations\n  return () => process.cwd();\n})();\n\nconst posix = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? args[i] : posixCwd();\n\n      validateString(path\x2C 'path');\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute =\n        StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath\x2C !resolvedAbsolute\x2C '/'\x2C\n                                   isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator =\n      StringPrototypeCharCodeAt(path\x2C path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path\x2C !isAbsolute\x2C '/'\x2C isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute)\n        return '/';\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator)\n      path += '/';\n\n    return isAbsolute ? `/${path}` : path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    return path.length > 0 &&\n           StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n    let joined;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += `/${arg}`;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  }\x2C\n\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = (fromLen < toLen ? fromLen : toLen);\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_FORWARD_SLASH)\n        lastCommonSep = i;\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return StringPrototypeSlice(to\x2C toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return StringPrototypeSlice(to\x2C toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${StringPrototypeSlice(to\x2C toStart + lastCommonSep)}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    if (path.length === 0)\n      return '.';\n    const hasRoot = StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [ext]\n   * @returns {string}\n   */\n  basename(path\x2C ext) {\n    if (ext !== undefined)\n      validateString(ext\x2C 'ext');\n    validateString(path\x2C 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= 0; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= 0; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '/')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *   dir: string;\n   *   root: string;\n   *   base: string;\n   *   name: string;\n   *   ext: string;\n   *   }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n          startDot === end - 1 &&\n          startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C start\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C start\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C start\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    if (startPart > 0)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  }\x2C\n\n  sep: '/'\x2C\n  delimiter: ':'\x2C\n  win32: null\x2C\n  posix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n// Legacy internal API\x2C docs-only deprecated: DEP0080\nwin32._makeLong = win32.toNamespacedPath;\nposix._makeLong = posix.toNamespacedPath;\n\nmodule.exports = platformIsWin32 ? win32 : posix;\n
code-source-info,0x24b326949136,35,33782,34692,C0O33782C3O33817C6O33848C8O33878C12O33885C16O33898C18O33892C25O33902C27O33946C28O33948C35O33959C42O33965C45O33965C49O33984C57O33984C62O34058C68O34065C73O34082C75O34107C87O34133C92O34155C99O34182C107O34221C109O34217C113O33921C118O33860C121O34437C126O34483C137O34452C143O34569C147O34599C152O34610C156O34625C157O34656C163O34663C174O34688,,
tick,0x7fff2038537c,47893,0,0x0,3,0x10c825337,0x24b3269474ab,0x24b326943963,0x24b357dbd30d
tick,0x7fff202df064,47954,0,0x0,3,0x10c825337,0x24b3269474ab,0x24b326943963,0x24b357dbd30d
tick,0x7fff2029a51b,47973,0,0x0,3,0x10c825337,0x24b3269474ab,0x24b326943963,0x24b357dbd30d
code-creation,LazyCompile,10,48017,0x24b32694c36e,30,validateString node:internal/validators:117:24,0x24b360899ef8,~
script-source,17,node:internal/validators,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  NumberIsInteger\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  NumberParseInt\x2C\n  RegExpPrototypeTest\x2C\n  String\x2C\n  StringPrototypeToUpperCase\x2C\n  StringPrototypeTrim\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_SOCKET_BAD_PORT\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n    ERR_INVALID_CALLBACK\x2C\n  }\n} = require('internal/errors');\nconst { normalizeEncoding } = require('internal/util');\nconst {\n  isArrayBufferView\n} = require('internal/util/types');\nconst { signals } = internalBinding('constants').os;\n\nfunction isInt32(value) {\n  return value === (value | 0);\n}\n\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string';\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land\x2C but any value higher than 0o777 will result in platform-specific\n * behaviors.\n *\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified\x2C will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value\x2C name\x2C def) {\n  value ??= def;\n  if (typeof value === 'string') {\n    if (!RegExpPrototypeTest(octalReg\x2C value)) {\n      throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C modeDesc);\n    }\n    value = NumberParseInt(value\x2C 8);\n  }\n\n  validateInt32(value\x2C name\x2C 0\x2C 2 ** 32 - 1);\n  return value;\n}\n\nconst validateInteger = hideStackFrames(\n  (value\x2C name\x2C min = NumberMIN_SAFE_INTEGER\x2C max = NumberMAX_SAFE_INTEGER) => {\n    if (typeof value !== 'number')\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    if (!NumberIsInteger(value))\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    if (value < min || value > max)\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n  }\n);\n\nconst validateInt32 = hideStackFrames(\n  (value\x2C name\x2C min = -2147483648\x2C max = 2147483647) => {\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (!isInt32(value)) {\n      if (typeof value !== 'number') {\n        throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n      }\n      if (!NumberIsInteger(value)) {\n        throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n      }\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n    if (value < min || value > max) {\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n  }\n);\n\nconst validateUint32 = hideStackFrames((value\x2C name\x2C positive) => {\n  if (!isUint32(value)) {\n    if (typeof value !== 'number') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    }\n    if (!NumberIsInteger(value)) {\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    }\n    const min = positive ? 1 : 0;\n    // 2 ** 32 === 4294967296\n    throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && < 4294967296`\x2C value);\n  }\n  if (positive && value === 0) {\n    throw new ERR_OUT_OF_RANGE(name\x2C '>= 1 && < 4294967296'\x2C value);\n  }\n});\n\nfunction validateString(value\x2C name) {\n  if (typeof value !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'string'\x2C value);\n}\n\nfunction validateNumber(value\x2C name) {\n  if (typeof value !== 'number')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n}\n\nconst validateOneOf = hideStackFrames((value\x2C name\x2C oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf\x2C value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf\x2C (v) =>\n        (typeof v === 'string' ? `'${v}'` : String(v)))\x2C\n      '\x2C ');\n    const reason = 'must be one of: ' + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\nfunction validateBoolean(value\x2C name) {\n  if (typeof value !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'boolean'\x2C value);\n}\n\n/**\n * @param {unknown} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean\x2C\n *   allowFunction?: boolean\x2C\n *   nullable?: boolean\n * }} [options]\n */\nconst validateObject = hideStackFrames(\n  (value\x2C name\x2C options) => {\n    const useDefaultOptions = options == null;\n    const allowArray = useDefaultOptions ? false : options.allowArray;\n    const allowFunction = useDefaultOptions ? false : options.allowFunction;\n    const nullable = useDefaultOptions ? false : options.nullable;\n    if ((!nullable && value === null) ||\n        (!allowArray && ArrayIsArray(value)) ||\n        (typeof value !== 'object' && (\n          !allowFunction || typeof value !== 'function'\n        ))) {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'Object'\x2C value);\n    }\n  });\n\nconst validateArray = hideStackFrames((value\x2C name\x2C minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Array'\x2C value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\nfunction validateSignalName(signal\x2C name = 'signal') {\n  validateString(signal\x2C name);\n\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal +\n                                   ' (signals must use all capital letters)');\n    }\n\n    throw new ERR_UNKNOWN_SIGNAL(signal);\n  }\n}\n\nconst validateBuffer = hideStackFrames((buffer\x2C name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C\n                                   ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n                                   buffer);\n  }\n});\n\nfunction validateEncoding(data\x2C encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding'\x2C encoding\x2C\n                                    `is invalid for data of length ${length}`);\n  }\n}\n\n// Check that the port number is not NaN when coerced to a number\x2C\n// is an integer and that it falls within the legal range of port numbers.\nfunction validatePort(port\x2C name = 'Port'\x2C allowZero = true) {\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\n      (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n      +port !== (+port >>> 0) ||\n      port > 0xFFFF ||\n      (port === 0 && !allowZero)) {\n    throw new ERR_SOCKET_BAD_PORT(name\x2C port\x2C allowZero);\n  }\n  return port | 0;\n}\n\nconst validateCallback = hideStackFrames((callback) => {\n  if (typeof callback !== 'function')\n    throw new ERR_INVALID_CALLBACK(callback);\n});\n\nconst validateAbortSignal = hideStackFrames((signal\x2C name) => {\n  if (signal !== undefined &&\n      (signal === null ||\n       typeof signal !== 'object' ||\n       !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'AbortSignal'\x2C signal);\n  }\n});\n\nconst validateFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\nconst validateUndefined = hideStackFrames((value\x2C name) => {\n  if (value !== undefined)\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'undefined'\x2C value);\n});\n\nmodule.exports = {\n  isInt32\x2C\n  isUint32\x2C\n  parseFileMode\x2C\n  validateArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateNumber\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validatePort\x2C\n  validateSignalName\x2C\n  validateString\x2C\n  validateUint32\x2C\n  validateUndefined\x2C\n  validateCallback\x2C\n  validateAbortSignal\x2C\n};\n
code-source-info,0x24b32694c36e,17,3398,3507,C0O3416C6O3451C22O3457C27O3451C29O3506,,
code-creation,LazyCompile,10,48604,0x24b32694ccce,13, node:path:1082:10,0x24b3bc5a8b48,~
code-source-info,0x24b32694ccce,35,33631,33650,C0O33645C3O33645C8O33645C12O33650,,
code-creation,LazyCompile,10,48659,0x24b32694cdce,40,wrappedCwd node:internal/bootstrap/switches/does_own_process_state:124:20,0x24b38114d988,~
script-source,91,node:internal/bootstrap/switches/does_own_process_state,'use strict';\n\nconst credentials = internalBinding('credentials');\nconst rawMethods = internalBinding('process_methods');\n\nprocess.abort = rawMethods.abort;\nprocess.umask = wrappedUmask;\nprocess.chdir = wrappedChdir;\nprocess.cwd = wrappedCwd;\n\nif (credentials.implementsPosixCredentials) {\n  const wrapped = wrapPosixCredentialSetters(credentials);\n\n  process.initgroups = wrapped.initgroups;\n  process.setgroups = wrapped.setgroups;\n  process.setegid = wrapped.setegid;\n  process.seteuid = wrapped.seteuid;\n  process.setgid = wrapped.setgid;\n  process.setuid = wrapped.setuid;\n}\n\n// ---- keep the attachment of the wrappers above so that it's easier to ----\n// ----              compare the setups side-by-side                    -----\n\nconst {\n  parseFileMode\x2C\n  validateArray\x2C\n  validateString\n} = require('internal/validators');\n\nfunction wrapPosixCredentialSetters(credentials) {\n  const {\n    codes: {\n      ERR_INVALID_ARG_TYPE\x2C\n      ERR_UNKNOWN_CREDENTIAL\n    }\n  } = require('internal/errors');\n  const {\n    validateUint32\n  } = require('internal/validators');\n\n  const {\n    initgroups: _initgroups\x2C\n    setgroups: _setgroups\x2C\n    setegid: _setegid\x2C\n    seteuid: _seteuid\x2C\n    setgid: _setgid\x2C\n    setuid: _setuid\n  } = credentials;\n\n  function initgroups(user\x2C extraGroup) {\n    validateId(user\x2C 'user');\n    validateId(extraGroup\x2C 'extraGroup');\n    // Result is 0 on success\x2C 1 if user is unknown\x2C 2 if group is unknown.\n    const result = _initgroups(user\x2C extraGroup);\n    if (result === 1) {\n      throw new ERR_UNKNOWN_CREDENTIAL('User'\x2C user);\n    } else if (result === 2) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C extraGroup);\n    }\n  }\n\n  function setgroups(groups) {\n    validateArray(groups\x2C 'groups');\n    for (let i = 0; i < groups.length; i++) {\n      validateId(groups[i]\x2C `groups[${i}]`);\n    }\n    // Result is 0 on success. A positive integer indicates that the\n    // corresponding group was not found.\n    const result = _setgroups(groups);\n    if (result > 0) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C groups[result - 1]);\n    }\n  }\n\n  function wrapIdSetter(type\x2C method) {\n    return function(id) {\n      validateId(id\x2C 'id');\n      if (typeof id === 'number') id |= 0;\n      // Result is 0 on success\x2C 1 if credential is unknown.\n      const result = method(id);\n      if (result === 1) {\n        throw new ERR_UNKNOWN_CREDENTIAL(type\x2C id);\n      }\n    };\n  }\n\n  function validateId(id\x2C name) {\n    if (typeof id === 'number') {\n      validateUint32(id\x2C name);\n    } else if (typeof id !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C ['number'\x2C 'string']\x2C id);\n    }\n  }\n\n  return {\n    initgroups\x2C\n    setgroups\x2C\n    setegid: wrapIdSetter('Group'\x2C _setegid)\x2C\n    seteuid: wrapIdSetter('User'\x2C _seteuid)\x2C\n    setgid: wrapIdSetter('Group'\x2C _setgid)\x2C\n    setuid: wrapIdSetter('User'\x2C _setuid)\n  };\n}\n\n// Cache the working directory to prevent lots of lookups. If the working\n// directory is changed by `chdir`\x2C it'll be updated.\nlet cachedCwd = '';\n\nfunction wrappedChdir(directory) {\n  validateString(directory\x2C 'directory');\n  rawMethods.chdir(directory);\n  // Mark cache that it requires an update.\n  cachedCwd = '';\n}\n\nfunction wrappedUmask(mask) {\n  if (mask !== undefined) {\n    mask = parseFileMode(mask\x2C 'mask');\n  }\n  return rawMethods.umask(mask);\n}\n\nfunction wrappedCwd() {\n  if (cachedCwd === '')\n    cachedCwd = rawMethods.cwd();\n  return cachedCwd;\n}\n
code-source-info,0x24b32694cdce,91,3341,3425,C0O3348C7O3362C12O3374C17O3397C22O3397C29O3384C35O3406C39O3423,,
tick,0x7fff203557c6,49081,1,0x10c35fed1,6,0x10c4a5769,0x24b32694cde4,0x24b32694ccd6,0x24b326949163,0x24b3269474ab,0x24b326943963,0x24b357dbd30d
code-creation,LazyCompile,10,49209,0x24b32694d436,442,normalizeString node:path:66:25,0x24b3bc5a86b0,~
code-source-info,0x24b32694d436,35,2161,4085,C0O2226C3O2256C5O2277C8O2294C10O2310C12O2328C14O2341C18O2333C23O2373C27O2366C32O2387C37O2394C45O2443C51O2472C53O2494C58O2530C64O2561C66O2581C69O2575C76O2593C83O2631C85O2640C90O2665C97O2672C104O2697C111O2718C114O2753C118O2760C122O2718C130O2769C132O2765C139O2793C142O2828C146O2835C150O2793C158O2844C160O2840C165O2874C172O2881C177O2923C182O2923C188O2979C190O2998C195O3022C198O3046C202O3104C215O3110C221O3210C225O3217C231O3223C234O3223C239O3221C243O3293C246O3320C248O3342C250O3377C256O3384C261O3405C264O3427C266O3462C269O3489C271O3511C273O3551C277O3594C283O3601C293O3610C308O3642C313O3706C319O3713C324O3728C326O3738C330O3750C335O3787C345O3750C363O3821C370O3864C380O3827C386O3881C388O3903C391O3915C395O3934C398O3955C402O3976C404O3989C406O3985C413O4006C418O4022C425O4049C428O2351C433O2315C439O4072C441O4083,,
code-creation,LazyCompile,10,49301,0x24b32694d7b6,8,isPosixPathSeparator node:path:56:30,0x24b3bc5a8610,~
code-source-info,0x24b32694d7b6,35,1854,1902,C0O1865C2O1881C4O1877C7O1900,,
code-creation,LazyCompile,10,49402,0x24b32694dc2e,63,addReadOnlyProcessAlias node:internal/bootstrap/pre_execution:129:33,0x24b357dbf268,~
code-source-info,0x24b32694dc2e,93,4285,4510,C16O4337C21O4337C26O4363C28O4380C36O4410C43O4473C49O4491C56O4380C62O4509,,
code-creation,LazyCompile,10,49463,0x24b32694ddae,82,getOptionValue node:internal/options:39:24,0x24b326942960,~
code-source-info,0x24b32694ddae,94,902,1145,C0O935C3O935C7O980C15O980C22O1030C30O1052C38O1052C43O1039C47O1030C53O1067C55O1092C60O1098C61O1120C66O1120C74O1135C81O1143,,
code-creation,LazyCompile,10,49506,0x24b32694e15e,33,getCLIOptionsFromBinding node:internal/options:18:34,0x24b326942870,~
code-source-info,0x24b32694e15e,94,497,598,C0O504C6O527C11O554C15O539C28O578C32O596,,
code-creation,LazyCompile,10,49846,0x24b32694e58e,46,setupTraceCategoryState node:internal/bootstrap/pre_execution:221:33,0x24b357dbf510,~
code-source-info,0x24b32694e58e,93,6753,6980,C0O6795C6O6795C11O6768C16O6867C22O6867C27O6838C32O6909C35O6934C40O6909C45O6979,,
code-creation,LazyCompile,10,49913,0x24b32694e726,77,toggleTraceCategoryState node:internal/process/per_thread:385:34,0x24b3608be470,~
code-source-info,0x24b32694e726,23,11040,11337,C0O11064C4O11093C10O11128C16O11159C21O11203C26O11204C33O11149C39O11228C44O11249C49O11249C55O11268C61O11300C66O11321C71O11321C76O11336,,
code-creation,LazyCompile,10,49953,0x24b32694e8d6,42,setupPerfHooks node:internal/bootstrap/pre_execution:227:24,0x24b357dbf560,~
code-source-info,0x24b32694e8d6,93,7005,7125,C0O7012C6O7012C11O7048C16O7049C20O7072C26O7072C31O7102C36O7103C41O7124,,
code-creation,LazyCompile,10,50003,0x24b32694ea56,42,refreshTimeOrigin node:internal/perf/performance:178:27,0x24b3cf283b38,~
script-source,70,node:internal/perf/performance,'use strict';\n\nconst {\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n  }\n} = require('internal/errors');\n\nconst {\n  EventTarget\x2C\n} = require('internal/event_target');\n\nconst { now } = require('internal/perf/utils');\n\nconst {\n  mark\x2C\n  measure\x2C\n  clearMarkTimings\x2C\n} = require('internal/perf/usertiming');\nconst {\n  clearEntriesFromBuffer\x2C\n  filterBufferMapByNameAndType\x2C\n} = require('internal/perf/observe');\n\nconst eventLoopUtilization = require('internal/perf/event_loop_utilization');\nconst nodeTiming = require('internal/perf/nodetiming');\nconst timerify = require('internal/perf/timerify');\nconst { customInspectSymbol: kInspect } = require('internal/util');\nconst { inspect } = require('util');\n\nconst {\n  getTimeOriginTimestamp\n} = internalBinding('performance');\n\nclass Performance extends EventTarget {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0) return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `Performance ${inspect({\n      nodeTiming: this.nodeTiming\x2C\n      timeOrigin: this.timeOrigin\x2C\n    }\x2C opts)}`;\n  }\n}\n\nfunction toJSON() {\n  return {\n    nodeTiming: this.nodeTiming\x2C\n    timeOrigin: this.timeOrigin\x2C\n    eventLoopUtilization: this.eventLoopUtilization()\n  };\n}\n\nfunction clearMarks(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearMarkTimings(name);\n  clearEntriesFromBuffer('mark'\x2C name);\n}\n\nfunction clearMeasures(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearEntriesFromBuffer('measure'\x2C name);\n}\n\nfunction getEntries() {\n  return filterBufferMapByNameAndType();\n}\n\nfunction getEntriesByName(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  return filterBufferMapByNameAndType(name\x2C undefined);\n}\n\nfunction getEntriesByType(type) {\n  if (type !== undefined) {\n    type = `${type}`;\n  }\n  return filterBufferMapByNameAndType(undefined\x2C type);\n}\n\nclass InternalPerformance extends EventTarget {}\nInternalPerformance.prototype.constructor = Performance.prototype.constructor;\nObjectSetPrototypeOf(InternalPerformance.prototype\x2C Performance.prototype);\n\nObjectDefineProperties(Performance.prototype\x2C {\n  clearMarks: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearMarks\x2C\n  }\x2C\n  clearMeasures: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearMeasures\x2C\n  }\x2C\n  eventLoopUtilization: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: eventLoopUtilization\x2C\n  }\x2C\n  getEntries: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntries\x2C\n  }\x2C\n  getEntriesByName: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntriesByName\x2C\n  }\x2C\n  getEntriesByType: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntriesByType\x2C\n  }\x2C\n  mark: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: mark\x2C\n  }\x2C\n  measure: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: measure\x2C\n  }\x2C\n  nodeTiming: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: nodeTiming\x2C\n  }\x2C\n  now: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: now\x2C\n  }\x2C\n  timerify: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: timerify\x2C\n  }\x2C\n  // This would be updated during pre-execution in case\n  // the process is launched from a snapshot.\n  // TODO(joyeecheung): we may want to warn about access to\n  // this during snapshot building.\n  timeOrigin: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  }\x2C\n  toJSON: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: toJSON\x2C\n  }\n});\n\nfunction refreshTimeOrigin() {\n  ObjectDefineProperty(Performance.prototype\x2C 'timeOrigin'\x2C {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  });\n}\n\nmodule.exports = {\n  InternalPerformance\x2C\n  refreshTimeOrigin\n};\n
code-source-info,0x24b32694ea56,70,3755,3912,C0O3762C7O3783C10O3795C25O3879C28O3879C35O3762C41O3911,,
code-creation,LazyCompile,10,50348,0x24b32694f166,19,refreshTimeOrigin node:internal/perf/utils:25:27,0x24b3bc5bbb30,~
script-source,41,node:internal/perf/utils,'use strict';\n\nconst binding = internalBinding('performance');\nconst {\n  milestones\x2C\n  getTimeOrigin\x2C\n} = binding;\n\n// TODO(joyeecheung): we may want to warn about access to\n// this during snapshot building.\nlet timeOrigin = getTimeOrigin();\n\nfunction now() {\n  const hr = process.hrtime();\n  return (hr[0] * 1000 + hr[1] / 1e6) - timeOrigin;\n}\n\nfunction getMilestoneTimestamp(milestoneIdx) {\n  const ns = milestones[milestoneIdx];\n  if (ns === -1)\n    return ns;\n  return ns / 1e6 - timeOrigin;\n}\n\nfunction refreshTimeOrigin() {\n  timeOrigin = getTimeOrigin();\n}\n\nmodule.exports = {\n  now\x2C\n  getMilestoneTimestamp\x2C\n  refreshTimeOrigin\n};\n
code-source-info,0x24b32694f166,41,525,563,C0O532C5O545C11O543C18O562,,
code-creation,LazyCompile,10,50477,0x24b32694f3d6,62,setupInspectorHooks node:internal/bootstrap/pre_execution:232:29,0x24b357dbf5b0,~
code-source-info,0x24b32694f3d6,93,7155,7708,C0O7498C6O7502C11O7527C17O7592C23O7592C28O7562C33O7576C38O7638C44O7638C49O7666C54O7667C61O7707,,
tick,0x7fff203572be,50563,0,0x0,3,0x10c825337,0x24b32694e8fa,0x24b326943970,0x24b357dbd30d
code-creation,Eval,10,50607,0x24b32694f786,5, node:internal/inspector_async_hook:1:1,0x24b32694f5d0,~
script-source,95,node:internal/inspector_async_hook,'use strict';\n\nlet hook;\nlet config;\n\nconst {\n  SafeSet\x2C\n} = primordials;\n\nfunction lazyHookCreation() {\n  const inspector = internalBinding('inspector');\n  const { createHook } = require('async_hooks');\n  config = internalBinding('config');\n\n  hook = createHook({\n    init(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n    // It's difficult to tell which tasks will be recurring and which won't\x2C\n    // therefore we mark all tasks as recurring. Based on the discussion\n    // in https://github.com/nodejs/node/pull/13870#discussion_r124515293\x2C\n    // this should be fine as long as we call asyncTaskCanceled() too.\n      const recurring = true;\n      if (type === 'PROMISE')\n        this.promiseIds.add(asyncId);\n      else\n        inspector.asyncTaskScheduled(type\x2C asyncId\x2C recurring);\n    }\x2C\n\n    before(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskStarted(asyncId);\n    }\x2C\n\n    after(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskFinished(asyncId);\n    }\x2C\n\n    destroy(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return this.promiseIds.delete(asyncId);\n      inspector.asyncTaskCanceled(asyncId);\n    }\x2C\n  });\n\n  hook.promiseIds = new SafeSet();\n}\n\nfunction enable() {\n  if (hook === undefined) lazyHookCreation();\n  if (config.bits < 64) {\n    // V8 Inspector stores task ids as (void*) pointers.\n    // async_hooks store ids as 64bit numbers.\n    // As a result\x2C we cannot reliably translate async_hook ids to V8 async_task\n    // ids on 32bit platforms.\n    process.emitWarning(\n      'Warning: Async stack traces in debugger are not available ' +\n      `on ${config.bits}bit platforms. The feature is disabled.`\x2C\n      {\n        code: 'INSPECTOR_ASYNC_STACK_TRACES_NOT_AVAILABLE'\x2C\n      });\n  } else {\n    hook.enable();\n  }\n}\n\nfunction disable() {\n  if (hook === undefined) lazyHookCreation();\n  hook.disable();\n}\n\nmodule.exports = {\n  enable\x2C\n  disable\n};\n
code-source-info,0x24b32694f786,95,0,1972,C0O0C4O1972,,
code-creation,Function,10,50751,0x24b32694f9a6,79, node:internal/inspector_async_hook:1:1,0x24b32694f700,~
code-source-info,0x24b32694f9a6,95,0,1972,C0O0C42O19C43O19C45O29C46O29C48O48C54O1930C61O1951C67O1961C73O1945C78O1971,,
code-creation,LazyCompile,10,50873,0x24b32694fe9e,69,setupWarningHandler node:internal/bootstrap/pre_execution:141:29,0x24b357dbf2b8,~
code-source-info,0x24b32694fe9e,93,4540,4737,C0O4575C6O4575C11O4559C16O4614C24O4618C33O4662C38O4666C45O4683C50O4698C53O4706C61O4706C68O4736,,
code-creation,LazyCompile,10,51091,0x24b32694fffe,20,addListener node:events:486:58,0x24b3c05b31d8,~
script-source,13,node:events,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  Boolean\x2C\n  Error\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  MathMin\x2C\n  NumberIsNaN\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromiseReject\x2C\n  PromiseResolve\x2C\n  ReflectOwnKeys\x2C\n  String\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolAsyncIterator\x2C\n} = primordials;\nconst kRejection = SymbolFor('nodejs.rejection');\nconst { inspect } = require('internal/util/inspect');\n\nlet spliceOne;\n\nconst {\n  AbortError\x2C\n  kEnhanceStackBeforeInspector\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNHANDLED_ERROR\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst kCapture = Symbol('kCapture');\nconst kErrorMonitor = Symbol('events.errorMonitor');\nconst kMaxEventTargetListeners = Symbol('events.maxEventTargetListeners');\nconst kMaxEventTargetListenersWarned =\n  Symbol('events.maxEventTargetListenersWarned');\n\n/**\n * Creates a new `EventEmitter` instance.\n * @param {{ captureRejections?: boolean; }} [opts]\n * @returns {EventEmitter}\n */\nfunction EventEmitter(opts) {\n  EventEmitter.init.call(this\x2C opts);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\nmodule.exports.on = on;\nmodule.exports.getEventListeners = getEventListeners;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.captureRejectionSymbol = kRejection;\nObjectDefineProperty(EventEmitter\x2C 'captureRejections'\x2C {\n  get() {\n    return EventEmitter.prototype[kCapture];\n  }\x2C\n  set(value) {\n    validateBoolean(value\x2C 'EventEmitter.captureRejections');\n\n    EventEmitter.prototype[kCapture] = value;\n  }\x2C\n  enumerable: true\n});\n\nEventEmitter.errorMonitor = kErrorMonitor;\n\n// The default for captureRejections is false\nObjectDefineProperty(EventEmitter.prototype\x2C kCapture\x2C {\n  value: false\x2C\n  writable: true\x2C\n  enumerable: false\n});\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nlet defaultMaxListeners = 10;\nlet isEventTarget;\n\nfunction checkListener(listener) {\n  validateFunction(listener\x2C 'listener');\n}\n\nObjectDefineProperty(EventEmitter\x2C 'defaultMaxListeners'\x2C {\n  enumerable: true\x2C\n  get: function() {\n    return defaultMaxListeners;\n  }\x2C\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new ERR_OUT_OF_RANGE('defaultMaxListeners'\x2C\n                                 'a non-negative number'\x2C\n                                 arg);\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nObjectDefineProperties(EventEmitter\x2C {\n  kMaxEventTargetListeners: {\n    value: kMaxEventTargetListeners\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\x2C\n  kMaxEventTargetListenersWarned: {\n    value: kMaxEventTargetListenersWarned\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\n});\n\n/**\n * Sets the max listeners.\n * @param {number} n\n * @param {EventTarget[] | EventEmitter[]} [eventTargets]\n * @returns {void}\n */\nEventEmitter.setMaxListeners =\n  function(n = defaultMaxListeners\x2C ...eventTargets) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n))\n      throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n    if (eventTargets.length === 0) {\n      defaultMaxListeners = n;\n    } else {\n      if (isEventTarget === undefined)\n        isEventTarget = require('internal/event_target').isEventTarget;\n\n      for (let i = 0; i < eventTargets.length; i++) {\n        const target = eventTargets[i];\n        if (isEventTarget(target)) {\n          target[kMaxEventTargetListeners] = n;\n          target[kMaxEventTargetListenersWarned] = false;\n        } else if (typeof target.setMaxListeners === 'function') {\n          target.setMaxListeners(n);\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\n            'eventTargets'\x2C\n            ['EventEmitter'\x2C 'EventTarget']\x2C\n            target);\n        }\n      }\n    }\n  };\n\nEventEmitter.init = function(opts) {\n\n  if (this._events === undefined ||\n      this._events === ObjectGetPrototypeOf(this)._events) {\n    this._events = ObjectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n\n\n  if (opts?.captureRejections) {\n    validateBoolean(opts.captureRejections\x2C 'options.captureRejections');\n    this[kCapture] = Boolean(opts.captureRejections);\n  } else {\n    // Assigning the kCapture property directly saves an expensive\n    // prototype lookup in a very sensitive hot path.\n    this[kCapture] = EventEmitter.prototype[kCapture];\n  }\n};\n\nfunction addCatch(that\x2C promise\x2C type\x2C args) {\n  if (!that[kCapture]) {\n    return;\n  }\n\n  // Handle Promises/A+ spec\x2C then could be a getter\n  // that throws on second use.\n  try {\n    const then = promise.then;\n\n    if (typeof then === 'function') {\n      then.call(promise\x2C undefined\x2C function(err) {\n        // The callback is called with nextTick to avoid a follow-up\n        // rejection from this promise.\n        process.nextTick(emitUnhandledRejectionOrErr\x2C that\x2C err\x2C type\x2C args);\n      });\n    }\n  } catch (err) {\n    that.emit('error'\x2C err);\n  }\n}\n\nfunction emitUnhandledRejectionOrErr(ee\x2C err\x2C type\x2C args) {\n  if (typeof ee[kRejection] === 'function') {\n    ee[kRejection](err\x2C type\x2C ...args);\n  } else {\n    // We have to disable the capture rejections mechanism\x2C otherwise\n    // we might end up in an infinite loop.\n    const prev = ee[kCapture];\n\n    // If the error handler throws\x2C it is not catcheable and it\n    // will end up in 'uncaughtException'. We restore the previous\n    // value of kCapture in case the uncaughtException is present\n    // and the exception is handled.\n    try {\n      ee[kCapture] = false;\n      ee.emit('error'\x2C err);\n    } finally {\n      ee[kCapture] = prev;\n    }\n  }\n}\n\n/**\n * Increases the max listeners of the event emitter.\n * @param {number} n\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\n/**\n * Returns the current max listener value for the event emitter.\n * @returns {number}\n */\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\n// Returns the length and line number of the first sequence of `a` that fully\n// appears in `b` with a length of at least 4.\nfunction identicalSequenceRange(a\x2C b) {\n  for (let i = 0; i < a.length - 3; i++) {\n    // Find the first entry of b that matches the current entry of a.\n    const pos = ArrayPrototypeIndexOf(b\x2C a[i]);\n    if (pos !== -1) {\n      const rest = b.length - pos;\n      if (rest > 3) {\n        let len = 1;\n        const maxLen = MathMin(a.length - i\x2C rest);\n        // Count the number of consecutive entries.\n        while (maxLen > len && a[i + len] === b[pos + len]) {\n          len++;\n        }\n        if (len > 3) {\n          return [len\x2C i];\n        }\n      }\n    }\n  }\n\n  return [0\x2C 0];\n}\n\nfunction enhanceStackTrace(err\x2C own) {\n  let ctorInfo = '';\n  try {\n    const { name } = this.constructor;\n    if (name !== 'EventEmitter')\n      ctorInfo = ` on ${name} instance`;\n  } catch {}\n  const sep = `\\nEmitted 'error' event${ctorInfo} at:\\n`;\n\n  const errStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(err.stack\x2C '\\n')\x2C 1);\n  const ownStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(own.stack\x2C '\\n')\x2C 1);\n\n  const { 0: len\x2C 1: off } = identicalSequenceRange(ownStack\x2C errStack);\n  if (len > 0) {\n    ArrayPrototypeSplice(ownStack\x2C off + 1\x2C len - 2\x2C\n                         '    [... lines matching original stack trace ...]');\n  }\n\n  return err.stack + sep + ArrayPrototypeJoin(ownStack\x2C '\\n');\n}\n\n/**\n * Synchronously calls each of the listeners registered\n * for the event.\n * @param {string | symbol} type\n * @param {...any} [args]\n * @returns {boolean}\n */\nEventEmitter.prototype.emit = function emit(type\x2C ...args) {\n  let doError = (type === 'error');\n\n  const events = this._events;\n  if (events !== undefined) {\n    if (doError && events[kErrorMonitor] !== undefined)\n      this.emit(kErrorMonitor\x2C ...args);\n    doError = (doError && events.error === undefined);\n  } else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    let er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      try {\n        const capture = {};\n        ErrorCaptureStackTrace(capture\x2C EventEmitter.prototype.emit);\n        ObjectDefineProperty(er\x2C kEnhanceStackBeforeInspector\x2C {\n          value: FunctionPrototypeBind(enhanceStackTrace\x2C this\x2C er\x2C capture)\x2C\n          configurable: true\n        });\n      } catch {}\n\n      // Note: The comments on the `throw` lines are intentional\x2C they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n\n    let stringifiedEr;\n    try {\n      stringifiedEr = inspect(er);\n    } catch {\n      stringifiedEr = er;\n    }\n\n    // At least give some kind of context to the user\n    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  const handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    const result = handler.apply(this\x2C args);\n\n    // We check if result is undefined first because that\n    // is the most common case so we do not pay any perf\n    // penalty\n    if (result !== undefined && result !== null) {\n      addCatch(this\x2C result\x2C type\x2C args);\n    }\n  } else {\n    const len = handler.length;\n    const listeners = arrayClone(handler);\n    for (let i = 0; i < len; ++i) {\n      const result = listeners[i].apply(this\x2C args);\n\n      // We check if result is undefined first because that\n      // is the most common case so we do not pay any perf\n      // penalty.\n      // This code is duplicated because extracting it away\n      // would make it non-inlineable.\n      if (result !== undefined && result !== null) {\n        addCatch(this\x2C result\x2C type\x2C args);\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target\x2C type\x2C listener\x2C prepend) {\n  let m;\n  let events;\n  let existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = ObjectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === "newListener"! Before\n    // adding it to the listeners\x2C first emit "newListener".\n    if (events.newListener !== undefined) {\n      target.emit('newListener'\x2C type\x2C\n                  listener.listener ?? listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element\x2C need to change to array.\n      existing = events[type] =\n        prepend ? [listener\x2C existing] : [existing\x2C listener];\n      // If we've already got an array\x2C just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventEmitter memory leak detected. ' +\n                          `${existing.length} ${String(type)} listeners ` +\n                          `added to ${inspect(target\x2C { depth: -1 })}. Use ` +\n                          'emitter.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      process.emitWarning(w);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Adds a listener to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.addListener = function addListener(type\x2C listener) {\n  return _addListener(this\x2C type\x2C listener\x2C false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n/**\n * Adds the `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependListener =\n    function prependListener(type\x2C listener) {\n      return _addListener(this\x2C type\x2C listener\x2C true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type\x2C this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target\x2C arguments);\n  }\n}\n\nfunction _onceWrap(target\x2C type\x2C listener) {\n  const state = { fired: false\x2C wrapFn: undefined\x2C target\x2C type\x2C listener };\n  const wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\n/**\n * Adds a one-time `listener` function to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.once = function once(type\x2C listener) {\n  checkListener(listener);\n\n  this.on(type\x2C _onceWrap(this\x2C type\x2C listener));\n  return this;\n};\n\n/**\n * Adds a one-time `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type\x2C listener) {\n      checkListener(listener);\n\n      this.prependListener(type\x2C _onceWrap(this\x2C type\x2C listener));\n      return this;\n    };\n\n/**\n * Removes the specified `listener` from the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeListener =\n    function removeListener(type\x2C listener) {\n      checkListener(listener);\n\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      const list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = ObjectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener'\x2C type\x2C list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        let position = -1;\n\n        for (let i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          if (spliceOne === undefined)\n            spliceOne = require('internal/util').spliceOne;\n          spliceOne(list\x2C position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener'\x2C type\x2C listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n/**\n * Removes all listeners from the event emitter. (Only\n * removes listeners for a specific event name if specified\n * as `type`).\n * @param {string | symbol} [type]\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      // Not listening for removeListener\x2C no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = ObjectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = ObjectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // Emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        for (const key of ReflectOwnKeys(events)) {\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = ObjectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      const listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type\x2C listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type\x2C listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target\x2C type\x2C unwrap) {\n  const events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  const evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener);\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this\x2C type\x2C true);\n};\n\n/**\n * Returns a copy of the array of listeners and wrappers for\n * the event name specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this\x2C type\x2C false);\n};\n\n/**\n * Returns the number of listeners listening to the event name\n * specified as `type`.\n * @deprecated since v3.2.0\n * @param {EventEmitter} emitter\n * @param {string | symbol} type\n * @returns {number}\n */\nEventEmitter.listenerCount = function(emitter\x2C type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  }\n  return FunctionPrototypeCall(listenerCount\x2C emitter\x2C type);\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\n/**\n * Returns the number of listeners listening to event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {number}\n */\nfunction listenerCount(type) {\n  const events = this._events;\n\n  if (events !== undefined) {\n    const evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Returns an array listing the events for which\n * the emitter has registered listeners.\n * @returns {any[]}\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr) {\n  // At least since V8 8.3\x2C this implementation is faster than the previous\n  // which always used a simple for-loop\n  switch (arr.length) {\n    case 2: return [arr[0]\x2C arr[1]];\n    case 3: return [arr[0]\x2C arr[1]\x2C arr[2]];\n    case 4: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]];\n    case 5: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]];\n    case 6: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]\x2C arr[5]];\n  }\n  return ArrayPrototypeSlice(arr);\n}\n\nfunction unwrapListeners(arr) {\n  const ret = arrayClone(arr);\n  for (let i = 0; i < ret.length; ++i) {\n    const orig = ret[i].listener;\n    if (typeof orig === 'function')\n      ret[i] = orig;\n  }\n  return ret;\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {EventEmitter | EventTarget} emitterOrTarget\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nfunction getEventListeners(emitterOrTarget\x2C type) {\n  // First check if EventEmitter\n  if (typeof emitterOrTarget.listeners === 'function') {\n    return emitterOrTarget.listeners(type);\n  }\n  // Require event target lazily to avoid always loading it\n  const { isEventTarget\x2C kEvents } = require('internal/event_target');\n  if (isEventTarget(emitterOrTarget)) {\n    const root = emitterOrTarget[kEvents].get(type);\n    const listeners = [];\n    let handler = root?.next;\n    while (handler?.listener !== undefined) {\n      const listener = handler.listener?.deref ?\n        handler.listener.deref() : handler.listener;\n      listeners.push(listener);\n      handler = handler.next;\n    }\n    return listeners;\n  }\n  throw new ERR_INVALID_ARG_TYPE('emitter'\x2C\n                                 ['EventEmitter'\x2C 'EventTarget']\x2C\n                                 emitterOrTarget);\n}\n\n/**\n * Creates a `Promise` that is fulfilled when the emitter\n * emits the given event.\n * @param {EventEmitter} emitter\n * @param {string} name\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {Promise}\n */\nasync function once(emitter\x2C name\x2C options = {}) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError();\n  return new Promise((resolve\x2C reject) => {\n    const errorListener = (err) => {\n      emitter.removeListener(name\x2C resolver);\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      reject(err);\n    };\n    const resolver = (...args) => {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error'\x2C errorListener);\n      }\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      resolve(args);\n    };\n    eventTargetAgnosticAddListener(emitter\x2C name\x2C resolver\x2C { once: true });\n    if (name !== 'error' && typeof emitter.once === 'function') {\n      emitter.once('error'\x2C errorListener);\n    }\n    function abortListener() {\n      eventTargetAgnosticRemoveListener(emitter\x2C name\x2C resolver);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorListener);\n      reject(new AbortError());\n    }\n    if (signal != null) {\n      eventTargetAgnosticAddListener(\n        signal\x2C 'abort'\x2C abortListener\x2C { once: true });\n    }\n  });\n}\n\nconst AsyncIteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf(async function* () {}).prototype);\n\nfunction createIterResult(value\x2C done) {\n  return { value\x2C done };\n}\n\nfunction eventTargetAgnosticRemoveListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.removeListener === 'function') {\n    emitter.removeListener(name\x2C listener);\n  } else if (typeof emitter.removeEventListener === 'function') {\n    emitter.removeEventListener(name\x2C listener\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags?.once) {\n      emitter.once(name\x2C listener);\n    } else {\n      emitter.on(name\x2C listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters\x2C we do not listen to `error` events here.\n    emitter.addEventListener(name\x2C (arg) => { listener(arg); }\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\n/**\n * Returns an `AsyncIterator` that iterates `event` events.\n * @param {EventEmitter} emitter\n * @param {string | symbol} event\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {AsyncIterator}\n */\nfunction on(emitter\x2C event\x2C options) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError();\n\n  const unconsumedEvents = [];\n  const unconsumedPromises = [];\n  let error = null;\n  let finished = false;\n\n  const iterator = ObjectSetPrototypeOf({\n    next() {\n      // First\x2C we consume all unread events\n      const value = unconsumedEvents.shift();\n      if (value) {\n        return PromiseResolve(createIterResult(value\x2C false));\n      }\n\n      // Then we error\x2C if an error happened\n      // This happens one time if at all\x2C because after 'error'\n      // we stop listening\n      if (error) {\n        const p = PromiseReject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n\n      // If the iterator is finished\x2C resolve to done\n      if (finished) {\n        return PromiseResolve(createIterResult(undefined\x2C true));\n      }\n\n      // Wait until an event happens\n      return new Promise(function(resolve\x2C reject) {\n        unconsumedPromises.push({ resolve\x2C reject });\n      });\n    }\x2C\n\n    return() {\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n\n      if (signal) {\n        eventTargetAgnosticRemoveListener(\n          signal\x2C\n          'abort'\x2C\n          abortListener\x2C\n          { once: true });\n      }\n\n      finished = true;\n\n      for (const promise of unconsumedPromises) {\n        promise.resolve(createIterResult(undefined\x2C true));\n      }\n\n      return PromiseResolve(createIterResult(undefined\x2C true));\n    }\x2C\n\n    throw(err) {\n      if (!err || !(err instanceof Error)) {\n        throw new ERR_INVALID_ARG_TYPE('EventEmitter.AsyncIterator'\x2C\n                                       'Error'\x2C err);\n      }\n      error = err;\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n    }\x2C\n\n    [SymbolAsyncIterator]() {\n      return this;\n    }\n  }\x2C AsyncIteratorPrototype);\n\n  eventTargetAgnosticAddListener(emitter\x2C event\x2C eventHandler);\n  if (event !== 'error' && typeof emitter.on === 'function') {\n    emitter.on('error'\x2C errorHandler);\n  }\n\n  if (signal) {\n    eventTargetAgnosticAddListener(\n      signal\x2C\n      'abort'\x2C\n      abortListener\x2C\n      { once: true });\n  }\n\n  return iterator;\n\n  function abortListener() {\n    errorHandler(new AbortError());\n  }\n\n  function eventHandler(...args) {\n    const promise = ArrayPrototypeShift(unconsumedPromises);\n    if (promise) {\n      promise.resolve(createIterResult(args\x2C false));\n    } else {\n      unconsumedEvents.push(args);\n    }\n  }\n\n  function errorHandler(err) {\n    finished = true;\n\n    const toError = ArrayPrototypeShift(unconsumedPromises);\n\n    if (toError) {\n      toError.reject(err);\n    } else {\n      // The next time we call next()\n      error = err;\n    }\n\n    iterator.return();\n  }\n}\n
code-source-info,0x24b32694fffe,13,14192,14264,C0O14213C14O14220C19O14262,,
tick,0x7fff20385398,53302,0,0x0,3,0x10c825337,0x24b32694fedb,0x24b32694397c,0x24b357dbd30d
tick,0x7fff203851aa,53322,0,0x0,3,0x10c825337,0x24b32694fedb,0x24b32694397c,0x24b357dbd30d
code-creation,LazyCompile,10,53534,0x24b32695225e,387,_addListener node:events:418:22,0x24b3c05b3138,~
code-source-info,0x24b32695225e,13,11979,13994,C0O12021C2O12030C4O12044C6O12057C9O12057C13O12101C18O12112C20O12144C22O12170C27O12170C32O12168C39O12194C40O12214C46O12380C52O12422C60O12475C77O12422C82O12654C87O12673C89O12690C93O12705C97O12816C99O12829C103O12845C109O12854C115O12883C121O12988C129O13022C140O13033C149O13043C166O13056C175O13066C182O13012C193O13141C197O13171C202O13171C209O13218C214O13218C219O13276C222O13280C227O13310C228O13316C233O13332C240O13339C245O13356C251O13372C252O13388C256O13521C264O13618C278O13628C281O13628C295O13578C304O13694C307O13702C312O13694C327O13654C333O13733C339O13521C345O13815C347O13822C351O13861C353O13871C357O13887C359O13894C363O13927C367O13916C371O13941C374O13949C379O13949C384O13978C386O13992,,
code-creation,LazyCompile,10,53641,0x24b326952596,15,checkListener node:events:127:23,0x24b3c05b2a98,~
code-source-info,0x24b326952596,13,3670,3726,C0O3685C8O3685C14O3725,,
code-creation,LazyCompile,10,53710,0x24b326952686,30, node:internal/validators:235:42,0x24b36089a390,~
code-source-info,0x24b326952686,17,7207,7323,C0O7228C6O7265C22O7271C27O7265C29O7322,,
code-creation,LazyCompile,10,53859,0x24b32695291e,380,emit node:events:340:44,0x24b3c05b3078,~
code-source-info,0x24b32695291e,13,9741,11955,C0O9741C8O9775C10O9781C14O9818C19O9829C21O9861C27O9883C29O9882C34O9924C41O9929C51O9924C56O9958C60O9987C68O10018C72O10036C73O10049C74O10108C78O10131C80O10148C86O10155C91O10166C92O10175C96O10184C98O10202C100O10191C108O10247C110O10259C120O10304C126O10314C132O10259C137O10329C145O10354C157O10403C174O10403C186O10329C197O10677C199O10677C200O10729C205O10760C211O10776C219O10774C220O10809C225O10906C232O10906C238O10950C240O10962C244O10972C246O10972C247O11033C249O11039C253O11050C255O11081C256O11094C257O11098C263O11162C268O11162C275O11316C281O11369C296O11369C303O11446C308O11476C311O11476C316O11514C318O11519C320O11519C325O11554C327O11563C332O11567C337O11567C344O11829C350O11884C365O11884C370O11528C375O11501C378O11941C379O11953,,
code-creation,LazyCompile,10,54006,0x24b326952cbe,172,startListeningIfSignal node:internal/process/signal:22:32,0x24b38114c438,~
script-source,90,node:internal/process/signal,'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  SafeMap\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n} = require('internal/errors');\n\nconst { signals } = internalBinding('constants').os;\n\nlet Signal;\nconst signalWraps = new SafeMap();\n\nfunction isSignal(event) {\n  return typeof event === 'string' && signals[event] !== undefined;\n}\n\n// Detect presence of a listener for the special signal types\nfunction startListeningIfSignal(type) {\n  if (isSignal(type) && !signalWraps.has(type)) {\n    if (Signal === undefined)\n      Signal = internalBinding('signal_wrap').Signal;\n    const wrap = new Signal();\n\n    wrap.unref();\n\n    wrap.onsignal = FunctionPrototypeBind(process.emit\x2C process\x2C type\x2C type);\n\n    const signum = signals[type];\n    const err = wrap.start(signum);\n    if (err) {\n      wrap.close();\n      throw errnoException(err\x2C 'uv_signal_start');\n    }\n\n    signalWraps.set(type\x2C wrap);\n  }\n}\n\nfunction stopListeningIfSignal(type) {\n  const wrap = signalWraps.get(type);\n  if (wrap !== undefined && process.listenerCount(type) === 0) {\n    wrap.close();\n    signalWraps.delete(type);\n  }\n}\n\nmodule.exports = {\n  startListeningIfSignal\x2C\n  stopListeningIfSignal\n};\n
code-source-info,0x24b326952cbe,90,429,904,C0O440C3O444C11O463C14O475C19O475C26O492C32O524C38O533C43O563C50O531C56O589C61O589C67O613C72O613C76O627C78O643C84O673C98O643C103O641C107O721C114O728C118O757C123O757C129O776C131O798C136O798C140O813C148O819C153O813C154O870C159O882C164O882C171O903,,
code-creation,LazyCompile,10,54168,0x24b32695307e,19,isSignal node:internal/process/signal:17:18,0x24b38114c280,~
code-source-info,0x24b32695307e,90,255,334,C0O267C8O303C13O310C17O318C18O332,,
code-creation,LazyCompile,10,54232,0x24b32695321e,75,setupDebugEnv node:internal/bootstrap/pre_execution:193:23,0x24b357dbf420,~
code-source-info,0x24b32695321e,93,6003,6213,C0O6010C6O6010C11O6043C19O6071C24O6075C29O6044C34O6090C42O6094C48O6138C54O6138C59O6175C64O6188C69O6189C74O6212,,
tick,0x10c780a36,54376,0,0x0,3,0x10c825337,0x24b32695323b,0x24b3269439b0,0x24b357dbd30d
code-creation,LazyCompile,10,54457,0x24b3269535b6,159,initializeDebugEnv node:internal/util/debuglog:22:28,0x24b3bc5baed8,~
script-source,40,node:internal/util/debuglog,'use strict';\n\nconst {\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n} = primordials;\n\nconst { inspect\x2C format\x2C formatWithOptions } = require('internal/util/inspect');\n\n// `debugImpls` and `testEnabled` are deliberately not initialized so any call\n// to `debuglog()` before `initializeDebugEnv()` is called will throw.\nlet debugImpls;\nlet testEnabled;\n\n\n// `debugEnv` is initial value of process.env.NODE_DEBUG\nfunction initializeDebugEnv(debugEnv) {\n  debugImpls = ObjectCreate(null);\n  if (debugEnv) {\n    // This is run before any user code\x2C it's OK not to use primordials.\n    debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g\x2C '\\\\$&')\n      .replaceAll('*'\x2C '.*')\n      .replaceAll('\x2C'\x2C '$|^');\n    const debugEnvRegex = new RegExp(`^${debugEnv}$`\x2C 'i');\n    testEnabled = (str) => RegExpPrototypeExec(debugEnvRegex\x2C str) !== null;\n  } else {\n    testEnabled = () => false;\n  }\n}\n\n// Emits warning when user sets\n// NODE_DEBUG=http or NODE_DEBUG=http2.\nfunction emitWarningIfNeeded(set) {\n  if ('HTTP' === set || 'HTTP2' === set) {\n    process.emitWarning('Setting the NODE_DEBUG environment variable ' +\n      'to \\'' + StringPrototypeToLowerCase(set) + '\\' can expose sensitive ' +\n      'data (such as passwords\x2C tokens and authentication headers) ' +\n      'in the resulting log.');\n  }\n}\n\nconst noop = () => {};\n\nfunction debuglogImpl(enabled\x2C set) {\n  if (debugImpls[set] === undefined) {\n    if (enabled) {\n      const pid = process.pid;\n      emitWarningIfNeeded(set);\n      debugImpls[set] = function debug(...args) {\n        const colors = process.stderr.hasColors && process.stderr.hasColors();\n        const msg = formatWithOptions({ colors }\x2C ...args);\n        const coloredPID = inspect(pid\x2C { colors });\n        process.stderr.write(format('%s %s: %s\\n'\x2C set\x2C coloredPID\x2C msg));\n      };\n    } else {\n      debugImpls[set] = noop;\n    }\n  }\n  return debugImpls[set];\n}\n\n// debuglogImpl depends on process.pid and process.env.NODE_DEBUG\x2C\n// so it needs to be called lazily in top scopes of internal modules\n// that may be loaded before these run time states are allowed to\n// be accessed.\nfunction debuglog(set\x2C cb) {\n  function init() {\n    set = StringPrototypeToUpperCase(set);\n    enabled = testEnabled(set);\n  }\n  let debug = (...args) => {\n    init();\n    // Only invokes debuglogImpl() when the debug function is\n    // called for the first time.\n    debug = debuglogImpl(enabled\x2C set);\n    if (typeof cb === 'function')\n      cb(debug);\n    switch (args.length) {\n      case 0: return debug();\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  let enabled;\n  let test = () => {\n    init();\n    test = () => enabled;\n    return enabled;\n  };\n  const logger = (...args) => {\n    switch (args.length) {\n      case 0: return debug();\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  ObjectDefineProperty(logger\x2C 'enabled'\x2C {\n    get() {\n      return test();\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\n  });\n  return logger;\n}\n\nmodule.exports = {\n  debuglog\x2C\n  initializeDebugEnv\n};\n
code-source-info,0x24b3269535b6,40,546,991,C0O561C7O574C14O572C20O596C31O709C44O709C51O753C62O754C69O782C80O783C88O833C100O848C116O833C121O833C123O871C132O883C144O959C151O971C158O990,,
new,MemoryChunk,0x114300000,262144
code-creation,Function,11,54887,0x114303080,588,getOptionValue node:internal/options:39:24,0x24b326942960,^
code-source-info,0x114303080,94,902,1145,,,
code-creation,Function,11,54925,0x114303380,120,isPosixPathSeparator node:path:56:30,0x24b3bc5a8610,^
code-source-info,0x114303380,35,1854,1902,,,
code-creation,Function,11,54979,0x114303480,3188,normalizeString node:path:66:25,0x24b3bc5a86b0,^
code-source-info,0x114303480,35,2161,4085,,,
code-creation,LazyCompile,10,55046,0x24b326953ebe,49,setupStacktracePrinterOnSigint node:internal/bootstrap/pre_execution:172:40,0x24b357dbf358,~
code-source-info,0x24b326953ebe,93,5567,5753,C0O5574C8O5579C14O5619C15O5626C16O5660C22O5660C27O5641C32O5710C38O5743C43O5743C48O5752,,
code-creation,LazyCompile,10,55124,0x24b32695412e,62,initializeReport node:internal/bootstrap/pre_execution:182:26,0x24b357dbf3a8,~
code-source-info,0x24b32695412e,93,5780,5979,C0O5780C8O5806C16O5806C21O5795C27O5844C42O5865C47O5937C55O5844C61O5978,,
code-creation,Eval,10,55380,0x24b3269546ae,5, node:internal/process/report:1:1,0x24b3269544a8,~
tick,0x7fff203572c8,55495,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b32695413e,0x24b3269439bc,0x24b357dbd30d
script-source,96,node:internal/process/report,'use strict';\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_SYNTHETIC\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateObject\x2C\n  validateSignalName\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst nr = internalBinding('report');\nconst {\n  JSONParse\x2C\n} = primordials;\nconst report = {\n  writeReport(file\x2C err) {\n    if (typeof file === 'object' && file !== null) {\n      err = file;\n      file = undefined;\n    } else if (file !== undefined && typeof file !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('file'\x2C 'String'\x2C file);\n    } else if (err === undefined) {\n      err = new ERR_SYNTHETIC();\n    } else {\n      validateObject(err\x2C 'err');\n    }\n\n    return nr.writeReport('JavaScript API'\x2C 'API'\x2C file\x2C err);\n  }\x2C\n  getReport(err) {\n    if (err === undefined)\n      err = new ERR_SYNTHETIC();\n    else\n      validateObject(err\x2C 'err');\n\n    return JSONParse(nr.getReport(err));\n  }\x2C\n  get directory() {\n    return nr.getDirectory();\n  }\x2C\n  set directory(dir) {\n    validateString(dir\x2C 'directory');\n    nr.setDirectory(dir);\n  }\x2C\n  get filename() {\n    return nr.getFilename();\n  }\x2C\n  set filename(name) {\n    validateString(name\x2C 'filename');\n    nr.setFilename(name);\n  }\x2C\n  get compact() {\n    return nr.getCompact();\n  }\x2C\n  set compact(b) {\n    validateBoolean(b\x2C 'compact');\n    nr.setCompact(b);\n  }\x2C\n  get signal() {\n    return nr.getSignal();\n  }\x2C\n  set signal(sig) {\n    validateSignalName(sig\x2C 'signal');\n    removeSignalHandler();\n    addSignalHandler(sig);\n    nr.setSignal(sig);\n  }\x2C\n  get reportOnFatalError() {\n    return nr.shouldReportOnFatalError();\n  }\x2C\n  set reportOnFatalError(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnFatalError(trigger);\n  }\x2C\n  get reportOnSignal() {\n    return nr.shouldReportOnSignal();\n  }\x2C\n  set reportOnSignal(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnSignal(trigger);\n    removeSignalHandler();\n    addSignalHandler();\n  }\x2C\n  get reportOnUncaughtException() {\n    return nr.shouldReportOnUncaughtException();\n  }\x2C\n  set reportOnUncaughtException(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnUncaughtException(trigger);\n  }\n};\n\nfunction addSignalHandler(sig) {\n  if (nr.shouldReportOnSignal()) {\n    if (typeof sig !== 'string')\n      sig = nr.getSignal();\n\n    process.on(sig\x2C signalHandler);\n  }\n}\n\nfunction removeSignalHandler() {\n  const sig = nr.getSignal();\n\n  if (sig)\n    process.removeListener(sig\x2C signalHandler);\n}\n\nfunction signalHandler(sig) {\n  nr.writeReport(sig\x2C 'Signal'\x2C null\x2C '');\n}\n\nmodule.exports = {\n  addSignalHandler\x2C\n  report\n};\n
code-source-info,0x24b3269546ae,96,0,2623,C0O0C4O2623,,
code-creation,Function,10,55818,0x24b3269551c6,315, node:internal/process/report:1:1,0x24b326954628,~
code-source-info,0x24b3269551c6,96,0,2623,C0O0C51O66C54O66C59O92C64O24C70O48C76O189C79O189C84O110C90O129C96O147C102O169C108O232C111O232C115O232C117O269C123O312C128O316C136O756C290O2572C297O2593C303O2613C309O2587C314O2622,,
code-creation,LazyCompile,10,56219,0x24b326956f06,21,initializeReportSignalHandlers node:internal/bootstrap/pre_execution:201:40,0x24b357dbf470,~
code-source-info,0x24b326956f06,93,6314,6410,C0O6350C6O6350C11O6329C16O6389C20O6409,,
code-creation,LazyCompile,10,56324,0x24b32695704e,57,addSignalHandler node:internal/process/report:97:26,0x24b3269546e0,~
code-source-info,0x24b32695704e,96,2222,2368,C0O2232C5O2239C10O2239C16O2269C22O2304C27O2313C32O2313C38O2331C41O2339C49O2339C56O2367,,
code-creation,LazyCompile,10,56393,0x24b32695760e,92,initializeHeapSnapshotSignalHandlers node:internal/bootstrap/pre_execution:207:46,0x24b357dbf4c0,~
code-source-info,0x24b32695760e,93,6457,6719,C0O6457C8O6479C18O6479C23O6523C25O6540C26O6547C27O6551C35O6551C40O6581C45O6582C50O6642C58O6642C63O6620C69O6660C74O6668C79O6671C84O6668C91O6718,,
code-creation,LazyCompile,10,56477,0x24b32695789e,138,setupChildProcessIpcChannel node:internal/bootstrap/pre_execution:337:37,0x24b357dbf690,~
code-source-info,0x24b32695789e,93,10471,11000,C0O10478C3O10490C8O10494C14O10532C20O10532C25O10576C33O10599C38O10603C46O10576C52O10629C53O10639C57O10629C61O10720C64O10735C73O10793C76O10801C81O10805C90O10852C93O10867C102O10909C108O10909C113O10933C118O10934C124O10973C127O10988C132O10973C137O10999,,
code-creation,LazyCompile,10,56683,0x24b326957c96,455,initializePolicy node:internal/bootstrap/pre_execution:365:26,0x24b357dbf730,~
code-source-info,0x24b326957c96,93,11299,13097,C0O11333C10O11333C15O11376C17O11406C21O11414C35O11414C41O11539C49O11539C55O11516C60O11531C65O11658C67O11675C75O11679C81O11694C87O11695C94O11735C100O11767C108O11749C116O11824C120O11846C126O11846C132O11824C138O11860C149O11876C153O11890C161O11904C167O11962C175O11962C180O11996C190O11996C197O12071C207O12071C212O12113C214O12166C222O12166C227O12244C235O12244C241O12212C246O12224C251O12293C257O12293C263O12343C269O12343C275O12402C277O12428C279O12452C283O12433C288O12542C290O12558C295O12493C300O12521C305O12584C311O12620C317O12620C322O12661C328O12661C334O12690C340O12710C344O12697C349O12730C356O12777C358O12806C360O12847C366O12869C376O12869C383O12847C389O12461C394O12415C397O12904C401O12931C415O12937C420O12931C421O13020C429O13020C435O13061C441O13085C447O13062C454O13096,,
code-creation,LazyCompile,10,56901,0x24b326958086,63,initializeClusterIPC node:internal/bootstrap/pre_execution:356:30,0x24b357dbf6e0,~
code-source-info,0x24b326958086,93,11031,11272,C0O11038C3O11050C10O11054C18O11069C23O11073C29O11111C35O11111C40O11143C45O11143C49O11232C52O11247C62O11271,,
tick,0x7fff203201cb,56954,0,0x0,3,0x10c825337,0x24b3269439d4,0x24b357dbd30d
code-creation,LazyCompile,10,56982,0x24b3269581f6,27,initializeSourceMapsHandlers node:internal/bootstrap/pre_execution:460:38,0x24b357dbf870,~
code-source-info,0x24b3269581f6,93,14830,14979,C0O14874C6O14874C11O14845C16O14925C21O14954C26O14978,,
code-creation,Eval,10,57365,0x24b326958bfe,5, node:internal/source_map/source_map_cache:1:1,0x24b326958898,~
script-source,97,node:internal/source_map/source_map_cache,'use strict';\n\nconst {\n  ArrayPrototypeMap\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectKeys\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeSplit\x2C\n} = primordials;\n\nfunction ObjectGetValueSafe(obj\x2C key) {\n  const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\n  return ObjectPrototypeHasOwnProperty(desc\x2C 'value') ? desc.value : undefined;\n}\n\n// See https://sourcemaps.info/spec.html for SourceMap V3 specification.\nconst { Buffer } = require('buffer');\nlet debug = require('internal/util/debuglog').debuglog('source_map'\x2C (fn) => {\n  debug = fn;\n});\nconst fs = require('fs');\nconst { getOptionValue } = require('internal/options');\nconst { IterableWeakMap } = require('internal/util/iterable_weak_map');\nconst {\n  normalizeReferrerURL\x2C\n} = require('internal/modules/cjs/helpers');\nconst { validateBoolean } = require('internal/validators');\n// Since the CJS module cache is mutable\x2C which leads to memory leaks when\n// modules are deleted\x2C we use a WeakMap so that the source map cache will\n// be purged automatically:\nconst cjsSourceMapCache = new IterableWeakMap();\n// The esm cache is not mutable\x2C so we can use a Map without memory concerns:\nconst esmSourceMapCache = new SafeMap();\nconst { fileURLToPath\x2C pathToFileURL\x2C URL } = require('internal/url');\nlet SourceMap;\n\nlet sourceMapsEnabled;\nfunction getSourceMapsEnabled() {\n  if (sourceMapsEnabled === undefined) {\n    setSourceMapsEnabled(getOptionValue('--enable-source-maps'));\n  }\n  return sourceMapsEnabled;\n}\n\nfunction setSourceMapsEnabled(val) {\n  validateBoolean(val\x2C 'val');\n\n  const {\n    setSourceMapsEnabled\x2C\n    setPrepareStackTraceCallback\n  } = internalBinding('errors');\n  setSourceMapsEnabled(val);\n  if (val) {\n    const {\n      prepareStackTrace\n    } = require('internal/source_map/prepare_stack_trace');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  } else if (sourceMapsEnabled !== undefined) {\n    // Reset prepare stack trace callback only when disabling source maps.\n    const {\n      prepareStackTrace\x2C\n    } = require('internal/errors');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  }\n\n  sourceMapsEnabled = val;\n}\n\nfunction maybeCacheSourceMap(filename\x2C content\x2C cjsModuleInstance) {\n  const sourceMapsEnabled = getSourceMapsEnabled();\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled)) return;\n  try {\n    filename = normalizeReferrerURL(filename);\n  } catch (err) {\n    // This is most likely an [eval]-wrapper\x2C which is currently not\n    // supported.\n    debug(err.stack);\n    return;\n  }\n  const match = StringPrototypeMatch(\n    content\x2C\n    /\\/[*/]#\\s+sourceMappingURL=(?<sourceMappingURL>[^\\s]+)/\n  );\n  if (match) {\n    const data = dataFromUrl(filename\x2C match.groups.sourceMappingURL);\n    const url = data ? null : match.groups.sourceMappingURL;\n    if (cjsModuleInstance) {\n      cjsSourceMapCache.set(cjsModuleInstance\x2C {\n        filename\x2C\n        lineLengths: lineLengths(content)\x2C\n        data\x2C\n        url\n      });\n    } else {\n      // If there is no cjsModuleInstance assume we are in a\n      // "modules/esm" context.\n      esmSourceMapCache.set(filename\x2C {\n        lineLengths: lineLengths(content)\x2C\n        data\x2C\n        url\n      });\n    }\n  }\n}\n\nfunction dataFromUrl(sourceURL\x2C sourceMappingURL) {\n  try {\n    const url = new URL(sourceMappingURL);\n    switch (url.protocol) {\n      case 'data:':\n        return sourceMapFromDataUrl(sourceURL\x2C url.pathname);\n      default:\n        debug(`unknown protocol ${url.protocol}`);\n        return null;\n    }\n  } catch (err) {\n    debug(err.stack);\n    // If no scheme is present\x2C we assume we are dealing with a file path.\n    const mapURL = new URL(sourceMappingURL\x2C sourceURL).href;\n    return sourceMapFromFile(mapURL);\n  }\n}\n\n// Cache the length of each line in the file that a source map was extracted\n// from. This allows translation from byte offset V8 coverage reports\x2C\n// to line/column offset Source Map V3.\nfunction lineLengths(content) {\n  // We purposefully keep \\r as part of the line-length calculation\x2C in\n  // cases where there is a \\r\\n separator\x2C so that this can be taken into\n  // account in coverage calculations.\n  return ArrayPrototypeMap(StringPrototypeSplit(content\x2C /\\n|\\u2028|\\u2029/)\x2C (line) => {\n    return line.length;\n  });\n}\n\nfunction sourceMapFromFile(mapURL) {\n  try {\n    const content = fs.readFileSync(fileURLToPath(mapURL)\x2C 'utf8');\n    const data = JSONParse(content);\n    return sourcesToAbsolute(mapURL\x2C data);\n  } catch (err) {\n    debug(err.stack);\n    return null;\n  }\n}\n\n// data:[<mediatype>][;base64]\x2C<data> see:\n// https://tools.ietf.org/html/rfc2397#section-2\nfunction sourceMapFromDataUrl(sourceURL\x2C url) {\n  const { 0: format\x2C 1: data } = StringPrototypeSplit(url\x2C '\x2C');\n  const splitFormat = StringPrototypeSplit(format\x2C ';');\n  const contentType = splitFormat[0];\n  const base64 = splitFormat[splitFormat.length - 1] === 'base64';\n  if (contentType === 'application/json') {\n    const decodedData = base64 ?\n      Buffer.from(data\x2C 'base64').toString('utf8') : data;\n    try {\n      const parsedData = JSONParse(decodedData);\n      return sourcesToAbsolute(sourceURL\x2C parsedData);\n    } catch (err) {\n      debug(err.stack);\n      return null;\n    }\n  } else {\n    debug(`unknown content-type ${contentType}`);\n    return null;\n  }\n}\n\n// If the sources are not absolute URLs after prepending of the "sourceRoot"\x2C\n// the sources are resolved relative to the SourceMap (like resolving script\n// src in a html document).\nfunction sourcesToAbsolute(baseURL\x2C data) {\n  data.sources = data.sources.map((source) => {\n    source = (data.sourceRoot || '') + source;\n    return new URL(source\x2C baseURL).href;\n  });\n  // The sources array is now resolved to absolute URLs\x2C sourceRoot should\n  // be updated to noop.\n  data.sourceRoot = '';\n  return data;\n}\n\n// WARNING: The `sourceMapCacheToObject` and `appendCJSCache` run during\n// shutdown. In particular\x2C they also run when Workers are terminated\x2C making\n// it important that they do not call out to any user-provided code\x2C including\n// built-in prototypes that might have been tampered with.\n\n// Get serialized representation of source-map cache\x2C this is used\n// to persist a cache of source-maps to disk when NODE_V8_COVERAGE is enabled.\nfunction sourceMapCacheToObject() {\n  const obj = ObjectCreate(null);\n\n  for (const { 0: k\x2C 1: v } of esmSourceMapCache) {\n    obj[k] = v;\n  }\n\n  appendCJSCache(obj);\n\n  if (ObjectKeys(obj).length === 0) {\n    return undefined;\n  }\n  return obj;\n}\n\nfunction appendCJSCache(obj) {\n  for (const value of cjsSourceMapCache) {\n    obj[ObjectGetValueSafe(value\x2C 'filename')] = {\n      lineLengths: ObjectGetValueSafe(value\x2C 'lineLengths')\x2C\n      data: ObjectGetValueSafe(value\x2C 'data')\x2C\n      url: ObjectGetValueSafe(value\x2C 'url')\n    };\n  }\n}\n\nfunction findSourceMap(sourceURL) {\n  if (!RegExpPrototypeTest(/^\\w+:\\/\\//\x2C sourceURL)) {\n    sourceURL = pathToFileURL(sourceURL).href;\n  }\n  if (!SourceMap) {\n    SourceMap = require('internal/source_map/source_map').SourceMap;\n  }\n  let sourceMap = esmSourceMapCache.get(sourceURL);\n  if (sourceMap === undefined) {\n    for (const value of cjsSourceMapCache) {\n      const filename = ObjectGetValueSafe(value\x2C 'filename');\n      if (sourceURL === filename) {\n        sourceMap = {\n          data: ObjectGetValueSafe(value\x2C 'data')\n        };\n      }\n    }\n  }\n  if (sourceMap && sourceMap.data) {\n    return new SourceMap(sourceMap.data);\n  }\n  return undefined;\n}\n\nmodule.exports = {\n  findSourceMap\x2C\n  getSourceMapsEnabled\x2C\n  setSourceMapsEnabled\x2C\n  maybeCacheSourceMap\x2C\n  sourceMapCacheToObject\x2C\n};\n
code-source-info,0x24b326958bfe,97,0,7654,C0O0C4O7654,,
code-creation,Function,10,57890,0x24b326959276,435, node:internal/source_map/source_map_cache:1:1,0x24b326958b78,~
code-source-info,0x24b326959276,97,0,7654,C0O0C152O25C158O46C164O59C170O75C176O89C182O123C188O156C194O179C199O190C205O214C211O526C217O526C222O515C228O557C234O557C239O590C252O591C258O557C260O653C266O653C270O653C272O695C278O695C283O676C289O752C295O752C300O732C305O832C311O832C316O806C322O901C328O901C333O881C339O1137C341O1137C346O1137C348O1264C350O1264C355O1264C357O1325C363O1325C368O1287C374O1302C380O1317C386O1354C387O1354C389O1370C390O1370C392O7518C399O7539C405O7556C411O7580C417O7604C423O7627C429O7533C434O7653,,
tick,0x10c7b638e,58055,0,0x0,2,0x10c825337,0x24b326959372,0x24b357dbe2b5,0x24b357dbd585,0x24b3269581fc,0x24b3269439e0,0x24b357dbd30d
code-creation,LazyCompile,10,58116,0x24b32695a05e,82,debuglog node:internal/util/debuglog:71:18,0x24b3bc5bb210,~
code-source-info,0x24b32695a05e,40,2232,3279,C0O2232C28O2357C32O2357C34O2789C35O2789C37O2811C41O2811C43O2899C48O3128C58O3149C63O3174C74O3128C79O3263C81O3277,,
code-creation,Eval,10,58324,0x24b32695a5de,5, node:internal/util/iterable_weak_map:1:1,0x24b32695a390,~
script-source,98,node:internal/util/iterable_weak_map,'use strict';\n\nconst {\n  ObjectFreeze\x2C\n  SafeFinalizationRegistry\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SymbolIterator\x2C\n} = primordials;\n\n// This class is modified from the example code in the WeakRefs specification:\n// https://github.com/tc39/proposal-weakrefs\n// Licensed under ECMA's MIT-style license\x2C see:\n// https://github.com/tc39/ecma262/blob/HEAD/LICENSE.md\nclass IterableWeakMap {\n  #weakMap = new SafeWeakMap();\n  #refSet = new SafeSet();\n  #finalizationGroup = new SafeFinalizationRegistry(cleanup);\n\n  set(key\x2C value) {\n    const entry = this.#weakMap.get(key);\n    if (entry) {\n      // If there's already an entry for the object represented by "key"\x2C\n      // the value can be updated without creating a new WeakRef:\n      this.#weakMap.set(key\x2C { value\x2C ref: entry.ref });\n    } else {\n      const ref = new SafeWeakRef(key);\n      this.#weakMap.set(key\x2C { value\x2C ref });\n      this.#refSet.add(ref);\n      this.#finalizationGroup.register(key\x2C {\n        set: this.#refSet\x2C\n        ref\n      }\x2C ref);\n    }\n  }\n\n  get(key) {\n    return this.#weakMap.get(key)?.value;\n  }\n\n  has(key) {\n    return this.#weakMap.has(key);\n  }\n\n  delete(key) {\n    const entry = this.#weakMap.get(key);\n    if (!entry) {\n      return false;\n    }\n    this.#weakMap.delete(key);\n    this.#refSet.delete(entry.ref);\n    this.#finalizationGroup.unregister(entry.ref);\n    return true;\n  }\n\n  [SymbolIterator]() {\n    const iterator = this.#refSet[SymbolIterator]();\n\n    const next = () => {\n      const result = iterator.next();\n      if (result.done) return result;\n      const key = result.value.deref();\n      if (key == null) return next();\n      const { value } = this.#weakMap.get(key);\n      return { done: false\x2C value };\n    };\n\n    return {\n      [SymbolIterator]() { return this; }\x2C\n      next\x2C\n    };\n  }\n}\n\nfunction cleanup({ set\x2C ref }) {\n  set.delete(ref);\n}\n\nObjectFreeze(IterableWeakMap.prototype);\n\nmodule.exports = {\n  IterableWeakMap\x2C\n};\n
code-source-info,0x24b32695a5de,98,0,1958,C0O0C4O1958,,
code-creation,Function,10,58484,0x24b32695ad3e,196, node:internal/util/iterable_weak_map:1:1,0x24b32695a558,~
code-source-info,0x24b32695ad3e,98,0,1958,C0O0C26O25C31O41C37O69C43O80C49O95C55O110C134O1392C168O1904C173O1875C177O1917C184O1938C190O1932C195O1957,,
code-creation,Function,10,58508,0x24b32695aebe,75,<instance_members_initializer> node:internal/util/iterable_weak_map:17:3,0x24b32695a868,~
code-source-info,0x24b32695aebe,98,399,516,C3O410C10O410C27O441C34O441C48O479C62O479C74O516,,
code-creation,Eval,10,58816,0x24b32695bb96,5, node:internal/modules/cjs/helpers:1:1,0x24b32695b8e0,~
script-source,99,node:internal/modules/cjs/helpers,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeSome\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst {\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_UNKNOWN_BUILTIN_MODULE\n} = require('internal/errors').codes;\nconst { NativeModule } = require('internal/bootstrap/loaders');\n\nconst { validateString } = require('internal/validators');\nconst path = require('path');\nconst { pathToFileURL\x2C fileURLToPath\x2C URL } = require('internal/url');\n\nconst { getOptionValue } = require('internal/options');\nconst userConditions = getOptionValue('--conditions');\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\n\nconst noAddons = getOptionValue('--no-addons');\nconst addonConditions = noAddons ? [] : ['node-addons'];\n\n// TODO: Use this set when resolving pkg#exports conditions in loader.js.\nconst cjsConditions = new SafeSet([\n  'require'\x2C\n  'node'\x2C\n  ...addonConditions\x2C\n  ...userConditions\x2C\n]);\n\nfunction loadNativeModule(filename\x2C request) {\n  const mod = NativeModule.map.get(filename);\n  if (mod?.canBeRequiredByUsers) {\n    debug('load native module %s'\x2C request);\n    // compileForPublicLoader() throws if mod.canBeRequiredByUsers is false:\n    mod.compileForPublicLoader();\n    return mod;\n  }\n}\n\n// Invoke with makeRequireFunction(module) where |module| is the Module object\n// to use as the context for the require() function.\n// Use redirects to set up a mapping from a policy and restrict dependencies\nconst urlToFileCache = new SafeMap();\nfunction makeRequireFunction(mod\x2C redirects) {\n  const Module = mod.constructor;\n\n  let require;\n  if (redirects) {\n    const id = mod.filename || mod.id;\n    const conditions = cjsConditions;\n    const { resolve\x2C reaction } = redirects;\n    require = function require(specifier) {\n      let missing = true;\n      const destination = resolve(specifier\x2C conditions);\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        if (destination.protocol === 'node:') {\n          const specifier = destination.pathname;\n          const mod = loadNativeModule(specifier\x2C href);\n          if (mod && mod.canBeRequiredByUsers) {\n            return mod.exports;\n          }\n          throw new ERR_UNKNOWN_BUILTIN_MODULE(specifier);\n        } else if (destination.protocol === 'file:') {\n          let filepath;\n          if (urlToFileCache.has(href)) {\n            filepath = urlToFileCache.get(href);\n          } else {\n            filepath = fileURLToPath(destination);\n            urlToFileCache.set(href\x2C filepath);\n          }\n          return mod.require(filepath);\n        }\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          id\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C ')\n        ));\n      }\n      return mod.require(specifier);\n    };\n  } else {\n    require = function require(path) {\n      return mod.require(path);\n    };\n  }\n\n  function resolve(request\x2C options) {\n    validateString(request\x2C 'request');\n    return Module._resolveFilename(request\x2C mod\x2C false\x2C options);\n  }\n\n  require.resolve = resolve;\n\n  function paths(request) {\n    validateString(request\x2C 'request');\n    return Module._resolveLookupPaths(request\x2C mod);\n  }\n\n  resolve.paths = paths;\n\n  require.main = process.mainModule;\n\n  // Enable support to add extra extension types.\n  require.extensions = Module._extensions;\n\n  require.cache = Module._cache;\n\n  return require;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n * because the buffer-to-string conversion in `fs.readFileSync()`\n * translates it to FEFF\x2C the UTF-16 BOM.\n */\nfunction stripBOM(content) {\n  if (StringPrototypeCharCodeAt(content) === 0xFEFF) {\n    content = StringPrototypeSlice(content\x2C 1);\n  }\n  return content;\n}\n\nfunction addBuiltinLibsToObject(object\x2C dummyModuleName) {\n  // Make built-in modules available directly (loaded lazily).\n  const Module = require('internal/modules/cjs/loader').Module;\n  const { builtinModules } = Module;\n\n  // To require built-in modules in user-land and ignore modules whose\n  // `canBeRequiredByUsers` is false. So we create a dummy module object and not\n  // use `require()` directly.\n  const dummyModule = new Module(dummyModuleName);\n\n  ArrayPrototypeForEach(builtinModules\x2C (name) => {\n    // Neither add underscored modules\x2C nor ones that contain slashes (e.g.\x2C\n    // 'fs/promises') or ones that are already defined.\n    if (StringPrototypeStartsWith(name\x2C '_') ||\n        StringPrototypeIncludes(name\x2C '/') ||\n        ObjectPrototypeHasOwnProperty(object\x2C name)) {\n      return;\n    }\n    // Goals of this mechanism are:\n    // - Lazy loading of built-in modules\n    // - Having all built-in modules available as non-enumerable properties\n    // - Allowing the user to re-assign these variables as if there were no\n    //   pre-existing globals with the same name.\n\n    const setReal = (val) => {\n      // Deleting the property before re-assigning it disables the\n      // getter/setter mechanism.\n      delete object[name];\n      object[name] = val;\n    };\n\n    ObjectDefineProperty(object\x2C name\x2C {\n      get: () => {\n        const lib = dummyModule.require(name);\n\n        // Disable the current getter/setter and set up a new\n        // non-enumerable property.\n        delete object[name];\n        ObjectDefineProperty(object\x2C name\x2C {\n          get: () => lib\x2C\n          set: setReal\x2C\n          configurable: true\x2C\n          enumerable: false\n        });\n\n        return lib;\n      }\x2C\n      set: setReal\x2C\n      configurable: true\x2C\n      enumerable: false\n    });\n  });\n}\n\nfunction normalizeReferrerURL(referrer) {\n  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\n    return pathToFileURL(referrer).href;\n  }\n  return new URL(referrer).href;\n}\n\n// For error messages only - used to check if ESM syntax is in use.\nfunction hasEsmSyntax(code) {\n  debug('Checking for ESM syntax');\n  const parser = require('internal/deps/acorn/acorn/dist/acorn').Parser;\n  let root;\n  try {\n    root = parser.parse(code\x2C { sourceType: 'module'\x2C ecmaVersion: 'latest' });\n  } catch {\n    return false;\n  }\n\n  return ArrayPrototypeSome(root.body\x2C (stmt) =>\n    stmt.type === 'ExportDefaultDeclaration' ||\n    stmt.type === 'ExportNamedDeclaration' ||\n    stmt.type === 'ImportDeclaration' ||\n    stmt.type === 'ExportAllDeclaration');\n}\n\nmodule.exports = {\n  addBuiltinLibsToObject\x2C\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n};\n
code-source-info,0x24b32695bb96,99,0,6746,C0O0C4O6746,,
code-creation,Function,10,59293,0x24b32695c116,536, node:internal/modules/cjs/helpers:1:1,0x24b32695bb10,~
code-source-info,0x24b32695c116,99,0,6746,C0O0C104O25C110O50C116O72C122O94C128O118C134O151C139O162C144O173C150O202C156O229C162O253C168O373C174O373C179O399C184O307C190O342C196O432C202O432C207O415C213O499C219O499C224O480C230O544C236O544C240O544C242O607C248O607C253O569C259O584C265O599C271O660C277O660C282O641C287O712C290O712C295O757C301O757C306O790C319O791C325O757C327O856C330O856C335O911C346O1041C353O1083C354O1083C410O1105C465O1041C470O1041C472O1665C474O1665C479O1665C481O6586C488O6607C494O6633C500O6650C506O6666C512O6686C518O6709C524O6733C530O6601C535O6745,,
tick,0x7fff20385398,59391,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b3269593ad,0x24b357dbe2b5,0x24b357dbd585,0x24b3269581fc,0x24b3269439e0,0x24b357dbd30d
code-creation,LazyCompile,10,59521,0x24b32695cd56,27,SafeSet node:internal/per_context/primordials:364:16,0x24b3c0589fd0,~
script-source,6,node:internal/per_context/primordials,'use strict';\n\n/* eslint-disable node-core/prefer-primordials */\n\n// This file subclasses and stores the JS builtins that come from the VM\n// so that Node.js's builtin modules do not need to later look these up from\n// the global proxy\x2C which can be mutated by users.\n\n// Use of primordials have sometimes a dramatic impact on performance\x2C please\n// benchmark all changes made in performance-sensitive areas of the codebase.\n// See: https://github.com/nodejs/node/pull/38248\n\nconst {\n  defineProperty: ReflectDefineProperty\x2C\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor\x2C\n  ownKeys: ReflectOwnKeys\x2C\n} = Reflect;\n\n// `uncurryThis` is equivalent to `func => Function.prototype.call.bind(func)`.\n// It is using `bind.bind(call)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.call` after it may have been mutated by users.\nconst { apply\x2C bind\x2C call } = Function.prototype;\nconst uncurryThis = bind.bind(call);\nprimordials.uncurryThis = uncurryThis;\n\n// `applyBind` is equivalent to `func => Function.prototype.apply.bind(func)`.\n// It is using `bind.bind(apply)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.apply` after it may have been mutated by users.\nconst applyBind = bind.bind(apply);\nprimordials.applyBind = applyBind;\n\n// Methods that accept a variable number of arguments\x2C and thus it's useful to\n// also create `${prefix}${key}Apply`\x2C which uses `Function.prototype.apply`\x2C\n// instead of `Function.prototype.call`\x2C and thus doesn't require iterator\n// destructuring.\nconst varargsMethods = [\n  // 'ArrayPrototypeConcat' is omitted\x2C because it performs the spread\n  // on its own for arrays and array-likes with a truthy\n  // @@isConcatSpreadable symbol property.\n  'ArrayOf'\x2C\n  'ArrayPrototypePush'\x2C\n  'ArrayPrototypeUnshift'\x2C\n  // 'FunctionPrototypeCall' is omitted\x2C since there's 'ReflectApply'\n  // and 'FunctionPrototypeApply'.\n  'MathHypot'\x2C\n  'MathMax'\x2C\n  'MathMin'\x2C\n  'StringPrototypeConcat'\x2C\n  'TypedArrayOf'\x2C\n];\n\nfunction getNewKey(key) {\n  return typeof key === 'symbol' ?\n    `Symbol${key.description[7].toUpperCase()}${key.description.slice(8)}` :\n    `${key[0].toUpperCase()}${key.slice(1)}`;\n}\n\nfunction copyAccessor(dest\x2C prefix\x2C key\x2C { enumerable\x2C get\x2C set }) {\n  ReflectDefineProperty(dest\x2C `${prefix}Get${key}`\x2C {\n    value: uncurryThis(get)\x2C\n    enumerable\n  });\n  if (set !== undefined) {\n    ReflectDefineProperty(dest\x2C `${prefix}Set${key}`\x2C {\n      value: uncurryThis(set)\x2C\n      enumerable\n    });\n  }\n}\n\nfunction copyPropsRenamed(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          // `src` is bound as the `this` so that the static `this` points\n          // to the object it was defined on\x2C\n          // e.g.: `ArrayOfApply` gets a `this` of `Array`:\n          value: applyBind(desc.value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPropsRenamedBound(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = value.bind(src);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          value: applyBind(value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPrototype(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = uncurryThis(value);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          value: applyBind(value)\x2C\n        });\n      }\n    }\n  }\n}\n\n// Create copies of configurable value properties of the global object\n[\n  'Proxy'\x2C\n  'globalThis'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  primordials[name] = globalThis[name];\n});\n\n// Create copies of URI handling functions\n[\n  decodeURI\x2C\n  decodeURIComponent\x2C\n  encodeURI\x2C\n  encodeURIComponent\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of the namespace objects\n[\n  'JSON'\x2C\n  'Math'\x2C\n  'Proxy'\x2C\n  'Reflect'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  copyPropsRenamed(global[name]\x2C primordials\x2C name);\n});\n\n// Create copies of intrinsic objects\n[\n  'AggregateError'\x2C\n  'Array'\x2C\n  'ArrayBuffer'\x2C\n  'BigInt'\x2C\n  'BigInt64Array'\x2C\n  'BigUint64Array'\x2C\n  'Boolean'\x2C\n  'DataView'\x2C\n  'Date'\x2C\n  'Error'\x2C\n  'EvalError'\x2C\n  'FinalizationRegistry'\x2C\n  'Float32Array'\x2C\n  'Float64Array'\x2C\n  'Function'\x2C\n  'Int16Array'\x2C\n  'Int32Array'\x2C\n  'Int8Array'\x2C\n  'Map'\x2C\n  'Number'\x2C\n  'Object'\x2C\n  'RangeError'\x2C\n  'ReferenceError'\x2C\n  'RegExp'\x2C\n  'Set'\x2C\n  'String'\x2C\n  'Symbol'\x2C\n  'SyntaxError'\x2C\n  'TypeError'\x2C\n  'URIError'\x2C\n  'Uint16Array'\x2C\n  'Uint32Array'\x2C\n  'Uint8Array'\x2C\n  'Uint8ClampedArray'\x2C\n  'WeakMap'\x2C\n  'WeakRef'\x2C\n  'WeakSet'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = global[name];\n  primordials[name] = original;\n  copyPropsRenamed(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of intrinsic objects that require a valid `this` to call\n// static methods.\n// Refs: https://www.ecma-international.org/ecma-262/#sec-promise.all\n[\n  'Promise'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = global[name];\n  primordials[name] = original;\n  copyPropsRenamedBound(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of abstract intrinsic objects that are not directly exposed\n// on the global object.\n// Refs: https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object\n[\n  { name: 'TypedArray'\x2C original: Reflect.getPrototypeOf(Uint8Array) }\x2C\n  { name: 'ArrayIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(Array.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n  { name: 'StringIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(String.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n].forEach(({ name\x2C original }) => {\n  primordials[name] = original;\n  // The static %TypedArray% methods require a valid `this`\x2C but can't be bound\x2C\n  // as they need a subclass constructor as the receiver:\n  copyPrototype(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n/* eslint-enable node-core/prefer-primordials */\n\nconst {\n  ArrayPrototypeForEach\x2C\n  FinalizationRegistry\x2C\n  FunctionPrototypeCall\x2C\n  Map\x2C\n  ObjectFreeze\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  Set\x2C\n  SymbolIterator\x2C\n  WeakMap\x2C\n  WeakRef\x2C\n  WeakSet\x2C\n} = primordials;\n\n// Because these functions are used by `makeSafe`\x2C which is exposed\n// on the `primordials` object\x2C it's important to use const references\n// to the primordials that they use:\nconst createSafeIterator = (factory\x2C next) => {\n  class SafeIterator {\n    constructor(iterable) {\n      this._iterator = factory(iterable);\n    }\n    next() {\n      return next(this._iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype\x2C null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\n\nprimordials.SafeArrayIterator = createSafeIterator(\n  primordials.ArrayPrototypeSymbolIterator\x2C\n  primordials.ArrayIteratorPrototypeNext\n);\nprimordials.SafeStringIterator = createSafeIterator(\n  primordials.StringPrototypeSymbolIterator\x2C\n  primordials.StringIteratorPrototypeNext\n);\n\nconst copyProps = (src\x2C dest) => {\n  ArrayPrototypeForEach(ReflectOwnKeys(src)\x2C (key) => {\n    if (!ReflectGetOwnPropertyDescriptor(dest\x2C key)) {\n      ReflectDefineProperty(\n        dest\x2C\n        key\x2C\n        ReflectGetOwnPropertyDescriptor(src\x2C key));\n    }\n  });\n};\n\n/**\n * @type {typeof primordials.makeSafe}\n */\nconst makeSafe = (unsafe\x2C safe) => {\n  if (SymbolIterator in unsafe.prototype) {\n    const dummy = new unsafe();\n    let next; // We can reuse the same `next` method.\n\n    ArrayPrototypeForEach(ReflectOwnKeys(unsafe.prototype)\x2C (key) => {\n      if (!ReflectGetOwnPropertyDescriptor(safe.prototype\x2C key)) {\n        const desc = ReflectGetOwnPropertyDescriptor(unsafe.prototype\x2C key);\n        if (\n          typeof desc.value === 'function' &&\n          desc.value.length === 0 &&\n          SymbolIterator in (FunctionPrototypeCall(desc.value\x2C dummy) ?? {})\n        ) {\n          const createIterator = uncurryThis(desc.value);\n          next ??= uncurryThis(createIterator(dummy).next);\n          const SafeIterator = createSafeIterator(createIterator\x2C next);\n          desc.value = function() {\n            return new SafeIterator(this);\n          };\n        }\n        ReflectDefineProperty(safe.prototype\x2C key\x2C desc);\n      }\n    });\n  } else {\n    copyProps(unsafe.prototype\x2C safe.prototype);\n  }\n  copyProps(unsafe\x2C safe);\n\n  ObjectSetPrototypeOf(safe.prototype\x2C null);\n  ObjectFreeze(safe.prototype);\n  ObjectFreeze(safe);\n  return safe;\n};\nprimordials.makeSafe = makeSafe;\n\n// Subclass the constructors because we need to use their prototype\n// methods later.\n// Defining the `constructor` is necessary here to avoid the default\n// constructor which uses the user-mutable `%ArrayIteratorPrototype%.next`.\nprimordials.SafeMap = makeSafe(\n  Map\x2C\n  class SafeMap extends Map {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\nprimordials.SafeWeakMap = makeSafe(\n  WeakMap\x2C\n  class SafeWeakMap extends WeakMap {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\n\nprimordials.SafeSet = makeSafe(\n  Set\x2C\n  class SafeSet extends Set {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\nprimordials.SafeWeakSet = makeSafe(\n  WeakSet\x2C\n  class SafeWeakSet extends WeakSet {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\n\nprimordials.SafeFinalizationRegistry = makeSafe(\n  FinalizationRegistry\x2C\n  class SafeFinalizationRegistry extends FinalizationRegistry {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(cleanupCallback) { super(cleanupCallback); }\n  }\n);\nprimordials.SafeWeakRef = makeSafe(\n  WeakRef\x2C\n  class SafeWeakRef extends WeakRef {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(target) { super(target); }\n  }\n);\n\nconst SafePromise = makeSafe(\n  Promise\x2C\n  class SafePromise extends Promise {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(executor) { super(executor); }\n  }\n);\n\nprimordials.PromisePrototypeCatch = (thisPromise\x2C onRejected) =>\n  PromisePrototypeThen(thisPromise\x2C undefined\x2C onRejected);\n\n/**\n * Attaches a callback that is invoked when the Promise is settled (fulfilled or\n * rejected). The resolved value cannot be modified from the callback.\n * Prefer using async functions when possible.\n * @param {Promise<any>} thisPromise\n * @param {() => void) | undefined | null} onFinally The callback to execute\n *        when the Promise is settled (fulfilled or rejected).\n * @returns A Promise for the completion of the callback.\n */\nprimordials.SafePromisePrototypeFinally = (thisPromise\x2C onFinally) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    new SafePromise((a\x2C b) => PromisePrototypeThen(thisPromise\x2C a\x2C b))\n      .finally(onFinally)\n      .then(a\x2C b)\n  );\n\nprimordials.AsyncIteratorPrototype =\n  primordials.ReflectGetPrototypeOf(\n    primordials.ReflectGetPrototypeOf(\n      async function* () {}).prototype);\n\nObjectSetPrototypeOf(primordials\x2C null);\nObjectFreeze(primordials);\n
code-source-info,0x24b32695cd56,6,10527,10544,C3O10533C7O10539C11O10533C26O10543,,
code-creation,LazyCompile,10,60395,0x24b32695db96,27,SafeMap node:internal/per_context/primordials:351:16,0x24b3c0589e48,~
code-source-info,0x24b32695db96,6,10200,10217,C3O10206C7O10212C11O10206C26O10216,,
tick,0x7fff203572be,60455,0,0x0,3,0x10c825337,0x24b32695c2f0,0x24b357dbe2b5,0x24b357dbd585,0x24b3269593ad,0x24b357dbe2b5,0x24b357dbd585,0x24b3269581fc,0x24b3269439e0,0x24b357dbd30d
code-creation,LazyCompile,10,60491,0x24b32695dd0e,16,IterableWeakMap node:internal/util/iterable_weak_map:16:1,0x24b32695a660,~
code-source-info,0x24b32695dd0e,98,373,373,C0O373C15O373,,
code-creation,LazyCompile,10,60550,0x24b32695e096,27,SafeWeakMap node:internal/per_context/primordials:357:16,0x24b3c0589f08,~
code-source-info,0x24b32695e096,6,10371,10388,C3O10377C7O10383C11O10377C26O10387,,
code-creation,LazyCompile,10,60589,0x24b32695e19e,27,SafeFinalizationRegistry node:internal/per_context/primordials:378:16,0x24b3c058a158,~
code-source-info,0x24b32695e19e,6,10977,11022,C3O10997C7O11003C11O10997C26O11021,,
code-creation,LazyCompile,10,60740,0x24b32695e986,492,initializeDeprecations node:internal/bootstrap/pre_execution:250:32,0x24b357dbf600,~
code-source-info,0x24b32695e986,93,7934,10433,C0O7934C11O7963C19O7963C24O7949C29O8018C39O8018C44O8209C52O8209C57O8250C65O8250C70O8303C99O8295C127O8295C130O8621C141O8641C145O8683C156O8757C167O8847C178O8802C187O8668C196O8906C199O8639C203O8284C269O9183C277O9183C282O9162C287O9212C289O9240C304O9261C311O9379C315O9240C320O9411C324O9441C334O9477C344O9554C351O9459C356O9457C360O9640C370O9682C381O9664C386O9662C390O10021C394O10021C396O10032C407O10053C418O10082C426O10124C434O10032C439O10237C445O10237C447O10247C458O10268C469O10296C477O10337C485O10247C491O10432,,
code-creation,LazyCompile,10,60868,0x24b32695efb6,53,initializeWASI node:internal/bootstrap/pre_execution:414:24,0x24b357dbf780,~
code-source-info,0x24b32695efb6,93,13122,13328,C0O13154C6O13154C11O13137C16O13220C21O13224C29O13224C35O13239C37O13270C43O13270C47O13264C52O13327,,
code-creation,LazyCompile,10,60924,0x24b32695f1b6,66,initializeCJSLoader node:internal/bootstrap/pre_execution:421:29,0x24b357dbf7d0,~
code-source-info,0x24b32695f1b6,93,13358,13673,C0O13383C6O13383C11O13425C16O13430C20O13450C26O13488C31O13495C36O13495C40O13591C51O13612C56O13648C60O13606C65O13672,,
tick,0x10c48e826,61770,1,0x10c345dc2,2,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Eval,10,61969,0x24b326961176,5, node:internal/modules/cjs/loader:1:1,0x24b326960890,~
script-source,100,node:internal/modules/cjs/loader,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeConcat\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  ArrayPrototypeUnshiftApply\x2C\n  Boolean\x2C\n  Error\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototype\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Proxy\x2C\n  ReflectApply\x2C\n  ReflectSet\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  String\x2C\n  StringPrototypeCharAt\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\n// Map used to store CJS parsing data.\nconst cjsParseCache = new SafeWeakMap();\n\n// Set first due to cycle with ESM loader functions.\nmodule.exports = {\n  wrapSafe\x2C Module\x2C toRealPath\x2C readPackageScope\x2C cjsParseCache\x2C\n  get hasLoadedAnyUserCJSModule() { return hasLoadedAnyUserCJSModule; }\n};\n\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  maybeCacheSourceMap\x2C\n} = require('internal/source_map/source_map_cache');\nconst { pathToFileURL\x2C fileURLToPath\x2C isURLInstance } = require('internal/url');\nconst { deprecate } = require('internal/util');\nconst vm = require('vm');\nconst assert = require('internal/assert');\nconst fs = require('fs');\nconst internalFS = require('internal/fs/utils');\nconst path = require('path');\nconst { sep } = path;\nconst { internalModuleStat } = internalBinding('fs');\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst { safeGetenv } = internalBinding('credentials');\nconst {\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst { getOptionValue } = require('internal/options');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\n\n// Whether any user-provided CJS modules had been loaded (executed).\n// Used for internal assertions.\nlet hasLoadedAnyUserCJSModule = false;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_MODULE_SPECIFIER\x2C\n    ERR_REQUIRE_ESM\x2C\n    ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  }\x2C\n  setArrowMessage\x2C\n} = require('internal/errors');\nconst { validateString } = require('internal/validators');\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\n} = require('internal/constants');\n\nconst {\n  isProxy\n} = require('internal/util/types');\n\nconst asyncESM = require('internal/process/esm_loader');\nconst { enrichCJSError } = require('internal/modules/esm/translators');\nconst { kEvaluated } = internalBinding('module_wrap');\nconst {\n  encodedSepRegEx\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\n} = require('internal/modules/esm/resolve');\n\nconst isWindows = process.platform === 'win32';\n\nconst relativeResolveCache = ObjectCreate(null);\n\nlet requireDepth = 0;\nlet statCache = null;\nlet isPreloading = false;\n\nfunction stat(filename) {\n  filename = path.toNamespacedPath(filename);\n  if (statCache !== null) {\n    const result = statCache.get(filename);\n    if (result !== undefined) return result;\n  }\n  const result = internalModuleStat(filename);\n  if (statCache !== null && result >= 0) {\n    // Only set cache when `internalModuleStat(filename)` succeeds.\n    statCache.set(filename\x2C result);\n  }\n  return result;\n}\n\nfunction updateChildren(parent\x2C child\x2C scan) {\n  const children = parent?.children;\n  if (children && !(scan && ArrayPrototypeIncludes(children\x2C child)))\n    ArrayPrototypePush(children\x2C child);\n}\n\nconst moduleParentCache = new SafeWeakMap();\nfunction Module(id = ''\x2C parent) {\n  this.id = id;\n  this.path = path.dirname(id);\n  this.exports = {};\n  moduleParentCache.set(this\x2C parent);\n  updateChildren(parent\x2C this\x2C false);\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\n\nconst builtinModules = [];\nfor (const { 0: id\x2C 1: mod } of NativeModule.map) {\n  if (mod.canBeRequiredByUsers) {\n    ArrayPrototypePush(builtinModules\x2C id);\n  }\n}\n\nObjectFreeze(builtinModules);\nModule.builtinModules = builtinModules;\n\nModule._cache = ObjectCreate(null);\nModule._pathCache = ObjectCreate(null);\nModule._extensions = ObjectCreate(null);\nlet modulePaths = [];\nModule.globalPaths = [];\n\nlet patched = false;\n\n// eslint-disable-next-line func-style\nlet wrap = function(script) {\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\n\nconst wrapper = [\n  '(function (exports\x2C require\x2C module\x2C __filename\x2C __dirname) { '\x2C\n  '\\n});'\x2C\n];\n\nlet wrapperProxy = new Proxy(wrapper\x2C {\n  set(target\x2C property\x2C value\x2C receiver) {\n    patched = true;\n    return ReflectSet(target\x2C property\x2C value\x2C receiver);\n  }\x2C\n\n  defineProperty(target\x2C property\x2C descriptor) {\n    patched = true;\n    return ObjectDefineProperty(target\x2C property\x2C descriptor);\n  }\n});\n\nObjectDefineProperty(Module\x2C 'wrap'\x2C {\n  get() {\n    return wrap;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrap = value;\n  }\n});\n\nObjectDefineProperty(Module\x2C 'wrapper'\x2C {\n  get() {\n    return wrapperProxy;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrapperProxy = value;\n  }\n});\n\nconst isPreloadingDesc = { get() { return isPreloading; } };\nObjectDefineProperty(Module.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\nObjectDefineProperty(NativeModule.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\n\nfunction getModuleParent() {\n  return moduleParentCache.get(this);\n}\n\nfunction setModuleParent(value) {\n  moduleParentCache.set(this\x2C value);\n}\n\nObjectDefineProperty(Module.prototype\x2C 'parent'\x2C {\n  get: pendingDeprecation ? deprecate(\n    getModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\n  ) : getModuleParent\x2C\n  set: pendingDeprecation ? deprecate(\n    setModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\n  ) : setModuleParent\x2C\n});\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\nModule._debug = deprecate(debug\x2C 'Module._debug is deprecated.'\x2C 'DEP0077');\n\n// Given a module name\x2C and a list of paths to test\x2C returns the first\n// matching file in the following precedence.\n//\n// require("a.<ext>")\n//   -> a.<ext>\n//\n// require("a")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\nconst packageJsonCache = new SafeMap();\n\nfunction readPackage(requestPath) {\n  const jsonPath = path.resolve(requestPath\x2C 'package.json');\n\n  const existing = packageJsonCache.get(jsonPath);\n  if (existing !== undefined) return existing;\n\n  const result = packageJsonReader.read(jsonPath);\n  const json = result.containsKeys === false ? '{}' : result.string;\n  if (json === undefined) {\n    packageJsonCache.set(jsonPath\x2C false);\n    return false;\n  }\n\n  try {\n    const parsed = JSONParse(json);\n    const filtered = {\n      name: parsed.name\x2C\n      main: parsed.main\x2C\n      exports: parsed.exports\x2C\n      imports: parsed.imports\x2C\n      type: parsed.type\n    };\n    packageJsonCache.set(jsonPath\x2C filtered);\n    return filtered;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n    throw e;\n  }\n}\n\nfunction readPackageScope(checkPath) {\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath\x2C sep);\n  let separatorIndex;\n  do {\n    separatorIndex = StringPrototypeLastIndexOf(checkPath\x2C sep);\n    checkPath = StringPrototypeSlice(checkPath\x2C 0\x2C separatorIndex);\n    if (StringPrototypeEndsWith(checkPath\x2C sep + 'node_modules'))\n      return false;\n    const pjson = readPackage(checkPath + sep);\n    if (pjson) return {\n      data: pjson\x2C\n      path: checkPath\x2C\n    };\n  } while (separatorIndex > rootSeparatorIndex);\n  return false;\n}\n\nfunction tryPackage(requestPath\x2C exts\x2C isMain\x2C originalPath) {\n  const pkg = readPackage(requestPath)?.main;\n\n  if (!pkg) {\n    return tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n  }\n\n  const filename = path.resolve(requestPath\x2C pkg);\n  let actual = tryFile(filename\x2C isMain) ||\n    tryExtensions(filename\x2C exts\x2C isMain) ||\n    tryExtensions(path.resolve(filename\x2C 'index')\x2C exts\x2C isMain);\n  if (actual === false) {\n    actual = tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n    if (!actual) {\n      // eslint-disable-next-line no-restricted-syntax\n      const err = new Error(\n        `Cannot find module '${filename}'. ` +\n        'Please verify that the package.json has a valid "main" entry'\n      );\n      err.code = 'MODULE_NOT_FOUND';\n      err.path = path.resolve(requestPath\x2C 'package.json');\n      err.requestPath = originalPath;\n      // TODO(BridgeAR): Add the requireStack as well.\n      throw err;\n    } else {\n      const jsonPath = path.resolve(requestPath\x2C 'package.json');\n      process.emitWarning(\n        `Invalid 'main' field in '${jsonPath}' of '${pkg}'. ` +\n          'Please either fix that or report it to the module author'\x2C\n        'DeprecationWarning'\x2C\n        'DEP0128'\n      );\n    }\n  }\n  return actual;\n}\n\n// In order to minimize unnecessary lstat() calls\x2C\n// this cache is a list of known-real paths.\n// Set to an empty Map to reset.\nconst realpathCache = new SafeMap();\n\n// Check if the file exists and is not a directory\n// if using --preserve-symlinks and isMain is false\x2C\n// keep symlinks intact\x2C otherwise resolve to the\n// absolute realpath.\nfunction tryFile(requestPath\x2C isMain) {\n  const rc = stat(requestPath);\n  if (rc !== 0) return;\n  if (preserveSymlinks && !isMain) {\n    return path.resolve(requestPath);\n  }\n  return toRealPath(requestPath);\n}\n\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath\x2C {\n    [internalFS.realpathCacheKey]: realpathCache\n  });\n}\n\n// Given a path\x2C check if the file exists with any of the set extensions\nfunction tryExtensions(p\x2C exts\x2C isMain) {\n  for (let i = 0; i < exts.length; i++) {\n    const filename = tryFile(p + exts[i]\x2C isMain);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\n// Find the longest (possibly multi-dot) extension registered in\n// Module._extensions\nfunction findLongestRegisteredExtension(filename) {\n  const name = path.basename(filename);\n  let currentExtension;\n  let index;\n  let startIndex = 0;\n  while ((index = StringPrototypeIndexOf(name\x2C '.'\x2C startIndex)) !== -1) {\n    startIndex = index + 1;\n    if (index === 0) continue; // Skip dotfiles like .gitignore\n    currentExtension = StringPrototypeSlice(name\x2C index);\n    if (Module._extensions[currentExtension]) return currentExtension;\n  }\n  return '.js';\n}\n\nfunction trySelfParentPath(parent) {\n  if (!parent) return false;\n\n  if (parent.filename) {\n    return parent.filename;\n  } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {\n    try {\n      return process.cwd() + path.sep;\n    } catch {\n      return false;\n    }\n  }\n}\n\nfunction trySelf(parentPath\x2C request) {\n  if (!parentPath) return false;\n\n  const { data: pkg\x2C path: pkgPath } = readPackageScope(parentPath) || {};\n  if (!pkg || pkg.exports === undefined) return false;\n  if (typeof pkg.name !== 'string') return false;\n\n  let expansion;\n  if (request === pkg.name) {\n    expansion = '.';\n  } else if (StringPrototypeStartsWith(request\x2C `${pkg.name}/`)) {\n    expansion = '.' + StringPrototypeSlice(request\x2C pkg.name.length);\n  } else {\n    return false;\n  }\n\n  try {\n    return finalizeEsmResolution(packageExportsResolve(\n      pathToFileURL(pkgPath + '/package.json')\x2C expansion\x2C pkg\x2C\n      pathToFileURL(parentPath)\x2C cjsConditions)\x2C parentPath\x2C pkgPath);\n  } catch (e) {\n    if (e.code === 'ERR_MODULE_NOT_FOUND')\n      throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n    throw e;\n  }\n}\n\n// This only applies to requests of a specific form:\n// 1. name/.*\n// 2. @scope/name/.*\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\nfunction resolveExports(nmPath\x2C request) {\n  // The implementation's behavior is meant to mirror resolution in ESM.\n  const { 1: name\x2C 2: expansion = '' } =\n    StringPrototypeMatch(request\x2C EXPORTS_PATTERN) || [];\n  if (!name)\n    return;\n  const pkgPath = path.resolve(nmPath\x2C name);\n  const pkg = readPackage(pkgPath);\n  if (pkg?.exports != null) {\n    try {\n      return finalizeEsmResolution(packageExportsResolve(\n        pathToFileURL(pkgPath + '/package.json')\x2C '.' + expansion\x2C pkg\x2C null\x2C\n        cjsConditions)\x2C null\x2C pkgPath);\n    } catch (e) {\n      if (e.code === 'ERR_MODULE_NOT_FOUND')\n        throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n      throw e;\n    }\n  }\n}\n\nconst trailingSlashRegex = /(?:^|\\/)\\.?\\.$/;\nModule._findPath = function(request\x2C paths\x2C isMain) {\n  const absoluteRequest = path.isAbsolute(request);\n  if (absoluteRequest) {\n    paths = [''];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n\n  const cacheKey = request + '\\x00' + ArrayPrototypeJoin(paths\x2C '\\x00');\n  const entry = Module._pathCache[cacheKey];\n  if (entry)\n    return entry;\n\n  let exts;\n  let trailingSlash = request.length > 0 &&\n    StringPrototypeCharCodeAt(request\x2C request.length - 1) ===\n    CHAR_FORWARD_SLASH;\n  if (!trailingSlash) {\n    trailingSlash = RegExpPrototypeTest(trailingSlashRegex\x2C request);\n  }\n\n  // For each path\n  for (let i = 0; i < paths.length; i++) {\n    // Don't search further if path doesn't exist\n    const curPath = paths[i];\n    if (curPath && stat(curPath) < 1) continue;\n\n    if (!absoluteRequest) {\n      const exportsResolved = resolveExports(curPath\x2C request);\n      if (exportsResolved)\n        return exportsResolved;\n    }\n\n    const basePath = path.resolve(curPath\x2C request);\n    let filename;\n\n    const rc = stat(basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {  // File.\n        if (!isMain) {\n          if (preserveSymlinks) {\n            filename = path.resolve(basePath);\n          } else {\n            filename = toRealPath(basePath);\n          }\n        } else if (preserveSymlinksMain) {\n          // For the main module\x2C we use the preserveSymlinksMain flag instead\n          // mainly for backward compatibility\x2C as the preserveSymlinks flag\n          // historically has not applied to the main module.  Most likely this\n          // was intended to keep .bin/ binaries working\x2C as following those\n          // symlinks is usually required for the imports in the corresponding\n          // files to resolve; that said\x2C in some use cases following symlinks\n          // causes bigger problems which is why the preserveSymlinksMain option\n          // is needed.\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      }\n\n      if (!filename) {\n        // Try it with each of the extensions\n        if (exts === undefined)\n          exts = ObjectKeys(Module._extensions);\n        filename = tryExtensions(basePath\x2C exts\x2C isMain);\n      }\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      // try it with each of the extensions at "index"\n      if (exts === undefined)\n        exts = ObjectKeys(Module._extensions);\n      filename = tryPackage(basePath\x2C exts\x2C isMain\x2C request);\n    }\n\n    if (filename) {\n      Module._pathCache[cacheKey] = filename;\n      return filename;\n    }\n  }\n\n  return false;\n};\n\n// 'node_modules' character codes reversed\nconst nmChars = [ 115\x2C 101\x2C 108\x2C 117\x2C 100\x2C 111\x2C 109\x2C 95\x2C 101\x2C 100\x2C 111\x2C 110 ];\nconst nmLen = nmChars.length;\nif (isWindows) {\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n\n    // return root node_modules when path is 'D:\\\\'.\n    // path.resolve will make sure from.length >=3 in Windows.\n    if (StringPrototypeCharCodeAt(from\x2C from.length - 1) ===\n          CHAR_BACKWARD_SLASH &&\n        StringPrototypeCharCodeAt(from\x2C from.length - 2) === CHAR_COLON)\n      return [from + 'node_modules'];\n\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      // The path segment separator check ('\\' and '/') was used to get\n      // node_modules path for every path segment.\n      // Use colon as an extra condition since we can get node_modules\n      // path for drive root like 'C:\\node_modules' and don't need to\n      // parse drive name.\n      if (code === CHAR_BACKWARD_SLASH ||\n          code === CHAR_FORWARD_SLASH ||\n          code === CHAR_COLON) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '\\\\node_modules'\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    return paths;\n  };\n} else { // posix\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n    // Return early not only to avoid unnecessary work\x2C but to *avoid* returning\n    // an array of two items for a root: [ '//node_modules'\x2C '/node_modules' ]\n    if (from === '/')\n      return ['/node_modules'];\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '/node_modules'\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    // Append /node_modules to handle root paths.\n    ArrayPrototypePush(paths\x2C '/node_modules');\n\n    return paths;\n  };\n}\n\nModule._resolveLookupPaths = function(request\x2C parent) {\n  if (NativeModule.canBeRequiredByUsers(request)) {\n    debug('looking for %j in []'\x2C request);\n    return null;\n  }\n\n  // Check for node modules paths.\n  if (StringPrototypeCharAt(request\x2C 0) !== '.' ||\n      (request.length > 1 &&\n      StringPrototypeCharAt(request\x2C 1) !== '.' &&\n      StringPrototypeCharAt(request\x2C 1) !== '/' &&\n      (!isWindows || StringPrototypeCharAt(request\x2C 1) !== '\\\\'))) {\n\n    let paths = modulePaths;\n    if (parent?.paths?.length) {\n      paths = ArrayPrototypeConcat(parent.paths\x2C paths);\n    }\n\n    debug('looking for %j in %j'\x2C request\x2C paths);\n    return paths.length > 0 ? paths : null;\n  }\n\n  // In REPL\x2C parent.filename is null.\n  if (!parent || !parent.id || !parent.filename) {\n    // Make require('./path/to/foo') work - normally the path is taken\n    // from realpath(__filename) but in REPL there is no filename\n    const mainPaths = ['.'];\n\n    debug('looking for %j in %j'\x2C request\x2C mainPaths);\n    return mainPaths;\n  }\n\n  debug('RELATIVE: requested: %s from parent.id %s'\x2C request\x2C parent.id);\n\n  const parentDir = [path.dirname(parent.filename)];\n  debug('looking for %j'\x2C parentDir);\n  return parentDir;\n};\n\nfunction emitCircularRequireWarning(prop) {\n  process.emitWarning(\n    `Accessing non-existent property '${String(prop)}' of module exports ` +\n    'inside circular dependency'\n  );\n}\n\n// A Proxy that can be used as the prototype of a module.exports object and\n// warns when non-existent properties are accessed.\nconst CircularRequirePrototypeWarningProxy = new Proxy({}\x2C {\n  get(target\x2C prop) {\n    // Allow __esModule access in any case because it is used in the output\n    // of transpiled code to determine whether something comes from an\n    // ES module\x2C and is not used as a regular key of `module.exports`.\n    if (prop in target || prop === '__esModule') return target[prop];\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\x2C\n\n  getOwnPropertyDescriptor(target\x2C prop) {\n    if (ObjectPrototypeHasOwnProperty(target\x2C prop) || prop === '__esModule')\n      return ObjectGetOwnPropertyDescriptor(target\x2C prop);\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\n});\n\nfunction getExportsForCircularRequire(module) {\n  if (module.exports &&\n      !isProxy(module.exports) &&\n      ObjectGetPrototypeOf(module.exports) === ObjectPrototype &&\n      // Exclude transpiled ES6 modules / TypeScript code because those may\n      // employ unusual patterns for accessing 'module.exports'. That should\n      // be okay because ES6 modules have a different approach to circular\n      // dependencies anyway.\n      !module.exports.__esModule) {\n    // This is later unset once the module is done loading.\n    ObjectSetPrototypeOf(\n      module.exports\x2C CircularRequirePrototypeWarningProxy);\n  }\n\n  return module.exports;\n}\n\n// Check the cache for the requested file.\n// 1. If a module already exists in the cache: return its exports object.\n// 2. If the module is native: call\n//    `NativeModule.prototype.compileForPublicLoader()` and return the exports.\n// 3. Otherwise\x2C create a new module for the file and save it to the cache.\n//    Then have it load  the file contents before returning its exports\n//    object.\nModule._load = function(request\x2C parent\x2C isMain) {\n  let relResolveCacheIdentifier;\n  if (parent) {\n    debug('Module._load REQUEST %s parent: %s'\x2C request\x2C parent.id);\n    // Fast path for (lazy loaded) modules in the same directory. The indirect\n    // caching is required to allow cache invalidation without changing the old\n    // cache key names.\n    relResolveCacheIdentifier = `${parent.path}\\x00${request}`;\n    const filename = relativeResolveCache[relResolveCacheIdentifier];\n    if (filename !== undefined) {\n      const cachedModule = Module._cache[filename];\n      if (cachedModule !== undefined) {\n        updateChildren(parent\x2C cachedModule\x2C true);\n        if (!cachedModule.loaded)\n          return getExportsForCircularRequire(cachedModule);\n        return cachedModule.exports;\n      }\n      delete relativeResolveCache[relResolveCacheIdentifier];\n    }\n  }\n\n  const filename = Module._resolveFilename(request\x2C parent\x2C isMain);\n  if (StringPrototypeStartsWith(filename\x2C 'node:')) {\n    // Slice 'node:' prefix\n    const id = StringPrototypeSlice(filename\x2C 5);\n\n    const module = loadNativeModule(id\x2C request);\n    if (!module?.canBeRequiredByUsers) {\n      throw new ERR_UNKNOWN_BUILTIN_MODULE(filename);\n    }\n\n    return module.exports;\n  }\n\n  const cachedModule = Module._cache[filename];\n  if (cachedModule !== undefined) {\n    updateChildren(parent\x2C cachedModule\x2C true);\n    if (!cachedModule.loaded) {\n      const parseCachedModule = cjsParseCache.get(cachedModule);\n      if (!parseCachedModule || parseCachedModule.loaded)\n        return getExportsForCircularRequire(cachedModule);\n      parseCachedModule.loaded = true;\n    } else {\n      return cachedModule.exports;\n    }\n  }\n\n  const mod = loadNativeModule(filename\x2C request);\n  if (mod?.canBeRequiredByUsers) return mod.exports;\n\n  // Don't call updateChildren()\x2C Module constructor already does.\n  const module = cachedModule || new Module(filename\x2C parent);\n\n  if (isMain) {\n    process.mainModule = module;\n    module.id = '.';\n  }\n\n  Module._cache[filename] = module;\n  if (parent !== undefined) {\n    relativeResolveCache[relResolveCacheIdentifier] = filename;\n  }\n\n  let threw = true;\n  try {\n    module.load(filename);\n    threw = false;\n  } finally {\n    if (threw) {\n      delete Module._cache[filename];\n      if (parent !== undefined) {\n        delete relativeResolveCache[relResolveCacheIdentifier];\n        const children = parent?.children;\n        if (ArrayIsArray(children)) {\n          const index = ArrayPrototypeIndexOf(children\x2C module);\n          if (index !== -1) {\n            ArrayPrototypeSplice(children\x2C index\x2C 1);\n          }\n        }\n      }\n    } else if (module.exports &&\n               !isProxy(module.exports) &&\n               ObjectGetPrototypeOf(module.exports) ===\n                 CircularRequirePrototypeWarningProxy) {\n      ObjectSetPrototypeOf(module.exports\x2C ObjectPrototype);\n    }\n  }\n\n  return module.exports;\n};\n\nModule._resolveFilename = function(request\x2C parent\x2C isMain\x2C options) {\n  if (StringPrototypeStartsWith(request\x2C 'node:') ||\n      NativeModule.canBeRequiredByUsers(request)) {\n    return request;\n  }\n\n  let paths;\n\n  if (typeof options === 'object' && options !== null) {\n    if (ArrayIsArray(options.paths)) {\n      const isRelative = StringPrototypeStartsWith(request\x2C './') ||\n          StringPrototypeStartsWith(request\x2C '../') ||\n          ((isWindows && StringPrototypeStartsWith(request\x2C '.\\\\')) ||\n          StringPrototypeStartsWith(request\x2C '..\\\\'));\n\n      if (isRelative) {\n        paths = options.paths;\n      } else {\n        const fakeParent = new Module(''\x2C null);\n\n        paths = [];\n\n        for (let i = 0; i < options.paths.length; i++) {\n          const path = options.paths[i];\n          fakeParent.paths = Module._nodeModulePaths(path);\n          const lookupPaths = Module._resolveLookupPaths(request\x2C fakeParent);\n\n          for (let j = 0; j < lookupPaths.length; j++) {\n            if (!ArrayPrototypeIncludes(paths\x2C lookupPaths[j]))\n              ArrayPrototypePush(paths\x2C lookupPaths[j]);\n          }\n        }\n      }\n    } else if (options.paths === undefined) {\n      paths = Module._resolveLookupPaths(request\x2C parent);\n    } else {\n      throw new ERR_INVALID_ARG_VALUE('options.paths'\x2C options.paths);\n    }\n  } else {\n    paths = Module._resolveLookupPaths(request\x2C parent);\n  }\n\n  if (parent?.filename) {\n    if (request[0] === '#') {\n      const pkg = readPackageScope(parent.filename) || {};\n      if (pkg.data?.imports != null) {\n        try {\n          return finalizeEsmResolution(\n            packageImportsResolve(request\x2C pathToFileURL(parent.filename)\x2C\n                                  cjsConditions)\x2C parent.filename\x2C\n            pkg.path);\n        } catch (e) {\n          if (e.code === 'ERR_MODULE_NOT_FOUND')\n            throw createEsmNotFoundErr(request);\n          throw e;\n        }\n      }\n    }\n  }\n\n  // Try module self resolution first\n  const parentPath = trySelfParentPath(parent);\n  const selfResolved = trySelf(parentPath\x2C request);\n  if (selfResolved) {\n    const cacheKey = request + '\\x00' +\n         (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths\x2C '\\x00'));\n    Module._pathCache[cacheKey] = selfResolved;\n    return selfResolved;\n  }\n\n  // Look up the filename first\x2C since that's the cache key.\n  const filename = Module._findPath(request\x2C paths\x2C isMain\x2C false);\n  if (filename) return filename;\n  const requireStack = [];\n  for (let cursor = parent;\n    cursor;\n    cursor = moduleParentCache.get(cursor)) {\n    ArrayPrototypePush(requireStack\x2C cursor.filename || cursor.id);\n  }\n  let message = `Cannot find module '${request}'`;\n  if (requireStack.length > 0) {\n    message = message + '\\nRequire stack:\\n- ' +\n              ArrayPrototypeJoin(requireStack\x2C '\\n- ');\n  }\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  err.code = 'MODULE_NOT_FOUND';\n  err.requireStack = requireStack;\n  throw err;\n};\n\nfunction finalizeEsmResolution(resolved\x2C parentPath\x2C pkgPath) {\n  if (RegExpPrototypeTest(encodedSepRegEx\x2C resolved))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved\x2C 'must not include encoded "/" or "\\\\" characters'\x2C parentPath);\n  const filename = fileURLToPath(resolved);\n  const actual = tryFile(filename);\n  if (actual)\n    return actual;\n  const err = createEsmNotFoundErr(filename\x2C\n                                   path.resolve(pkgPath\x2C 'package.json'));\n  throw err;\n}\n\nfunction createEsmNotFoundErr(request\x2C path) {\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(`Cannot find module '${request}'`);\n  err.code = 'MODULE_NOT_FOUND';\n  if (path)\n    err.path = path;\n  // TODO(BridgeAR): Add the requireStack as well.\n  return err;\n}\n\n// Given a file name\x2C pass it to the proper extension handler.\nModule.prototype.load = function(filename) {\n  debug('load %j for module %j'\x2C filename\x2C this.id);\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  const extension = findLongestRegisteredExtension(filename);\n  // allow .mjs to be overridden\n  if (StringPrototypeEndsWith(filename\x2C '.mjs') && !Module._extensions['.mjs'])\n    throw new ERR_REQUIRE_ESM(filename\x2C true);\n\n  Module._extensions[extension](this\x2C filename);\n  this.loaded = true;\n\n  const esmLoader = asyncESM.esmLoader;\n  // Create module entry at load time to snapshot exports correctly\n  const exports = this.exports;\n  // Preemptively cache\n  if ((module?.module === undefined ||\n       module.module.getStatus() < kEvaluated) &&\n      !esmLoader.cjsCache.has(this))\n    esmLoader.cjsCache.set(this\x2C exports);\n};\n\n\n// Loads a module at the given file path. Returns that module's\n// `exports` property.\nModule.prototype.require = function(id) {\n  validateString(id\x2C 'id');\n  if (id === '') {\n    throw new ERR_INVALID_ARG_VALUE('id'\x2C id\x2C\n                                    'must be a non-empty string');\n  }\n  requireDepth++;\n  try {\n    return Module._load(id\x2C this\x2C /* isMain */ false);\n  } finally {\n    requireDepth--;\n  }\n};\n\n\n// Resolved path to process.argv[1] will be lazily placed here\n// (needed for setting breakpoint when called with --inspect-brk)\nlet resolvedArgv;\nlet hasPausedEntry = false;\n\nfunction wrapSafe(filename\x2C content\x2C cjsModuleInstance) {\n  if (patched) {\n    const wrapper = Module.wrap(content);\n    return vm.runInThisContext(wrapper\x2C {\n      filename\x2C\n      lineOffset: 0\x2C\n      displayErrors: true\x2C\n      importModuleDynamically: async (specifier) => {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier\x2C normalizeReferrerURL(filename));\n      }\x2C\n    });\n  }\n  try {\n    return vm.compileFunction(content\x2C [\n      'exports'\x2C\n      'require'\x2C\n      'module'\x2C\n      '__filename'\x2C\n      '__dirname'\x2C\n    ]\x2C {\n      filename\x2C\n      importModuleDynamically(specifier) {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier\x2C normalizeReferrerURL(filename));\n      }\x2C\n    });\n  } catch (err) {\n    if (process.mainModule === cjsModuleInstance)\n      enrichCJSError(err\x2C content);\n    throw err;\n  }\n}\n\n// Run the file contents in the correct scope or sandbox. Expose\n// the correct helper variables (require\x2C module\x2C exports) to\n// the file.\n// Returns exception\x2C if any.\nModule.prototype._compile = function(content\x2C filename) {\n  let moduleURL;\n  let redirects;\n  if (policy?.manifest) {\n    moduleURL = pathToFileURL(filename);\n    redirects = policy.manifest.getDependencyMapper(moduleURL);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  maybeCacheSourceMap(filename\x2C content\x2C this);\n  const compiledWrapper = wrapSafe(filename\x2C content\x2C this);\n\n  let inspectorWrapper = null;\n  if (getOptionValue('--inspect-brk') && process._eval == null) {\n    if (!resolvedArgv) {\n      // We enter the repl if we're not given a filename argument.\n      if (process.argv[1]) {\n        try {\n          resolvedArgv = Module._resolveFilename(process.argv[1]\x2C null\x2C false);\n        } catch {\n          // We only expect this codepath to be reached in the case of a\n          // preloaded module (it will fail earlier with the main entry)\n          assert(ArrayIsArray(getOptionValue('--require')));\n        }\n      } else {\n        resolvedArgv = 'repl';\n      }\n    }\n\n    // Set breakpoint on module start\n    if (resolvedArgv && !hasPausedEntry && filename === resolvedArgv) {\n      hasPausedEntry = true;\n      inspectorWrapper = internalBinding('inspector').callAndPauseOnStart;\n    }\n  }\n  const dirname = path.dirname(filename);\n  const require = makeRequireFunction(this\x2C redirects);\n  let result;\n  const exports = this.exports;\n  const thisValue = exports;\n  const module = this;\n  if (requireDepth === 0) statCache = new SafeMap();\n  if (inspectorWrapper) {\n    result = inspectorWrapper(compiledWrapper\x2C thisValue\x2C exports\x2C\n                              require\x2C module\x2C filename\x2C dirname);\n  } else {\n    result = ReflectApply(compiledWrapper\x2C thisValue\x2C\n                          [exports\x2C require\x2C module\x2C filename\x2C dirname]);\n  }\n  hasLoadedAnyUserCJSModule = true;\n  if (requireDepth === 0) statCache = null;\n  return result;\n};\n\n// Native extension for .js\nModule._extensions['.js'] = function(module\x2C filename) {\n  // If already analyzed the source\x2C then it will be cached.\n  const cached = cjsParseCache.get(module);\n  let content;\n  if (cached?.source) {\n    content = cached.source;\n    cached.source = undefined;\n  } else {\n    content = fs.readFileSync(filename\x2C 'utf8');\n  }\n  if (StringPrototypeEndsWith(filename\x2C '.js')) {\n    const pkg = readPackageScope(filename);\n    // Function require shouldn't be used in ES modules.\n    if (pkg?.data?.type === 'module') {\n      const parent = moduleParentCache.get(module);\n      const parentPath = parent?.filename;\n      const packageJsonPath = path.resolve(pkg.path\x2C 'package.json');\n      const usesEsm = hasEsmSyntax(content);\n      const err = new ERR_REQUIRE_ESM(filename\x2C usesEsm\x2C parentPath\x2C\n                                      packageJsonPath);\n      // Attempt to reconstruct the parent require frame.\n      if (Module._cache[parentPath]) {\n        let parentSource;\n        try {\n          parentSource = fs.readFileSync(parentPath\x2C 'utf8');\n        } catch {}\n        if (parentSource) {\n          const errLine = StringPrototypeSplit(\n            StringPrototypeSlice(err.stack\x2C StringPrototypeIndexOf(\n              err.stack\x2C '    at '))\x2C '\\n'\x2C 1)[0];\n          const { 1: line\x2C 2: col } =\n              RegExpPrototypeExec(/(\\d+):(\\d+)\\)/\x2C errLine) || [];\n          if (line && col) {\n            const srcLine = StringPrototypeSplit(parentSource\x2C '\\n')[line - 1];\n            const frame = `${parentPath}:${line}\\n${srcLine}\\n${\n              StringPrototypeRepeat(' '\x2C col - 1)}^\\n`;\n            setArrowMessage(err\x2C frame);\n          }\n        }\n      }\n      throw err;\n    }\n  }\n  module._compile(content\x2C filename);\n};\n\n\n// Native extension for .json\nModule._extensions['.json'] = function(module\x2C filename) {\n  const content = fs.readFileSync(filename\x2C 'utf8');\n\n  if (policy?.manifest) {\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  try {\n    module.exports = JSONParse(stripBOM(content));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n\n// Native extension for .node\nModule._extensions['.node'] = function(module\x2C filename) {\n  if (policy?.manifest) {\n    const content = fs.readFileSync(filename);\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n  // Be aware this doesn't use `content`\n  return process.dlopen(module\x2C path.toNamespacedPath(filename));\n};\n\nfunction createRequireFromPath(filename) {\n  // Allow a directory to be passed as the filename\n  const trailingSlash =\n    StringPrototypeEndsWith(filename\x2C '/') ||\n    (isWindows && StringPrototypeEndsWith(filename\x2C '\\\\'));\n\n  const proxyPath = trailingSlash ?\n    path.join(filename\x2C 'noop.js') :\n    filename;\n\n  const m = new Module(proxyPath);\n  m.filename = proxyPath;\n\n  m.paths = Module._nodeModulePaths(m.path);\n  return makeRequireFunction(m\x2C null);\n}\n\nconst createRequireError = 'must be a file URL object\x2C file URL string\x2C or ' +\n  'absolute path string';\n\nfunction createRequire(filename) {\n  let filepath;\n\n  if (isURLInstance(filename) ||\n      (typeof filename === 'string' && !path.isAbsolute(filename))) {\n    try {\n      filepath = fileURLToPath(filename);\n    } catch {\n      throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C\n                                      createRequireError);\n    }\n  } else if (typeof filename !== 'string') {\n    throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C createRequireError);\n  } else {\n    filepath = filename;\n  }\n  return createRequireFromPath(filepath);\n}\n\nModule.createRequire = createRequire;\n\nModule._initPaths = function() {\n  const homeDir = isWindows ? process.env.USERPROFILE : safeGetenv('HOME');\n  const nodePath = isWindows ? process.env.NODE_PATH : safeGetenv('NODE_PATH');\n\n  // process.execPath is $PREFIX/bin/node except on Windows where it is\n  // $PREFIX\\node.exe where $PREFIX is the root of the Node.js installation.\n  const prefixDir = isWindows ?\n    path.resolve(process.execPath\x2C '..') :\n    path.resolve(process.execPath\x2C '..'\x2C '..');\n\n  const paths = [path.resolve(prefixDir\x2C 'lib'\x2C 'node')];\n\n  if (homeDir) {\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_libraries'));\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_modules'));\n  }\n\n  if (nodePath) {\n    ArrayPrototypeUnshiftApply(paths\x2C ArrayPrototypeFilter(\n      StringPrototypeSplit(nodePath\x2C path.delimiter)\x2C\n      Boolean\n    ));\n  }\n\n  modulePaths = paths;\n\n  // Clone as a shallow copy\x2C for introspection.\n  Module.globalPaths = ArrayPrototypeSlice(modulePaths);\n};\n\nModule._preloadModules = function(requests) {\n  if (!ArrayIsArray(requests))\n    return;\n\n  isPreloading = true;\n\n  // Preloaded modules have a dummy parent module which is deemed to exist\n  // in the current working directory. This seeds the search path for\n  // preloaded modules.\n  const parent = new Module('internal/preload'\x2C null);\n  try {\n    parent.paths = Module._nodeModulePaths(process.cwd());\n  } catch (e) {\n    if (e.code !== 'ENOENT') {\n      isPreloading = false;\n      throw e;\n    }\n  }\n  for (let n = 0; n < requests.length; n++)\n    parent.require(requests[n]);\n  isPreloading = false;\n};\n\nModule.syncBuiltinESMExports = function syncBuiltinESMExports() {\n  for (const mod of NativeModule.map.values()) {\n    if (mod.canBeRequiredByUsers) {\n      mod.syncExports();\n    }\n  }\n};\n\n// Backwards compatibility\nModule.Module = Module;\n
code-source-info,0x24b326961176,100,0,39931,C0O0C4O39931,,
code-creation,Function,10,64632,0x24b326962f16,2547, node:internal/modules/cjs/loader:1:1,0x24b3269610f0,~
code-source-info,0x24b326962f16,100,0,39931,C0O0C446O1159C452O1175C458O1199C464O1223C470O1249C476O1274C482O1296C488O1318C494O1341C500O1365C506O1390C512O1420C518O1431C524O1440C530O1453C535O1469C541O1493C546O1509C552O1543C558O1567C564O1581C570O1600C576O1633C582O1657C587O1666C593O1682C599O1696C605O1719C611O1742C617O1753C622O1768C628O1778C634O1803C640O1832C646O1859C652O1889C658O1915C664O1939C670O1964C676O1988C682O2012C688O2118C690O2118C695O2118C697O2191C709O2212C715O2222C721O2230C727O2242C733O2260C763O2206C767O2376C771O2376C777O2359C783O2450C787O2450C793O2425C799O2555C803O2555C809O2507C815O2522C821O2537C827O2602C831O2602C837O2588C842O2639C846O2639C850O2639C852O2669C856O2669C860O2669C862O2708C866O2708C870O2708C872O2742C876O2742C880O2742C882O2785C886O2785C890O2785C892O2818C896O2810C902O2855C910O2855C916O2832C922O2904C926O2904C930O2904C932O2976C940O2976C946O2961C952O3132C956O3132C962O3018C968O3035C974O3051C980O3071C986O3094C992O3118C998O3200C1002O3200C1008O3181C1014O3254C1022O3254C1026O3254C1028O3322C1036O3322C1040O3322C1042O3432C1050O3432C1060O3476C1067O3432C1069O3656C1070O3656C1072O3825C1076O3825C1082O3825C1088O3687C1094O3714C1100O3748C1106O3769C1112O3804C1118O3880C1122O3880C1128O3861C1134O3939C1142O3939C1147O4051C1151O4051C1157O3991C1163O4013C1169O4036C1175O4105C1179O4105C1185O4093C1191O4155C1195O4155C1199O4155C1201O4222C1205O4222C1211O4203C1217O4290C1225O4290C1231O4275C1237O4402C1241O4402C1247O4332C1253O4351C1259O4376C1265O4462C1269O4470C1277O4479C1280O4462C1282O4522C1285O4522C1289O4522C1291O4562C1292O4562C1294O4581C1295O4581C1297O4606C1298O4606C1300O5250C1302O5250C1307O5250C1309O5546C1312O5595C1316O5595C1350O5577C1381O5566C1388O5573C1397O5612C1403O5640C1407O5640C1412O5550C1483O5687C1487O5717C1493O5739C1497O5758C1504O5774C1508O5772C1512O5794C1519O5814C1527O5812C1535O5834C1542O5855C1550O5853C1558O5893C1562O5893C1564O5897C1572O5916C1580O5937C1581O5937C1583O5995C1587O5995C1589O6091C1597O6205C1606O6218C1618O6345C1635O6195C1645O6195C1647O6484C1659O6505C1668O6525C1680O6558C1692O6484C1702O6618C1714O6639C1723O6662C1735O6703C1747O6618C1757O6796C1766O6798C1781O6832C1789O6860C1806O6832C1816O6906C1824O6940C1841O6906C1851O7132C1859O7160C1884O7190C1892O7313C1907O7211C1921O7394C1931O7418C1939O7541C1954O7439C1968O7622C1976O7132C1986O7656C1990O7656C2000O7689C2020O7690C2032O7656C2034O7737C2050O7753C2060O7751C2068O8066C2072O8066C2082O8066C2084O10869C2088O10869C2098O10869C2100O13489C2107O13489C2109O14264C2116O14264C2118O14282C2126O14299C2134O16975C2141O16975C2143O17052C2147O17060C2155O17052C2157O17068C2161O17131C2169O17155C2179O18739C2187O18763C2195O19909C2203O19936C2211O21484C2223O21502C2235O21879C2249O21484C2259O21484C2261O23167C2269O23180C2277O26111C2285O26135C2293O29982C2297O29989C2311O30004C2319O30918C2323O30925C2337O30943C2345O31381C2346O31381C2348O31416C2349O31416C2351O32473C2355O32480C2369O32499C2377O34381C2381O34388C2395O34407C2403O36151C2407O36158C2421O36179C2429O36579C2433O36586C2447O36607C2455O37420C2461O37470C2467O37420C2469O38054C2475O38075C2483O38093C2491O38111C2499O39080C2507O39103C2515O39690C2523O39719C2531O39907C2537O39921C2546O39930,,
tick,0x7fff2038515d,64886,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
tick,0x10c677360,64927,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
tick,0x10c7cd2c4,65228,1,0x10c345dc2,2,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b3269632b4,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Eval,10,65321,0x24b326966f56,5, node:internal/modules/package_json_reader:1:1,0x24b326966db0,~
script-source,101,node:internal/modules/package_json_reader,'use strict';\n\nconst { SafeMap } = primordials;\nconst { internalModuleReadJSON } = internalBinding('fs');\nconst { pathToFileURL } = require('url');\nconst { toNamespacedPath } = require('path');\n\nconst cache = new SafeMap();\n\nlet manifest;\n\n/**\n *\n * @param {string} jsonPath\n */\nfunction read(jsonPath) {\n  if (cache.has(jsonPath)) {\n    return cache.get(jsonPath);\n  }\n\n  const { 0: string\x2C 1: containsKeys } = internalModuleReadJSON(\n    toNamespacedPath(jsonPath)\n  );\n  const result = { string\x2C containsKeys };\n  const { getOptionValue } = require('internal/options');\n  if (string !== undefined) {\n    if (manifest === undefined) {\n      manifest = getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').manifest :\n        null;\n    }\n    if (manifest !== null) {\n      const jsonURL = pathToFileURL(jsonPath);\n      manifest.assertIntegrity(jsonURL\x2C string);\n    }\n  }\n  cache.set(jsonPath\x2C result);\n  return result;\n}\n\nmodule.exports = { read };\n
code-source-info,0x24b326966f56,101,0,983,C0O0C4O983,,
code-creation,Function,10,65423,0x24b3269670a6,113, node:internal/modules/package_json_reader:1:1,0x24b326966ed0,~
code-source-info,0x24b3269670a6,101,0,983,C0O0C29O23C34O83C37O83C42O56C48O132C54O132C59O114C65O177C71O177C76O156C82O209C84O209C89O209C91O229C92O229C94O956C101O975C107O971C112O982,,
code-creation,Eval,10,65838,0x24b326967876,5, node:internal/process/esm_loader:1:1,0x24b326967680,~
script-source,102,node:internal/process/esm_loader,'use strict';\n\nconst {\n  ObjectCreate\x2C\n} = primordials;\n\nconst {\n  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\x2C\n} = require('internal/errors').codes;\nconst { ESMLoader } = require('internal/modules/esm/loader');\nconst {\n  hasUncaughtExceptionCaptureCallback\x2C\n} = require('internal/process/execution');\nconst { pathToFileURL } = require('internal/url');\nconst {\n  getModuleFromWrap\x2C\n} = require('internal/vm/module');\n\nexports.initializeImportMetaObject = function(wrap\x2C meta) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { initializeImportMeta } = callbackMap.get(wrap);\n    if (initializeImportMeta !== undefined) {\n      initializeImportMeta(meta\x2C getModuleFromWrap(wrap) || wrap);\n    }\n  }\n};\n\nexports.importModuleDynamicallyCallback =\nasync function importModuleDynamicallyCallback(wrap\x2C specifier\x2C assertions) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { importModuleDynamically } = callbackMap.get(wrap);\n    if (importModuleDynamically !== undefined) {\n      return importModuleDynamically(\n        specifier\x2C getModuleFromWrap(wrap) || wrap\x2C assertions);\n    }\n  }\n  throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING();\n};\n\nconst esmLoader = new ESMLoader();\n\nexports.esmLoader = esmLoader;\n\n/**\n * Causes side-effects: user-defined loader hooks are added to esmLoader.\n * @returns {void}\n */\nasync function initializeLoader() {\n  const { getOptionValue } = require('internal/options');\n  // customLoaders CURRENTLY can be only 1 (a string)\n  // Once chaining is implemented\x2C it will be string[]\n  const customLoaders = getOptionValue('--experimental-loader');\n\n  if (!customLoaders.length) return;\n\n  const { emitExperimentalWarning } = require('internal/util');\n  emitExperimentalWarning('--experimental-loader');\n\n  let cwd;\n  try {\n    cwd = process.cwd() + '/';\n  } catch {\n    cwd = 'file:///';\n  }\n\n  // A separate loader instance is necessary to avoid cross-contamination\n  // between internal Node.js and userland. For example\x2C a module with internal\n  // state (such as a counter) should be independent.\n  const internalEsmLoader = new ESMLoader();\n\n  // Importation must be handled by internal loader to avoid poluting userland\n  const exports = await internalEsmLoader.import(\n    customLoaders\x2C\n    pathToFileURL(cwd).href\x2C\n    ObjectCreate(null)\x2C\n  );\n\n  // Hooks must then be added to external/public loader\n  // (so they're triggered in userland)\n  await esmLoader.addCustomLoaders(exports);\n}\n\nexports.loadESM = async function loadESM(callback) {\n  try {\n    await initializeLoader();\n    await callback(esmLoader);\n  } catch (err) {\n    if (hasUncaughtExceptionCaptureCallback()) {\n      process._fatalException(err);\n      return;\n    }\n    internalBinding('errors').triggerUncaughtException(\n      err\x2C\n      true /* fromPromise */\n    );\n  }\n};\n
code-source-info,0x24b326967876,102,0,2883,C0O0C4O2883,,
code-creation,Function,10,66074,0x24b326967b16,182, node:internal/process/esm_loader:1:1,0x24b3269677f0,~
code-source-info,0x24b326967b16,102,0,2883,C0O0C44O25C50O111C56O111C61O137C66O67C72O167C78O167C83O153C89O258C95O258C100O217C106O323C112O323C117O305C123O381C129O381C134O358C140O413C144O448C148O749C152O789C156O1259C159O1259C164O1259C166O1277C168O1295C172O2528C176O2544C181O2882,,
tick,0x10c660417,66535,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Eval,10,66575,0x24b326968bbe,5, node:internal/modules/esm/loader:1:1,0x24b3269687c0,~
script-source,103,node:internal/modules/esm/loader,'use strict';\n\n// This is needed to avoid cycles in esm/resolve <-> cjs/loader\nrequire('internal/modules/cjs/loader');\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectCreate\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  SafeWeakMap\x2C\n  globalThis\x2C\n} = primordials;\n\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_MODULE_SPECIFIER\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\x2C\n  ERR_INVALID_RETURN_VALUE\x2C\n  ERR_UNKNOWN_MODULE_FORMAT\n} = require('internal/errors').codes;\nconst { pathToFileURL\x2C isURLInstance } = require('internal/url');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst ModuleMap = require('internal/modules/esm/module_map');\nconst ModuleJob = require('internal/modules/esm/module_job');\n\nconst {\n  defaultResolve\x2C\n  DEFAULT_CONDITIONS\x2C\n} = require('internal/modules/esm/resolve');\nconst { defaultLoad } = require('internal/modules/esm/load');\nconst { translators } = require(\n  'internal/modules/esm/translators');\nconst { getOptionValue } = require('internal/options');\n\n/**\n * An ESMLoader instance is used as the main entry point for loading ES modules.\n * Currently\x2C this is a singleton -- there is only one used for loading\n * the main module and everything in its dependency graph.\n */\nclass ESMLoader {\n  /**\n   * Prior to ESM loading. These are called once before any modules are started.\n   * @private\n   * @property {function[]} globalPreloaders First-in-first-out list of\n   * preload hooks.\n   */\n  #globalPreloaders = [];\n\n  /**\n   * Phase 2 of 2 in ESM loading.\n   * @private\n   * @property {function[]} loaders First-in-first-out list of loader hooks.\n   */\n  #loaders = [\n    defaultLoad\x2C\n  ];\n\n  /**\n   * Phase 1 of 2 in ESM loading.\n   * @private\n   * @property {function[]} resolvers First-in-first-out list of resolver hooks\n   */\n  #resolvers = [\n    defaultResolve\x2C\n  ];\n\n  /**\n   * Map of already-loaded CJS modules to use\n   */\n  cjsCache = new SafeWeakMap();\n\n  /**\n   * The index for assigning unique URLs to anonymous module evaluation\n   */\n  evalIndex = 0;\n\n  /**\n   * Registry of loaded modules\x2C akin to `require.cache`\n   */\n  moduleMap = new ModuleMap();\n\n  /**\n   * Methods which translate input code or other information into ES modules\n   */\n  translators = translators;\n\n  static pluckHooks({\n    globalPreload\x2C\n    resolve\x2C\n    load\x2C\n    // obsolete hooks:\n    dynamicInstantiate\x2C\n    getFormat\x2C\n    getGlobalPreloadCode\x2C\n    getSource\x2C\n    transformSource\x2C\n  }) {\n    const obsoleteHooks = [];\n    const acceptedHooks = ObjectCreate(null);\n\n    if (getGlobalPreloadCode) {\n      globalPreload ??= getGlobalPreloadCode;\n\n      process.emitWarning(\n        'Loader hook "getGlobalPreloadCode" has been renamed to "globalPreload"'\n      );\n    }\n    if (dynamicInstantiate) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'dynamicInstantiate'\n    );\n    if (getFormat) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'getFormat'\x2C\n    );\n    if (getSource) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'getSource'\x2C\n    );\n    if (transformSource) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'transformSource'\x2C\n    );\n\n    if (obsoleteHooks.length) process.emitWarning(\n      `Obsolete loader hook(s) supplied and will be ignored: ${\n        ArrayPrototypeJoin(obsoleteHooks\x2C '\x2C ')\n      }`\x2C\n      'DeprecationWarning'\x2C\n    );\n\n    // Use .bind() to avoid giving access to the Loader instance when called.\n    if (globalPreload) {\n      acceptedHooks.globalPreloader =\n        FunctionPrototypeBind(globalPreload\x2C null);\n    }\n    if (resolve) {\n      acceptedHooks.resolver = FunctionPrototypeBind(resolve\x2C null);\n    }\n    if (load) {\n      acceptedHooks.loader = FunctionPrototypeBind(load\x2C null);\n    }\n\n    return acceptedHooks;\n  }\n\n  /**\n   * Collect custom/user-defined hook(s). After all hooks have been collected\x2C\n   * calls global preload hook(s).\n   * @param {object | object[]} customLoaders A list of exports from\n   * user-defined loaders (as returned by ESMLoader.import()).\n   */\n  async addCustomLoaders(\n    customLoaders = []\x2C\n  ) {\n    if (!ArrayIsArray(customLoaders)) customLoaders = [customLoaders];\n\n    for (let i = 0; i < customLoaders.length; i++) {\n      const exports = customLoaders[i];\n      const {\n        globalPreloader\x2C\n        resolver\x2C\n        loader\x2C\n      } = ESMLoader.pluckHooks(exports);\n\n      if (globalPreloader) ArrayPrototypePush(\n        this.#globalPreloaders\x2C\n        FunctionPrototypeBind(globalPreloader\x2C null)\x2C // [1]\n      );\n      if (resolver) ArrayPrototypePush(\n        this.#resolvers\x2C\n        FunctionPrototypeBind(resolver\x2C null)\x2C // [1]\n      );\n      if (loader) ArrayPrototypePush(\n        this.#loaders\x2C\n        FunctionPrototypeBind(loader\x2C null)\x2C // [1]\n      );\n    }\n\n    // [1] ensure hook function is not bound to ESMLoader instance\n\n    this.preload();\n  }\n\n  async eval(\n    source\x2C\n    url = pathToFileURL(`${process.cwd()}/[eval${++this.evalIndex}]`).href\n  ) {\n    const evalInstance = (url) => {\n      const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n      const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n      callbackMap.set(module\x2C {\n        importModuleDynamically: (specifier\x2C { url }) => {\n          return this.import(specifier\x2C url);\n        }\n      });\n\n      return module;\n    };\n    const job = new ModuleJob(this\x2C url\x2C evalInstance\x2C false\x2C false);\n    this.moduleMap.set(url\x2C job);\n    const { module } = await job.run();\n\n    return {\n      namespace: module.getNamespace()\x2C\n    };\n  }\n\n  async getModuleJob(specifier\x2C parentURL) {\n    const { format\x2C url } = await this.resolve(specifier\x2C parentURL);\n    let job = this.moduleMap.get(url);\n    // CommonJS will set functions for lazy job evaluation.\n    if (typeof job === 'function') this.moduleMap.set(url\x2C job = job());\n\n    if (job !== undefined) return job;\n\n    const moduleProvider = async (url\x2C isMain) => {\n      const { format: finalFormat\x2C source } = await this.load(url\x2C { format });\n\n      const translator = translators.get(finalFormat);\n\n      if (!translator) throw new ERR_UNKNOWN_MODULE_FORMAT(finalFormat);\n\n      return FunctionPrototypeCall(translator\x2C this\x2C url\x2C source\x2C isMain);\n    };\n\n    const inspectBrk = (\n      parentURL === undefined &&\n      getOptionValue('--inspect-brk')\n    );\n\n    job = new ModuleJob(\n      this\x2C\n      url\x2C\n      moduleProvider\x2C\n      parentURL === undefined\x2C\n      inspectBrk\n    );\n\n    this.moduleMap.set(url\x2C job);\n\n    return job;\n  }\n\n  /**\n   * This method is usually called indirectly as part of the loading processes.\n   * Internally\x2C it is used directly to add loaders. Use directly with caution.\n   *\n   * This method must NOT be renamed: it functions as a dynamic import on a\n   * loader module.\n   *\n   * @param {string | string[]} specifiers Path(s) to the module\n   * @param {string} [parentURL] Path of the parent importing the module\n   * @returns {object | object[]} A list of module export(s)\n   */\n  async import(specifiers\x2C parentURL) {\n    const wasArr = ArrayIsArray(specifiers);\n    if (!wasArr) specifiers = [specifiers];\n\n    const count = specifiers.length;\n    const jobs = new Array(count);\n\n    for (let i = 0; i < count; i++) {\n      jobs[i] = this.getModuleJob(specifiers[i]\x2C parentURL)\n        .then((job) => job.run())\n        .then(({ module }) => module.getNamespace());\n    }\n\n    const namespaces = await PromiseAll(new SafeArrayIterator(jobs));\n\n    return wasArr ?\n      namespaces :\n      namespaces[0];\n  }\n\n  /**\n   * Provide source that is understood by one of Node's translators.\n   *\n   * The internals of this WILL change when chaining is implemented\x2C\n   * depending on the resolution/consensus from #36954\n   * @param {string} url The URL/path of the module to be loaded\n   * @param {Object} context Metadata about the module\n   * @returns {Object}\n   */\n  async load(url\x2C context = {}) {\n    const defaultLoader = this.#loaders[0];\n\n    const loader = this.#loaders.length === 1 ?\n      defaultLoader :\n      this.#loaders[1];\n    const loaded = await loader(url\x2C context\x2C defaultLoader);\n\n    if (typeof loaded !== 'object') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'object'\x2C\n        'loader load'\x2C\n        loaded\x2C\n      );\n    }\n\n    const {\n      format\x2C\n      source\x2C\n    } = loaded;\n\n    if (format == null) {\n      const dataUrl = RegExpPrototypeExec(\n        /^data:([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n        url\x2C\n      );\n\n      throw new ERR_INVALID_MODULE_SPECIFIER(\n        url\x2C\n        dataUrl ? `has an unsupported MIME type "${dataUrl[1]}"` : ''\n      );\n    }\n\n    if (typeof format !== 'string') {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C\n        'loader resolve'\x2C\n        'format'\x2C\n        format\x2C\n      );\n    }\n\n    if (\n      source != null &&\n      typeof source !== 'string' &&\n      !isAnyArrayBuffer(source) &&\n      !isArrayBufferView(source)\n    ) throw ERR_INVALID_RETURN_PROPERTY_VALUE(\n      'string\x2C an ArrayBuffer\x2C or a TypedArray'\x2C\n      'loader load'\x2C\n      'source'\x2C\n      source\n    );\n\n    return {\n      format\x2C\n      source\x2C\n    };\n  }\n\n  preload() {\n    const count = this.#globalPreloaders.length;\n    if (!count) return;\n\n    for (let i = 0; i < count; i++) {\n      const preload = this.#globalPreloaders[i]();\n\n      if (preload == null) return;\n\n      if (typeof preload !== 'string') {\n        throw new ERR_INVALID_RETURN_VALUE(\n          'string'\x2C\n          'loader globalPreloadCode'\x2C\n          preload\x2C\n        );\n      }\n      const { compileFunction } = require('vm');\n      const preloadInit = compileFunction(\n        preload\x2C\n        ['getBuiltin']\x2C\n        {\n          filename: '<preload>'\x2C\n        }\n      );\n      const { NativeModule } = require('internal/bootstrap/loaders');\n\n      FunctionPrototypeCall(preloadInit\x2C globalThis\x2C (builtinName) => {\n        if (NativeModule.canBeRequiredByUsers(builtinName)) {\n          return require(builtinName);\n        }\n        throw new ERR_INVALID_ARG_VALUE('builtinName'\x2C builtinName);\n      });\n    }\n  }\n\n  /**\n   * Resolve the location of the module.\n   *\n   * The internals of this WILL change when chaining is implemented\x2C\n   * depending on the resolution/consensus from #36954\n   * @param {string} originalSpecifier The specified URL path of the module to\n   * be resolved\n   * @param {String} parentURL The URL path of the module's parent\n   * @returns {{ url: String }}\n   */\n  async resolve(originalSpecifier\x2C parentURL) {\n    const isMain = parentURL === undefined;\n\n    if (\n      !isMain &&\n      typeof parentURL !== 'string' &&\n      !isURLInstance(parentURL)\n    ) throw new ERR_INVALID_ARG_TYPE(\n      'parentURL'\x2C\n      ['string'\x2C 'URL']\x2C\n      parentURL\x2C\n    );\n\n    const conditions = DEFAULT_CONDITIONS;\n\n    const defaultResolver = this.#resolvers[0];\n\n    const resolver = this.#resolvers.length === 1 ?\n      defaultResolver :\n      this.#resolvers[1];\n    const resolution = await resolver(\n      originalSpecifier\x2C\n      {\n        conditions\x2C\n        parentURL\x2C\n      }\x2C\n      defaultResolver\x2C\n    );\n\n    if (typeof resolution !== 'object') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'object'\x2C\n        'loader resolve'\x2C\n        resolution\x2C\n      );\n    }\n\n    const { format\x2C url } = resolution;\n\n    if (\n      format != null &&\n      typeof format !== 'string'\n    ) {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C\n        'loader resolve'\x2C\n        'format'\x2C\n        format\x2C\n      );\n    }\n    if (typeof url !== 'string') {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C\n        'loader resolve'\x2C\n        'url'\x2C\n        url\x2C\n      );\n    }\n\n    return {\n      format\x2C\n      url\x2C\n    };\n  }\n}\n\nObjectSetPrototypeOf(ESMLoader.prototype\x2C null);\n\nexports.ESMLoader = ESMLoader;\n
code-source-info,0x24b326968bbe,103,0,11918,C0O0C4O11918,,
code-creation,Function,10,67371,0x24b326969306,530, node:internal/modules/esm/loader:1:1,0x24b326968b38,~
code-source-info,0x24b326969306,103,0,11918,C0O0C104O79C110O79C114O130C120O139C126O155C132O177C138O199C144O224C150O249C156O265C161O289C167O303C173O326C179O347C185O362C191O578C197O578C202O604C207O402C213O426C219O451C225O483C231O520C237O548C243O653C249O653C254O620C260O635C266O731C272O731C277O688C283O708C289O781C295O781C299O781C301O843C307O843C311O843C313O940C319O940C324O898C330O916C336O1005C342O1005C347O989C353O1067C359O1067C364O1051C370O1142C376O1142C381O1123C510O11868C517O11837C522O11887C524O11905C529O11917,,
code-creation,Function,10,67416,0x24b3269696fe,139,<instance_members_initializer> node:internal/modules/esm/loader:59:3,0x24b326968ec0,~
code-source-info,0x24b3269696fe,103,1611,2404,C3O1631C17O1786C28O1792C45O1966C56O1972C73O2065C80O2065C94O2183C104O2270C111O2270C125O2393C138O2404,,
code-creation,Eval,10,67610,0x24b32696aac6,5, node:internal/modules/esm/module_map:1:1,0x24b32696a8f8,~
script-source,104,node:internal/modules/esm/module_map,'use strict';\n\nconst ModuleJob = require('internal/modules/esm/module_job');\nconst {\n  SafeMap\x2C\n} = primordials;\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\nconst { validateString } = require('internal/validators');\n\n// Tracks the state of the loader-level module cache\nclass ModuleMap extends SafeMap {\n  constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  get(url) {\n    validateString(url\x2C 'url');\n    return super.get(url);\n  }\n  set(url\x2C job) {\n    validateString(url\x2C 'url');\n    if (job instanceof ModuleJob !== true &&\n        typeof job !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('job'\x2C 'ModuleJob'\x2C job);\n    }\n    debug(`Storing ${url} in ModuleMap`);\n    return super.set(url\x2C job);\n  }\n  has(url) {\n    validateString(url\x2C 'url');\n    return super.has(url);\n  }\n}\nmodule.exports = ModuleMap;\n
code-source-info,0x24b32696aac6,104,0,955,C0O0C4O955,,
code-creation,Function,10,67700,0x24b32696aee6,149, node:internal/modules/esm/module_map:1:1,0x24b32696aa40,~
code-source-info,0x24b32696aee6,104,0,955,C0O0C17O33C20O33C24O33C26O87C31O125C34O125C39O158C52O159C58O125C60O236C63O236C68O262C73O211C79O297C82O297C87O278C97O407C141O927C143O942C148O954,,
tick,0x10c1f8de1,67810,0,0x0,0,0x24b357dbe24e,0x24b357dbd585,0x24b32696aefa,0x24b357dbe2b5,0x24b357dbd585,0x24b32696942d,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Eval,10,68027,0x24b32696b9c6,5, node:internal/modules/esm/module_job:1:1,0x24b32696b6e0,~
script-source,105,node:internal/modules/esm/module_job,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSome\x2C\n  FunctionPrototype\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  PromiseResolve\x2C\n  PromisePrototypeCatch\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  SafeSet\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\nconst { ModuleWrap } = internalBinding('module_wrap');\n\nconst { decorateErrorStack } = require('internal/util');\nconst {\n  getSourceMapsEnabled\x2C\n} = require('internal/source_map/source_map_cache');\nconst assert = require('internal/assert');\nconst resolvedPromise = PromiseResolve();\n\nconst noop = FunctionPrototype;\n\nlet hasPausedEntry = false;\n\nconst CJSGlobalLike = [\n  'require'\x2C\n  'module'\x2C\n  'exports'\x2C\n  '__filename'\x2C\n  '__dirname'\x2C\n];\nconst isCommonJSGlobalLikeNotDefinedError = (errorMessage) =>\n  ArrayPrototypeSome(\n    CJSGlobalLike\x2C\n    (globalLike) => errorMessage === `${globalLike} is not defined`\n  );\n\n/* A ModuleJob tracks the loading of a single Module\x2C and the ModuleJobs of\n * its dependencies\x2C over time. */\nclass ModuleJob {\n  // `loader` is the Loader instance used for loading dependencies.\n  // `moduleProvider` is a function\n  constructor(loader\x2C url\x2C moduleProvider\x2C isMain\x2C inspectBrk) {\n    this.loader = loader;\n    this.isMain = isMain;\n    this.inspectBrk = inspectBrk;\n\n    this.module = undefined;\n    // Expose the promise to the ModuleWrap directly for linking below.\n    // `this.module` is also filled in below.\n    this.modulePromise = ReflectApply(moduleProvider\x2C loader\x2C [url\x2C isMain]);\n\n    // Wait for the ModuleWrap instance being linked with all dependencies.\n    const link = async () => {\n      this.module = await this.modulePromise;\n      assert(this.module instanceof ModuleWrap);\n\n      // Explicitly keeping track of dependency jobs is needed in order\n      // to flatten out the dependency graph below in `_instantiate()`\x2C\n      // so that circular dependencies can't cause a deadlock by two of\n      // these `link` callbacks depending on each other.\n      const dependencyJobs = [];\n      const promises = this.module.link(async (specifier) => {\n        const jobPromise = this.loader.getModuleJob(specifier\x2C url);\n        ArrayPrototypePush(dependencyJobs\x2C jobPromise);\n        const job = await jobPromise;\n        return job.modulePromise;\n      });\n\n      if (promises !== undefined)\n        await PromiseAll(new SafeArrayIterator(promises));\n\n      return PromiseAll(new SafeArrayIterator(dependencyJobs));\n    };\n    // Promise for the list of all dependencyJobs.\n    this.linked = link();\n    // This promise is awaited later anyway\x2C so silence\n    // 'unhandled rejection' warnings.\n    PromisePrototypeCatch(this.linked\x2C noop);\n\n    // instantiated == deep dependency jobs wrappers are instantiated\x2C\n    // and module wrapper is instantiated.\n    this.instantiated = undefined;\n  }\n\n  instantiate() {\n    if (this.instantiated === undefined) {\n      this.instantiated = this._instantiate();\n    }\n    return this.instantiated;\n  }\n\n  async _instantiate() {\n    const jobsInGraph = new SafeSet();\n    const addJobsToDependencyGraph = async (moduleJob) => {\n      if (jobsInGraph.has(moduleJob)) {\n        return;\n      }\n      jobsInGraph.add(moduleJob);\n      const dependencyJobs = await moduleJob.linked;\n      return PromiseAll(new SafeArrayIterator(\n        ArrayPrototypeMap(dependencyJobs\x2C addJobsToDependencyGraph)));\n    };\n    await addJobsToDependencyGraph(this);\n\n    try {\n      if (!hasPausedEntry && this.inspectBrk) {\n        hasPausedEntry = true;\n        const initWrapper = internalBinding('inspector').callAndPauseOnStart;\n        initWrapper(this.module.instantiate\x2C this.module);\n      } else {\n        this.module.instantiate();\n      }\n    } catch (e) {\n      decorateErrorStack(e);\n      // TODO(@bcoe): Add source map support to exception that occurs as result\n      // of missing named export. This is currently not possible because\n      // stack trace originates in module_job\x2C not the file itself. A hidden\n      // symbol with filename could be set in node_errors.cc to facilitate this.\n      if (!getSourceMapsEnabled() &&\n          StringPrototypeIncludes(e.message\x2C\n                                  ' does not provide an export named')) {\n        const splitStack = StringPrototypeSplit(e.stack\x2C '\\n');\n        const parentFileUrl = StringPrototypeReplace(\n          splitStack[0]\x2C\n          /:\\d+$/\x2C\n          ''\n        );\n        const { 1: childSpecifier\x2C 2: name } = StringPrototypeMatch(\n          e.message\x2C\n          /module '(.*)' does not provide an export named '(.+)'/);\n        const { url: childFileURL } = await this.loader.resolve(\n          childSpecifier\x2C parentFileUrl\x2C\n        );\n        const { format } = await this.loader.load(childFileURL);\n\n        if (format === 'commonjs') {\n          const importStatement = splitStack[1];\n          // TODO(@ctavan): The original error stack only provides the single\n          // line which causes the error. For multi-line import statements we\n          // cannot generate an equivalent object destructuring assignment by\n          // just parsing the error stack.\n          const oneLineNamedImports = StringPrototypeMatch(importStatement\x2C /{.*}/);\n          const destructuringAssignment = oneLineNamedImports &&\n            StringPrototypeReplace(oneLineNamedImports\x2C /\\s+as\\s+/g\x2C ': ');\n          e.message = `Named export '${name}' not found. The requested module` +\n            ` '${childSpecifier}' is a CommonJS module\x2C which may not support` +\n            ' all module.exports as named exports.\\nCommonJS modules can ' +\n            'always be imported via the default export\x2C for example using:' +\n            `\\n\\nimport pkg from '${childSpecifier}';\\n${\n              destructuringAssignment ?\n                `const ${destructuringAssignment} = pkg;\\n` : ''}`;\n          const newStack = StringPrototypeSplit(e.stack\x2C '\\n');\n          newStack[3] = `SyntaxError: ${e.message}`;\n          e.stack = ArrayPrototypeJoin(newStack\x2C '\\n');\n        }\n      }\n      throw e;\n    }\n\n    for (const dependencyJob of jobsInGraph) {\n      // Calling `this.module.instantiate()` instantiates not only the\n      // ModuleWrap in this module\x2C but all modules in the graph.\n      dependencyJob.instantiated = resolvedPromise;\n    }\n  }\n\n  async run() {\n    await this.instantiate();\n    const timeout = -1;\n    const breakOnSigint = false;\n    try {\n      await this.module.evaluate(timeout\x2C breakOnSigint);\n    } catch (e) {\n      if (e?.name === 'ReferenceError' &&\n          isCommonJSGlobalLikeNotDefinedError(e.message)) {\n        e.message += ' in ES module scope';\n\n        if (StringPrototypeStartsWith(e.message\x2C 'require ')) {\n          e.message += '\x2C you can use import instead';\n        }\n\n        const packageConfig =\n          StringPrototypeStartsWith(this.module.url\x2C 'file://') &&\n            RegExpPrototypeTest(/\\.js(\\?[^#]*)?(#.*)?$/\x2C this.module.url) &&\n            require('internal/modules/esm/resolve')\n              .getPackageScopeConfig(this.module.url);\n        if (packageConfig.type === 'module') {\n          e.message +=\n            '\\nThis file is being treated as an ES module because it has a ' +\n            `'.js' file extension and '${packageConfig.pjsonPath}' contains ` +\n            '"type": "module". To treat it as a CommonJS script\x2C rename it ' +\n            'to use the \\'.cjs\\' file extension.';\n        }\n      }\n      throw e;\n    }\n    return { module: this.module };\n  }\n}\nObjectSetPrototypeOf(ModuleJob.prototype\x2C null);\nmodule.exports = ModuleJob;\n
code-source-info,0x24b32696b9c6,105,0,7692,C0O0C4O7692,,
code-creation,Function,10,68523,0x24b32696beb6,334, node:internal/modules/esm/module_job:1:1,0x24b32696b940,~
code-source-info,0x24b32696beb6,105,0,7692,C0O0C85O25C91O47C97O68C103O90C109O112C114O133C119O157C125O171C130O189C136O214C142O230C148O253C154O274C160O285C166O312C172O336C178O362C184O386C190O454C196O454C201O439C207O518C213O518C218O495C224O580C230O580C235O554C241O644C247O644C251O644C253O696C256O696C258O728C260O728C262O769C263O769C265O799C269O799C271O917C275O917C314O7646C321O7615C326O7664C328O7679C333O7691,,
tick,0x10c48af7d,68925,1,0x10c345dc2,2,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b326969445,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Eval,10,69756,0x24b32696eb96,5, node:internal/modules/esm/resolve:1:1,0x24b32696e4b0,~
script-source,106,node:internal/modules/esm/resolve,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  JSONParse\x2C\n  JSONStringify\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst internalFS = require('internal/fs/utils');\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  realpathSync\x2C\n  statSync\x2C\n  Stats\x2C\n} = require('fs');\nconst { getOptionValue } = require('internal/options');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst { sep\x2C relative\x2C resolve } = require('path');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst typeFlag = getOptionValue('--input-type');\nconst { URL\x2C pathToFileURL\x2C fileURLToPath } = require('internal/url');\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_MODULE_SPECIFIER\x2C\n  ERR_INVALID_PACKAGE_CONFIG\x2C\n  ERR_INVALID_PACKAGE_TARGET\x2C\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_MODULE_NOT_FOUND\x2C\n  ERR_PACKAGE_IMPORT_NOT_DEFINED\x2C\n  ERR_PACKAGE_PATH_NOT_EXPORTED\x2C\n  ERR_UNSUPPORTED_DIR_IMPORT\x2C\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\x2C\n} = require('internal/errors').codes;\nconst { Module: CJSModule } = require('internal/modules/cjs/loader');\n\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst userConditions = getOptionValue('--conditions');\nconst noAddons = getOptionValue('--no-addons');\nconst addonConditions = noAddons ? [] : ['node-addons'];\n\nconst DEFAULT_CONDITIONS = ObjectFreeze([\n  'node'\x2C\n  'import'\x2C\n  ...addonConditions\x2C\n  ...userConditions\x2C\n]);\n\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\n\n/**\n * @typedef {string | string[] | Record<string\x2C unknown>} Exports\n * @typedef {'module' | 'commonjs'} PackageType\n * @typedef {{\n *   exports?: ExportConfig;\n *   name?: string;\n *   main?: string;\n *   type?: PackageType;\n * }} PackageConfig\n */\n\nconst emittedPackageWarnings = new SafeSet();\n\nfunction emitTrailingSlashPatternDeprecation(match\x2C pjsonUrl\x2C base) {\n  const pjsonPath = fileURLToPath(pjsonUrl);\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match))\n    return;\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(\n    `Use of deprecated trailing slash pattern mapping "${match}" in the ` +\n    `"exports" field module resolution of the package at ${pjsonPath}${\n      base ? ` imported from ${fileURLToPath(base)}` :\n        ''}. Mapping specifiers ending in "/" is no longer supported.`\x2C\n    'DeprecationWarning'\x2C\n    'DEP0155'\n  );\n}\n\n/**\n * @param {URL} url\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n * @param {string} main\n * @returns\n */\nfunction emitLegacyIndexDeprecation(url\x2C packageJSONUrl\x2C base\x2C main) {\n  const format = defaultGetFormat(url);\n  if (format !== 'module')\n    return;\n  const path = fileURLToPath(url);\n  const pkgPath = fileURLToPath(new URL('.'\x2C packageJSONUrl));\n  const basePath = fileURLToPath(base);\n  if (main)\n    process.emitWarning(\n      `Package ${pkgPath} has a "main" field set to ${JSONStringify(main)}\x2C ` +\n      `excluding the full filename and extension to the resolved file at "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${\n        basePath}.\\n Automatic extension resolution of the "main" field is ` +\n      'deprecated for ES modules.'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\n    );\n  else\n    process.emitWarning(\n      `No "main" or "exports" field defined in the package.json for ${pkgPath\n      } resolving the main entry point "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${basePath\n      }.\\nDefault "index" lookups for the main are deprecated for ES modules.`\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\n    );\n}\n\n/**\n * @param {string[]} [conditions]\n * @returns {Set<string>}\n */\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\n    if (!ArrayIsArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE('conditions'\x2C conditions\x2C\n                                      'expected an array');\n    }\n    return new SafeSet(conditions);\n  }\n  return DEFAULT_CONDITIONS_SET;\n}\n\nconst realpathCache = new SafeMap();\nconst packageJSONCache = new SafeMap();  /* string -> PackageConfig */\n\n/**\n * @param {string | URL} path\n * @returns {import('fs').Stats}\n */\nconst tryStatSync =\n  (path) => statSync(path\x2C { throwIfNoEntry: false }) ?? new Stats();\n\n/**\n * @param {string} path\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @returns {PackageConfig}\n */\nfunction getPackageConfig(path\x2C specifier\x2C base) {\n  const existing = packageJSONCache.get(path);\n  if (existing !== undefined) {\n    return existing;\n  }\n  const source = packageJsonReader.read(path).string;\n  if (source === undefined) {\n    const packageConfig = {\n      pjsonPath: path\x2C\n      exists: false\x2C\n      main: undefined\x2C\n      name: undefined\x2C\n      type: 'none'\x2C\n      exports: undefined\x2C\n      imports: undefined\x2C\n    };\n    packageJSONCache.set(path\x2C packageConfig);\n    return packageConfig;\n  }\n\n  let packageJSON;\n  try {\n    packageJSON = JSONParse(source);\n  } catch (error) {\n    throw new ERR_INVALID_PACKAGE_CONFIG(\n      path\x2C\n      (base ? `"${specifier}" from ` : '') + fileURLToPath(base || specifier)\x2C\n      error.message\n    );\n  }\n\n  let { imports\x2C main\x2C name\x2C type } = packageJSON;\n  const { exports } = packageJSON;\n  if (typeof imports !== 'object' || imports === null) imports = undefined;\n  if (typeof main !== 'string') main = undefined;\n  if (typeof name !== 'string') name = undefined;\n  // Ignore unknown types for forwards compatibility\n  if (type !== 'module' && type !== 'commonjs') type = 'none';\n\n  const packageConfig = {\n    pjsonPath: path\x2C\n    exists: true\x2C\n    main\x2C\n    name\x2C\n    type\x2C\n    exports\x2C\n    imports\x2C\n  };\n  packageJSONCache.set(path\x2C packageConfig);\n  return packageConfig;\n}\n\n/**\n * @param {URL | string} resolved\n * @returns {PackageConfig}\n */\nfunction getPackageScopeConfig(resolved) {\n  let packageJSONUrl = new URL('./package.json'\x2C resolved);\n  while (true) {\n    const packageJSONPath = packageJSONUrl.pathname;\n    if (StringPrototypeEndsWith(packageJSONPath\x2C 'node_modules/package.json'))\n      break;\n    const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl)\x2C\n                                           resolved);\n    if (packageConfig.exists) return packageConfig;\n\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL('../package.json'\x2C packageJSONUrl);\n\n    // Terminates at root where ../package.json equals ../../package.json\n    // (can't just check "/package.json" for Windows support).\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;\n  }\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\n  const packageConfig = {\n    pjsonPath: packageJSONPath\x2C\n    exists: false\x2C\n    main: undefined\x2C\n    name: undefined\x2C\n    type: 'none'\x2C\n    exports: undefined\x2C\n    imports: undefined\x2C\n  };\n  packageJSONCache.set(packageJSONPath\x2C packageConfig);\n  return packageConfig;\n}\n\n/**\n * @param {string | URL} url\n * @returns {boolean}\n */\nfunction fileExists(url) {\n  return statSync(url\x2C { throwIfNoEntry: false })?.isFile() ?? false;\n}\n\n/**\n * Legacy CommonJS main resolution:\n * 1. let M = pkg_url + (json main field)\n * 2. TRY(M\x2C M.js\x2C M.json\x2C M.node)\n * 3. TRY(M/index.js\x2C M/index.json\x2C M/index.node)\n * 4. TRY(pkg_url/index.js\x2C pkg_url/index.json\x2C pkg_url/index.node)\n * 5. NOT_FOUND\n * @param {URL} packageJSONUrl\n * @param {PackageConfig} packageConfig\n * @param {string | URL | undefined} base\n * @returns {URL}\n */\nfunction legacyMainResolve(packageJSONUrl\x2C packageConfig\x2C base) {\n  let guess;\n  if (packageConfig.main !== undefined) {\n    // Note: fs check redundances will be handled by Descriptor cache here.\n    if (fileExists(guess = new URL(`./${packageConfig.main}`\x2C\n                                   packageJSONUrl))) {\n      return guess;\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}.js`\x2C\n                                          packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.node`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.js`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.node`\x2C\n                                        packageJSONUrl)));\n    else guess = undefined;\n    if (guess) {\n      emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C\n                                 packageConfig.main);\n      return guess;\n    }\n    // Fallthrough.\n  }\n  if (fileExists(guess = new URL('./index.js'\x2C packageJSONUrl)));\n  // So fs.\n  else if (fileExists(guess = new URL('./index.json'\x2C packageJSONUrl)));\n  else if (fileExists(guess = new URL('./index.node'\x2C packageJSONUrl)));\n  else guess = undefined;\n  if (guess) {\n    emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C packageConfig.main);\n    return guess;\n  }\n  // Not found.\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C fileURLToPath(base));\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensionsWithTryExactName(search) {\n  if (fileExists(search)) return search;\n  return resolveExtensions(search);\n}\n\nconst extensions = ['.js'\x2C '.json'\x2C '.node'\x2C '.mjs'];\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensions(search) {\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const guess = new URL(`${search.pathname}${extension}`\x2C search);\n    if (fileExists(guess)) return guess;\n  }\n  return undefined;\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveDirectoryEntry(search) {\n  const dirPath = fileURLToPath(search);\n  const pkgJsonPath = resolve(dirPath\x2C 'package.json');\n  if (fileExists(pkgJsonPath)) {\n    const pkgJson = packageJsonReader.read(pkgJsonPath);\n    if (pkgJson.containsKeys) {\n      const { main } = JSONParse(pkgJson.string);\n      if (main != null) {\n        const mainUrl = pathToFileURL(resolve(dirPath\x2C main));\n        return resolveExtensionsWithTryExactName(mainUrl);\n      }\n    }\n  }\n  return resolveExtensions(new URL('index'\x2C search));\n}\n\nconst encodedSepRegEx = /%2F|%2C/i;\n/**\n * @param {URL} resolved\n * @param {string | URL | undefined} base\n * @returns {URL | undefined}\n */\nfunction finalizeResolution(resolved\x2C base) {\n  if (RegExpPrototypeTest(encodedSepRegEx\x2C resolved.pathname))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname\x2C 'must not include encoded "/" or "\\\\" characters'\x2C\n      fileURLToPath(base));\n\n  const path = fileURLToPath(resolved);\n  if (getOptionValue('--experimental-specifier-resolution') === 'node') {\n    let file = resolveExtensionsWithTryExactName(resolved);\n    if (file !== undefined) return file;\n    if (!StringPrototypeEndsWith(path\x2C '/')) {\n      file = resolveDirectoryEntry(new URL(`${resolved}/`));\n      if (file !== undefined) return file;\n    } else {\n      return resolveDirectoryEntry(resolved) || resolved;\n    }\n    throw new ERR_MODULE_NOT_FOUND(\n      resolved.pathname\x2C fileURLToPath(base)\x2C 'module');\n  }\n\n  const stats = tryStatSync(StringPrototypeEndsWith(path\x2C '/') ?\n    StringPrototypeSlice(path\x2C -1) : path);\n  if (stats.isDirectory()) {\n    const err = new ERR_UNSUPPORTED_DIR_IMPORT(path\x2C fileURLToPath(base));\n    err.url = String(resolved);\n    throw err;\n  } else if (!stats.isFile()) {\n    throw new ERR_MODULE_NOT_FOUND(\n      path || resolved.pathname\x2C base && fileURLToPath(base)\x2C 'module');\n  }\n\n  return resolved;\n}\n\n/**\n * @param {string} specifier\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n */\nfunction throwImportNotDefined(specifier\x2C packageJSONUrl\x2C base) {\n  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier\x2C packageJSONUrl && fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C\n    fileURLToPath(base));\n}\n\n/**\n * @param {string} specifier\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n */\nfunction throwExportsNotFound(subpath\x2C packageJSONUrl\x2C base) {\n  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C\n    base && fileURLToPath(base));\n}\n\n/**\n *\n * @param {string | URL} subpath\n * @param {URL} packageJSONUrl\n * @param {boolean} internal\n * @param {string | URL | undefined} base\n */\nfunction throwInvalidSubpath(subpath\x2C packageJSONUrl\x2C internal\x2C base) {\n  const reason = `request is not a valid subpath for the "${internal ?\n    'imports' : 'exports'}" resolution of ${fileURLToPath(packageJSONUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(subpath\x2C reason\x2C\n                                         base && fileURLToPath(base));\n}\n\nfunction throwInvalidPackageTarget(\n  subpath\x2C target\x2C packageJSONUrl\x2C internal\x2C base) {\n  if (typeof target === 'object' && target !== null) {\n    target = JSONStringify(target\x2C null\x2C '');\n  } else {\n    target = `${target}`;\n  }\n  throw new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C target\x2C\n    internal\x2C base && fileURLToPath(base));\n}\n\nconst invalidSegmentRegEx = /(^|\\\\|\\/)(\\.\\.?|node_modules)(\\\\|\\/|$)/;\nconst patternRegEx = /\\*/g;\n\nfunction resolvePackageTargetString(\n  target\x2C subpath\x2C match\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C conditions) {\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (!StringPrototypeStartsWith(target\x2C './')) {\n    if (internal && !StringPrototypeStartsWith(target\x2C '../') &&\n        !StringPrototypeStartsWith(target\x2C '/')) {\n      let isURL = false;\n      try {\n        new URL(target);\n        isURL = true;\n      } catch {}\n      if (!isURL) {\n        const exportTarget = pattern ?\n          RegExpPrototypeSymbolReplace(patternRegEx\x2C target\x2C () => subpath) :\n          target + subpath;\n        return packageResolve(exportTarget\x2C packageJSONUrl\x2C conditions);\n      }\n    }\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n  }\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx\x2C StringPrototypeSlice(target\x2C 2)))\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  const resolved = new URL(target\x2C packageJSONUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL('.'\x2C packageJSONUrl).pathname;\n\n  if (!StringPrototypeStartsWith(resolvedPath\x2C packagePath))\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (subpath === '') return resolved;\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx\x2C subpath)) {\n    const request = pattern ?\n      StringPrototypeReplace(match\x2C '*'\x2C () => subpath) : match + subpath;\n    throwInvalidSubpath(request\x2C packageJSONUrl\x2C internal\x2C base);\n  }\n\n  if (pattern)\n    return new URL(RegExpPrototypeSymbolReplace(patternRegEx\x2C resolved.href\x2C\n                                                () => subpath));\n  return new URL(subpath\x2C resolved);\n}\n\n/**\n * @param {string} key\n * @returns {boolean}\n */\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key) return false;\n  return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\n}\n\nfunction resolvePackageTarget(packageJSONUrl\x2C target\x2C subpath\x2C packageSubpath\x2C\n                              base\x2C pattern\x2C internal\x2C conditions) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(\n      target\x2C subpath\x2C packageSubpath\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C\n      conditions);\n  } else if (ArrayIsArray(target)) {\n    if (target.length === 0)\n      return null;\n\n    let lastException;\n    for (let i = 0; i < target.length; i++) {\n      const targetItem = target[i];\n      let resolved;\n      try {\n        resolved = resolvePackageTarget(\n          packageJSONUrl\x2C targetItem\x2C subpath\x2C packageSubpath\x2C base\x2C pattern\x2C\n          internal\x2C conditions);\n      } catch (e) {\n        lastException = e;\n        if (e.code === 'ERR_INVALID_PACKAGE_TARGET')\n          continue;\n        throw e;\n      }\n      if (resolved === undefined)\n        continue;\n      if (resolved === null) {\n        lastException = null;\n        continue;\n      }\n      return resolved;\n    }\n    if (lastException === undefined || lastException === null)\n      return lastException;\n    throw lastException;\n  } else if (typeof target === 'object' && target !== null) {\n    const keys = ObjectGetOwnPropertyNames(target);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          fileURLToPath(packageJSONUrl)\x2C base\x2C\n          '"exports" cannot contain numeric property keys.');\n      }\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key === 'default' || conditions.has(key)) {\n        const conditionalTarget = target[key];\n        const resolved = resolvePackageTarget(\n          packageJSONUrl\x2C conditionalTarget\x2C subpath\x2C packageSubpath\x2C base\x2C\n          pattern\x2C internal\x2C conditions);\n        if (resolved === undefined)\n          continue;\n        return resolved;\n      }\n    }\n    return undefined;\n  } else if (target === null) {\n    return null;\n  }\n  throwInvalidPackageTarget(packageSubpath\x2C target\x2C packageJSONUrl\x2C internal\x2C\n                            base);\n}\n\n/**\n *\n * @param {Exports} exports\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n * @returns\n */\nfunction isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base) {\n  if (typeof exports === 'string' || ArrayIsArray(exports)) return true;\n  if (typeof exports !== 'object' || exports === null) return false;\n\n  const keys = ObjectGetOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  for (let j = 0; j < keys.length; j++) {\n    const key = keys[j];\n    const curIsConditionalSugar = key === '' || key[0] !== '.';\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(\n        fileURLToPath(packageJSONUrl)\x2C base\x2C\n        '"exports" cannot contain some keys starting with \\'.\\' and some not.' +\n        ' The exports object must either be an object of package subpath keys' +\n        ' or an object of main entry condition name keys only.');\n    }\n  }\n  return isConditionalSugar;\n}\n\n/**\n * @param {URL} packageJSONUrl\n * @param {string} packageSubpath\n * @param {PackageConfig} packageConfig\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageExportsResolve(\n  packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base))\n    exports = { '.': exports };\n\n  if (ObjectPrototypeHasOwnProperty(exports\x2C packageSubpath) &&\n      !StringPrototypeIncludes(packageSubpath\x2C '*') &&\n      !StringPrototypeEndsWith(packageSubpath\x2C '/')) {\n    const target = exports[packageSubpath];\n    const resolved = resolvePackageTarget(\n      packageJSONUrl\x2C target\x2C ''\x2C packageSubpath\x2C base\x2C false\x2C false\x2C conditions\n    );\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    return resolved;\n  }\n\n  let bestMatch = '';\n  let bestMatchSubpath;\n  const keys = ObjectGetOwnPropertyNames(exports);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n    if (patternIndex !== -1 &&\n        StringPrototypeStartsWith(packageSubpath\x2C\n                                  StringPrototypeSlice(key\x2C 0\x2C patternIndex))) {\n      // When this reaches EOL\x2C this can throw at the top of the whole function:\n      //\n      // if (StringPrototypeEndsWith(packageSubpath\x2C '/'))\n      //   throwInvalidSubpath(packageSubpath)\n      //\n      // To match "imports" and the spec.\n      if (StringPrototypeEndsWith(packageSubpath\x2C '/'))\n        emitTrailingSlashPatternDeprecation(packageSubpath\x2C packageJSONUrl\x2C\n                                            base);\n      const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n      if (packageSubpath.length >= key.length &&\n          StringPrototypeEndsWith(packageSubpath\x2C patternTrailer) &&\n          patternKeyCompare(bestMatch\x2C key) === 1 &&\n          StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n        bestMatch = key;\n        bestMatchSubpath = StringPrototypeSlice(\n          packageSubpath\x2C patternIndex\x2C\n          packageSubpath.length - patternTrailer.length);\n      }\n    }\n  }\n\n  if (bestMatch) {\n    const target = exports[bestMatch];\n    const resolved = resolvePackageTarget(packageJSONUrl\x2C target\x2C\n                                          bestMatchSubpath\x2C bestMatch\x2C base\x2C\n                                          true\x2C false\x2C conditions);\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    return resolved;\n  }\n\n  throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n}\n\nfunction patternKeyCompare(a\x2C b) {\n  const aPatternIndex = StringPrototypeIndexOf(a\x2C '*');\n  const bPatternIndex = StringPrototypeIndexOf(b\x2C '*');\n  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n  if (baseLenA > baseLenB) return -1;\n  if (baseLenB > baseLenA) return 1;\n  if (aPatternIndex === -1) return 1;\n  if (bPatternIndex === -1) return -1;\n  if (a.length > b.length) return -1;\n  if (b.length > a.length) return 1;\n  return 0;\n}\n\n/**\n * @param {string} name\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns\n */\nfunction packageImportsResolve(name\x2C base\x2C conditions) {\n  if (name === '#' || StringPrototypeStartsWith(name\x2C '#/') ||\n      StringPrototypeEndsWith(name\x2C '/')) {\n    const reason = 'is not a valid internal imports specifier name';\n    throw new ERR_INVALID_MODULE_SPECIFIER(name\x2C reason\x2C fileURLToPath(base));\n  }\n  let packageJSONUrl;\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (ObjectPrototypeHasOwnProperty(imports\x2C name) &&\n          !StringPrototypeIncludes(name\x2C '*')) {\n        const resolved = resolvePackageTarget(\n          packageJSONUrl\x2C imports[name]\x2C ''\x2C name\x2C base\x2C false\x2C true\x2C conditions\n        );\n        if (resolved !== null && resolved !== undefined)\n          return resolved;\n      } else {\n        let bestMatch = '';\n        let bestMatchSubpath;\n        const keys = ObjectGetOwnPropertyNames(imports);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n          if (patternIndex !== -1 &&\n              StringPrototypeStartsWith(name\x2C\n                                        StringPrototypeSlice(key\x2C 0\x2C\n                                                             patternIndex))) {\n            const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n            if (name.length >= key.length &&\n                StringPrototypeEndsWith(name\x2C patternTrailer) &&\n                patternKeyCompare(bestMatch\x2C key) === 1 &&\n                StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n              bestMatch = key;\n              bestMatchSubpath = StringPrototypeSlice(\n                name\x2C patternIndex\x2C name.length - patternTrailer.length);\n            }\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const resolved = resolvePackageTarget(packageJSONUrl\x2C target\x2C\n                                                bestMatchSubpath\x2C bestMatch\x2C\n                                                base\x2C true\x2C true\x2C conditions);\n          if (resolved !== null && resolved !== undefined)\n            return resolved;\n        }\n      }\n    }\n  }\n  throwImportNotDefined(name\x2C packageJSONUrl\x2C base);\n}\n\n/**\n * @param {URL} url\n * @returns {PackageType}\n */\nfunction getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url);\n  return packageConfig.type;\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @returns {{ packageName: string\x2C packageSubpath: string\x2C isScoped: boolean }}\n */\nfunction parsePackageName(specifier\x2C base) {\n  let separatorIndex = StringPrototypeIndexOf(specifier\x2C '/');\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === '@') {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = StringPrototypeIndexOf(\n        specifier\x2C '/'\x2C separatorIndex + 1);\n    }\n  }\n\n  const packageName = separatorIndex === -1 ?\n    specifier : StringPrototypeSlice(specifier\x2C 0\x2C separatorIndex);\n\n  // Package name cannot have leading . and cannot have percent-encoding or\n  // separators.\n  for (let i = 0; i < packageName.length; i++) {\n    if (packageName[i] === '%' || packageName[i] === '\\\\') {\n      validPackageName = false;\n      break;\n    }\n  }\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier\x2C 'is not a valid package name'\x2C fileURLToPath(base));\n  }\n\n  const packageSubpath = '.' + (separatorIndex === -1 ? '' :\n    StringPrototypeSlice(specifier\x2C separatorIndex));\n\n  return { packageName\x2C packageSubpath\x2C isScoped };\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageResolve(specifier\x2C base\x2C conditions) {\n  const { packageName\x2C packageSubpath\x2C isScoped } =\n    parsePackageName(specifier\x2C base);\n\n  // ResolveSelf\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    if (packageConfig.name === packageName &&\n        packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions\n      );\n    }\n  }\n\n  let packageJSONUrl =\n    new URL('./node_modules/' + packageName + '/package.json'\x2C base);\n  let packageJSONPath = fileURLToPath(packageJSONUrl);\n  let lastPath;\n  do {\n    const stat = tryStatSync(StringPrototypeSlice(packageJSONPath\x2C 0\x2C\n                                                  packageJSONPath.length - 13));\n    if (!stat.isDirectory()) {\n      lastPath = packageJSONPath;\n      packageJSONUrl = new URL((isScoped ?\n        '../../../../node_modules/' : '../../../node_modules/') +\n        packageName + '/package.json'\x2C packageJSONUrl);\n      packageJSONPath = fileURLToPath(packageJSONUrl);\n      continue;\n    }\n\n    // Package match.\n    const packageConfig = getPackageConfig(packageJSONPath\x2C specifier\x2C base);\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null)\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions\n      );\n    if (packageSubpath === '.')\n      return legacyMainResolve(packageJSONUrl\x2C packageConfig\x2C base);\n    return new URL(packageSubpath\x2C packageJSONUrl);\n    // Cross-platform root check.\n  } while (packageJSONPath.length !== lastPath.length);\n\n  // eslint can't handle the above code.\n  // eslint-disable-next-line no-unreachable\n  throw new ERR_MODULE_NOT_FOUND(packageName\x2C fileURLToPath(base));\n}\n\n/**\n * @param {string} specifier\n * @returns {boolean}\n */\nfunction isBareSpecifier(specifier) {\n  return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\n}\n\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') return true;\n    if (specifier[1] === '.') {\n      if (specifier.length === 2 || specifier[2] === '/') return true;\n    }\n  }\n  return false;\n}\n\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') return false;\n  if (specifier[0] === '/') return true;\n  return isRelativeSpecifier(specifier);\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction moduleResolve(specifier\x2C base\x2C conditions) {\n  // Order swapped from spec for minor perf gain.\n  // Ok since relative URLs cannot parse as URLs.\n  let resolved;\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL(specifier\x2C base);\n  } else if (specifier[0] === '#') {\n    resolved = packageImportsResolve(specifier\x2C base\x2C conditions);\n  } else {\n    try {\n      resolved = new URL(specifier);\n    } catch {\n      resolved = packageResolve(specifier\x2C base\x2C conditions);\n    }\n  }\n  return finalizeResolution(resolved\x2C base);\n}\n\n/**\n * Try to resolve an import as a CommonJS module\n * @param {string} specifier\n * @param {string} parentURL\n * @returns {boolean|string}\n */\nfunction resolveAsCommonJS(specifier\x2C parentURL) {\n  try {\n    const parent = fileURLToPath(parentURL);\n    const tmpModule = new CJSModule(parent\x2C null);\n    tmpModule.paths = CJSModule._nodeModulePaths(parent);\n\n    let found = CJSModule._resolveFilename(specifier\x2C tmpModule\x2C false);\n\n    // If it is a relative specifier return the relative path\n    // to the parent\n    if (isRelativeSpecifier(specifier)) {\n      found = relative(parent\x2C found);\n      // Add '.separator if the path does not start with '..separator'\n      // This should be a safe assumption because when loading\n      // esm modules there should be always a file specified so\n      // there should not be a specifier like '..' or '.'\n      if (!StringPrototypeStartsWith(found\x2C `..${sep}`)) {\n        found = `.${sep}${found}`;\n      }\n    } else if (isBareSpecifier(specifier)) {\n      // If it is a bare specifier return the relative path within the\n      // module\n      const pkg = StringPrototypeSplit(specifier\x2C '/')[0];\n      const index = StringPrototypeIndexOf(found\x2C pkg);\n      if (index !== -1) {\n        found = StringPrototypeSlice(found\x2C index);\n      }\n    }\n    // Normalize the path separator to give a valid suggestion\n    // on Windows\n    if (process.platform === 'win32') {\n      found = RegExpPrototypeSymbolReplace(new RegExp(`\\\\${sep}`\x2C 'g')\x2C\n                                           found\x2C '/');\n    }\n    return found;\n  } catch {\n    return false;\n  }\n}\n\nfunction defaultResolve(specifier\x2C context = {}\x2C defaultResolveUnused) {\n  let { parentURL\x2C conditions } = context;\n  if (parentURL && policy?.manifest) {\n    const redirects = policy.manifest.getDependencyMapper(parentURL);\n    if (redirects) {\n      const { resolve\x2C reaction } = redirects;\n      const destination = resolve(specifier\x2C new SafeSet(conditions));\n      let missing = true;\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        return { url: href };\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          parentURL\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C '))\n        );\n      }\n    }\n  }\n  let parsed;\n  try {\n    parsed = new URL(specifier);\n    if (parsed.protocol === 'data:') {\n      return {\n        url: specifier\n      };\n    }\n  } catch {}\n  if (parsed && parsed.protocol === 'node:')\n    return { url: specifier };\n  if (parsed && parsed.protocol !== 'file:' && parsed.protocol !== 'data:')\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);\n  if (NativeModule.canBeRequiredByUsers(specifier)) {\n    return {\n      url: 'node:' + specifier\n    };\n  }\n  if (parentURL && StringPrototypeStartsWith(parentURL\x2C 'data:')) {\n    // This is gonna blow up\x2C we want the error\n    new URL(specifier\x2C parentURL);\n  }\n\n  const isMain = parentURL === undefined;\n  if (isMain) {\n    parentURL = pathToFileURL(`${process.cwd()}/`).href;\n\n    // This is the initial entry point to the program\x2C and --input-type has\n    // been passed as an option; but --input-type can only be used with\n    // --eval\x2C --print or STDIN string input. It is not allowed with file\n    // input\x2C to avoid user confusion over how expansive the effect of the\n    // flag should be (i.e. entry point only\x2C package scope surrounding the\n    // entry point\x2C etc.).\n    if (typeFlag)\n      throw new ERR_INPUT_TYPE_NOT_ALLOWED();\n  }\n\n  conditions = getConditionsSet(conditions);\n  let url;\n  try {\n    url = moduleResolve(specifier\x2C parentURL\x2C conditions);\n  } catch (error) {\n    // Try to give the user a hint of what would have been the\n    // resolved CommonJS module\n    if (error.code === 'ERR_MODULE_NOT_FOUND' ||\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\n      if (StringPrototypeStartsWith(specifier\x2C 'file://')) {\n        specifier = fileURLToPath(specifier);\n      }\n      const found = resolveAsCommonJS(specifier\x2C parentURL);\n      if (found) {\n        // Modify the stack and message string to include the hint\n        const lines = StringPrototypeSplit(error.stack\x2C '\\n');\n        const hint = `Did you mean to import ${found}?`;\n        error.stack =\n          ArrayPrototypeShift(lines) + '\\n' +\n          hint + '\\n' +\n          ArrayPrototypeJoin(lines\x2C '\\n');\n        error.message += `\\n${hint}`;\n      }\n    }\n    throw error;\n  }\n\n  if (isMain ? !preserveSymlinksMain : !preserveSymlinks) {\n    const urlPath = fileURLToPath(url);\n    const real = realpathSync(urlPath\x2C {\n      [internalFS.realpathCacheKey]: realpathCache\n    });\n    const old = url;\n    url = pathToFileURL(\n      real + (StringPrototypeEndsWith(urlPath\x2C sep) ? '/' : ''));\n    url.search = old.search;\n    url.hash = old.hash;\n  }\n\n  return { url: `${url}` };\n}\n\nmodule.exports = {\n  DEFAULT_CONDITIONS\x2C\n  defaultResolve\x2C\n  encodedSepRegEx\x2C\n  getPackageScopeConfig\x2C\n  getPackageType\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\n};\n\n// cycle\nconst { defaultGetFormat } = require('internal/modules/esm/get_format');\n
code-source-info,0x24b32696eb96,106,0,34977,C0O0C4O34977,,
code-creation,Function,10,72702,0x24b32696fade,1074, node:internal/modules/esm/resolve:1:1,0x24b32696eb10,~
tick,0x10c46357d,72737,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b326969445,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
tick,0x10c6776e3,72778,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b326969445,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
tick,0x7fff202fa797,72790,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b326969445,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-source-info,0x24b32696fade,106,0,34977,C0O0C373O25C379O41C385O63C391O86C397O99C403O116C408O132C414O161C420O194C426O204C432O236C438O259C443O270C449O281C455O291C461O318C467O345C473O371C479O401C485O427C491O451C497O475C503O538C506O538C510O538C512O593C515O593C520O576C526O681C529O681C534O642C540O658C546O670C552O723C555O723C560O704C566O818C572O818C581O862C588O818C590O942C593O942C598O915C604O920C610O930C616O984C622O984C626O984C628O1052C634O1052C638O1052C640O1113C646O1113C650O1113C652O1191C655O1191C660O1153C666O1158C672O1173C678O1565C681O1565C686O1591C691O1226C697O1256C703O1281C709O1313C715O1343C721O1373C727O1408C733O1432C739O1466C745O1499C751O1529C757O1629C760O1629C765O1615C771O1696C774O1696C778O1696C780O1768C786O1768C791O1817C797O1817C802O1872C813O1933C820O1975C821O1975C875O1997C926O1933C930O1933C932O2049C940O2049C945O2049C947O2366C950O2366C955O2366C957O4635C959O4635C964O4635C966O4675C968O4675C973O4675C975O4815C979O4815C981O10126C985O10126C987O11100C991O11100C993O13992C997O13992C999O14055C1003O14055C1005O34721C1012O34742C1018O34764C1024O34782C1030O34801C1036O34826C1042O34844C1048O34869C1054O34736C1058O34933C1061O34933C1066O34912C1073O34976,,
code-creation,Eval,10,73546,0x24b326972bbe,5, node:internal/modules/esm/get_format:1:1,0x24b326972998,~
script-source,107,node:internal/modules/esm/get_format,'use strict';\nconst {\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeExec\x2C\n} = primordials;\nconst { extname } = require('path');\nconst { getOptionValue } = require('internal/options');\n\nconst experimentalJsonModules = getOptionValue('--experimental-json-modules');\nconst experimentalSpecifierResolution =\n  getOptionValue('--experimental-specifier-resolution');\nconst experimentalWasmModules = getOptionValue('--experimental-wasm-modules');\nconst { getPackageType } = require('internal/modules/esm/resolve');\nconst { URL\x2C fileURLToPath } = require('internal/url');\nconst { ERR_UNKNOWN_FILE_EXTENSION } = require('internal/errors').codes;\n\nconst extensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'module'\x2C\n  '.mjs': 'module'\n};\n\nconst legacyExtensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'commonjs'\x2C\n  '.json': 'commonjs'\x2C\n  '.mjs': 'module'\x2C\n  '.node': 'commonjs'\n};\n\nif (experimentalWasmModules)\n  extensionFormatMap['.wasm'] = legacyExtensionFormatMap['.wasm'] = 'wasm';\n\nif (experimentalJsonModules)\n  extensionFormatMap['.json'] = legacyExtensionFormatMap['.json'] = 'json';\n\nconst protocolHandlers = ObjectAssign(ObjectCreate(null)\x2C {\n  'data:'(parsed) {\n    const { 1: mime } = RegExpPrototypeExec(\n      /^([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n      parsed.pathname\x2C\n    ) || [\x2C null];\n    const format = ({\n      '__proto__': null\x2C\n      'text/javascript': 'module'\x2C\n      'application/json': experimentalJsonModules ? 'json' : null\x2C\n      'application/wasm': experimentalWasmModules ? 'wasm' : null\n    })[mime] || null;\n\n    return format;\n  }\x2C\n  'file:'(parsed\x2C url) {\n    const ext = extname(parsed.pathname);\n    let format;\n\n    if (ext === '.js') {\n      format = getPackageType(parsed.href) === 'module' ? 'module' : 'commonjs';\n    } else {\n      format = extensionFormatMap[ext];\n    }\n    if (!format) {\n      if (experimentalSpecifierResolution === 'node') {\n        process.emitWarning(\n          'The Node.js specifier resolution in ESM is experimental.'\x2C\n          'ExperimentalWarning');\n        format = legacyExtensionFormatMap[ext];\n      } else {\n        throw new ERR_UNKNOWN_FILE_EXTENSION(ext\x2C fileURLToPath(url));\n      }\n    }\n\n    return format || null;\n  }\x2C\n  'node:'() { return 'builtin'; }\x2C\n});\n\nfunction defaultGetFormat(url\x2C context) {\n  const parsed = new URL(url);\n\n  return ObjectPrototypeHasOwnProperty(protocolHandlers\x2C parsed.protocol) ?\n    protocolHandlers[parsed.protocol](parsed\x2C url) :\n    null;\n}\n\nmodule.exports = {\n  defaultGetFormat\x2C\n  extensionFormatMap\x2C\n  legacyExtensionFormatMap\x2C\n};\n
code-source-info,0x24b326972bbe,107,0,2630,C0O0C4O2630,,
code-creation,Function,10,73795,0x24b326972fee,314, node:internal/modules/esm/get_format:1:1,0x24b326972b38,~
code-source-info,0x24b326972fee,107,0,2630,C0O0C53O24C58O40C63O56C69O89C75O147C78O147C83O135C89O191C92O191C97O172C102O253C105O253C109O253C111O342C114O342C118O342C120O429C123O429C127O429C129O503C132O503C137O484C143O575C146O575C151O552C157O557C163O639C166O639C171O665C176O608C182O701C186O701C188O821C192O821C194O956C198O987C207O1051C213O1015C217O1062C221O1093C230O1157C236O1121C240O1193C242O1206C252O1230C260O1646C268O2284C276O1193C281O1193C283O2538C290O2559C296O2579C302O2601C308O2553C313O2629,,
tick,0x10c265599,73898,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b32696ff03,0x24b357dbe2b5,0x24b357dbd585,0x24b326969445,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Eval,10,74000,0x24b32697397e,5, node:internal/modules/esm/load:1:1,0x24b326973808,~
script-source,108,node:internal/modules/esm/load,'use strict';\n\nconst { defaultGetFormat } = require('internal/modules/esm/get_format');\nconst { defaultGetSource } = require('internal/modules/esm/get_source');\nconst { translators } = require('internal/modules/esm/translators');\n\nasync function defaultLoad(url\x2C context) {\n  let {\n    format\x2C\n    source\x2C\n  } = context;\n\n  if (!translators.has(format)) format = defaultGetFormat(url);\n\n  if (\n    format === 'builtin' ||\n    format === 'commonjs'\n  ) {\n    source = null;\n  } else if (source == null) {\n    source = await defaultGetSource(url\x2C { format });\n  }\n\n  return {\n    format\x2C\n    source\x2C\n  };\n}\n\nmodule.exports = {\n  defaultLoad\x2C\n};\n
code-source-info,0x24b32697397e,108,0,643,C0O0C4O643,,
code-creation,Function,10,74071,0x24b326973ac6,80, node:internal/modules/esm/load:1:1,0x24b3269738f8,~
code-source-info,0x24b326973ac6,108,0,643,C0O0C19O44C22O44C27O23C33O117C36O117C41O96C47O185C50O185C55O169C61O606C68O627C74O621C79O642,,
code-creation,Eval,10,74208,0x24b32697402e,5, node:internal/modules/esm/get_source:1:1,0x24b326973e58,~
script-source,109,node:internal/modules/esm/get_source,'use strict';\n\nconst {\n  RegExpPrototypeExec\x2C\n  decodeURIComponent\x2C\n} = primordials;\nconst { getOptionValue } = require('internal/options');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\n\nconst { Buffer } = require('buffer');\n\nconst fs = require('internal/fs/promises').exports;\nconst { URL } = require('internal/url');\nconst {\n  ERR_INVALID_URL\x2C\n  ERR_INVALID_URL_SCHEME\x2C\n} = require('internal/errors').codes;\nconst readFileAsync = fs.readFile;\n\nconst DATA_URL_PATTERN = /^[^/]+\\/[^\x2C;]+(?:[^\x2C]*?)(;base64)?\x2C([\\s\\S]*)$/;\n\nasync function defaultGetSource(url\x2C { format } = {}\x2C defaultGetSource) {\n  const parsed = new URL(url);\n  let source;\n  if (parsed.protocol === 'file:') {\n    source = await readFileAsync(parsed);\n  } else if (parsed.protocol === 'data:') {\n    const match = RegExpPrototypeExec(DATA_URL_PATTERN\x2C parsed.pathname);\n    if (!match) {\n      throw new ERR_INVALID_URL(url);\n    }\n    const { 1: base64\x2C 2: body } = match;\n    source = Buffer.from(decodeURIComponent(body)\x2C base64 ? 'base64' : 'utf8');\n  } else {\n    throw new ERR_INVALID_URL_SCHEME(['file'\x2C 'data']);\n  }\n  if (policy?.manifest) {\n    policy.manifest.assertIntegrity(parsed\x2C source);\n  }\n  return source;\n}\nexports.defaultGetSource = defaultGetSource;\n
code-source-info,0x24b32697402e,109,0,1349,C0O0C4O1349,,
code-creation,Function,10,74341,0x24b32697419e,169, node:internal/modules/esm/get_source:1:1,0x24b326973fa8,~
code-source-info,0x24b32697419e,109,0,1349,C0O0C37O25C43O48C49O112C52O112C57O93C62O207C65O207C74O251C81O207C83O316C86O316C91O305C97O347C100O347C105O378C110O404C113O404C118O396C124O486C127O486C132O512C137O439C143O458C149O545C153O542C155O581C159O581C161O1304C163O1329C168O1348,,
tick,0x10c65849d,75040,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Eval,10,75113,0x24b326975766,5, node:internal/fs/promises:1:1,0x24b326974f58,~
script-source,110,node:internal/fs/promises,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  Error\x2C\n  MathMax\x2C\n  MathMin\x2C\n  NumberIsSafeInteger\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  SafeArrayIterator\x2C\n  SafePromisePrototypeFinally\x2C\n  Symbol\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  F_OK\x2C\n  O_SYMLINK\x2C\n  O_WRONLY\x2C\n  S_IFMT\x2C\n  S_IFREG\n} = internalBinding('constants').fs;\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\n\nconst {\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_STATE\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n  }\x2C\n  AbortError\x2C\n  aggregateTwoErrors\x2C\n} = require('internal/errors');\nconst { isArrayBufferView } = require('internal/util/types');\nconst { rimrafPromises } = require('internal/fs/rimraf');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  copyObject\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getStatsFromBinding\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validateRmOptions\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\x2C\n} = require('internal/fs/utils');\nconst { opendir } = require('internal/fs/dir');\nconst {\n  parseFileMode\x2C\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst { lazyDOMException\x2C promisify } = require('internal/util');\nconst { EventEmitterMixin } = require('internal/event_target');\nconst { watch } = require('internal/fs/watchers');\nconst { isIterable } = require('internal/streams/utils');\nconst assert = require('internal/assert');\n\nconst kHandle = Symbol('kHandle');\nconst kFd = Symbol('kFd');\nconst kRefs = Symbol('kRefs');\nconst kClosePromise = Symbol('kClosePromise');\nconst kCloseResolve = Symbol('kCloseResolve');\nconst kCloseReject = Symbol('kCloseReject');\nconst kRef = Symbol('kRef');\nconst kUnref = Symbol('kUnref');\nconst kLocked = Symbol('kLocked');\n\nconst { kUsePromises } = binding;\nconst {\n  JSTransferable\x2C kDeserialize\x2C kTransfer\x2C kTransferList\n} = require('internal/worker/js_transferable');\n\nconst {\n  newReadableStreamFromStreamBase\x2C\n} = require('internal/webstreams/adapters');\n\nconst {\n  readableStreamCancel\x2C\n} = require('internal/webstreams/readablestream');\n\nconst getDirectoryEntriesPromise = promisify(getDirents);\nconst validateRmOptionsPromise = promisify(validateRmOptions);\n\nlet cpPromises;\nfunction lazyLoadCpPromises() {\n  return cpPromises ??= require('internal/fs/cp/cp').cpFn;\n}\n\n// Lazy loaded to avoid circular dependency.\nlet fsStreams;\nfunction lazyFsStreams() {\n  return fsStreams ??= require('internal/fs/streams');\n}\n\nclass FileHandle extends EventEmitterMixin(JSTransferable) {\n  /**\n   * @param {InternalFSBinding.FileHandle | undefined} filehandle\n   */\n  constructor(filehandle) {\n    super();\n    this[kHandle] = filehandle;\n    this[kFd] = filehandle ? filehandle.fd : -1;\n\n    this[kRefs] = 1;\n    this[kClosePromise] = null;\n  }\n\n  getAsyncId() {\n    return this[kHandle].getAsyncId();\n  }\n\n  get fd() {\n    return this[kFd];\n  }\n\n  appendFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  chmod(mode) {\n    return fsCall(fchmod\x2C this\x2C mode);\n  }\n\n  chown(uid\x2C gid) {\n    return fsCall(fchown\x2C this\x2C uid\x2C gid);\n  }\n\n  datasync() {\n    return fsCall(fdatasync\x2C this);\n  }\n\n  sync() {\n    return fsCall(fsync\x2C this);\n  }\n\n  read(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(read\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  readv(buffers\x2C position) {\n    return fsCall(readv\x2C this\x2C buffers\x2C position);\n  }\n\n  readFile(options) {\n    return fsCall(readFile\x2C this\x2C options);\n  }\n\n  stat(options) {\n    return fsCall(fstat\x2C this\x2C options);\n  }\n\n  truncate(len = 0) {\n    return fsCall(ftruncate\x2C this\x2C len);\n  }\n\n  utimes(atime\x2C mtime) {\n    return fsCall(futimes\x2C this\x2C atime\x2C mtime);\n  }\n\n  write(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(write\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  writev(buffers\x2C position) {\n    return fsCall(writev\x2C this\x2C buffers\x2C position);\n  }\n\n  writeFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  close = () => {\n    if (this[kFd] === -1) {\n      return PromiseResolve();\n    }\n\n    if (this[kClosePromise]) {\n      return this[kClosePromise];\n    }\n\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        this[kHandle].close()\x2C\n        () => { this[kClosePromise] = undefined; }\n      );\n    } else {\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        new Promise((resolve\x2C reject) => {\n          this[kCloseResolve] = resolve;\n          this[kCloseReject] = reject;\n        })\x2C () => {\n          this[kClosePromise] = undefined;\n          this[kCloseReject] = undefined;\n          this[kCloseResolve] = undefined;\n        }\n      );\n    }\n\n    this.emit('close');\n    return this[kClosePromise];\n  }\n\n  /**\n   * @typedef {import('../webstreams/readablestream').ReadableStream\n   * } ReadableStream\n   * @returns {ReadableStream}\n   */\n  readableWebStream() {\n    if (this[kFd] === -1)\n      throw new ERR_INVALID_STATE('The FileHandle is closed');\n    if (this[kClosePromise])\n      throw new ERR_INVALID_STATE('The FileHandle is closing');\n    if (this[kLocked])\n      throw new ERR_INVALID_STATE('The FileHandle is locked');\n    this[kLocked] = true;\n\n    const readable = newReadableStreamFromStreamBase(\n      this[kHandle]\x2C\n      undefined\x2C\n      { ondone: () => this[kUnref]() });\n\n    this[kRef]();\n    this.once('close'\x2C () => {\n      readableStreamCancel(readable);\n    });\n\n    return readable;\n  }\n\n  /**\n   * @typedef {import('./streams').ReadStream\n   * } ReadStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   end?: number;\n   *   highWaterMark?: number;\n   *   }} [options]\n   * @returns {ReadStream}\n   */\n  createReadStream(options = undefined) {\n    const { ReadStream } = lazyFsStreams();\n    return new ReadStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  /**\n   * @typedef {import('./streams').WriteStream\n   * } WriteStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   }} [options]\n   * @returns {WriteStream}\n   */\n  createWriteStream(options = undefined) {\n    const { WriteStream } = lazyFsStreams();\n    return new WriteStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  [kTransfer]() {\n    if (this[kClosePromise] || this[kRefs] > 1) {\n      throw lazyDOMException('Cannot transfer FileHandle while in use'\x2C\n                             'DataCloneError');\n    }\n\n    const handle = this[kHandle];\n    this[kFd] = -1;\n    this[kHandle] = null;\n    this[kRefs] = 0;\n\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/fs/promises:FileHandle'\n    };\n  }\n\n  [kTransferList]() {\n    return [ this[kHandle] ];\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kFd] = handle.fd;\n  }\n\n  [kRef]() {\n    this[kRefs]++;\n  }\n\n  [kUnref]() {\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      PromisePrototypeThen(\n        this[kHandle].close()\x2C\n        this[kCloseResolve]\x2C\n        this[kCloseReject]\n      );\n    }\n  }\n}\n\nasync function handleFdClose(fileOpPromise\x2C closeFunc) {\n  return PromisePrototypeThen(\n    fileOpPromise\x2C\n    (result) => PromisePrototypeThen(closeFunc()\x2C () => result)\x2C\n    (opError) =>\n      PromisePrototypeThen(\n        closeFunc()\x2C\n        () => PromiseReject(opError)\x2C\n        (closeError) => PromiseReject(aggregateTwoErrors(closeError\x2C opError))\n      )\n  );\n}\n\nasync function fsCall(fn\x2C handle\x2C ...args) {\n  assert(handle[kRefs] !== undefined\x2C\n         'handle must be an instance of FileHandle');\n\n  if (handle.fd === -1) {\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error('file closed');\n    err.code = 'EBADF';\n    err.syscall = fn.name;\n    throw err;\n  }\n\n  try {\n    handle[kRef]();\n    return await fn(handle\x2C ...new SafeArrayIterator(args));\n  } finally {\n    handle[kUnref]();\n  }\n}\n\nfunction checkAborted(signal) {\n  if (signal?.aborted)\n    throw new AbortError();\n}\n\nasync function writeFileHandle(filehandle\x2C data\x2C signal\x2C encoding) {\n  checkAborted(signal);\n  if (isCustomIterable(data)) {\n    for await (const buf of data) {\n      checkAborted(signal);\n      const toWrite =\n        isArrayBufferView(buf) ? buf : Buffer.from(buf\x2C encoding || 'utf8');\n      let remaining = toWrite.byteLength;\n      while (remaining > 0) {\n        const writeSize = MathMin(kWriteFileMaxChunkSize\x2C remaining);\n        const { bytesWritten } = await write(\n          filehandle\x2C toWrite\x2C toWrite.byteLength - remaining\x2C writeSize);\n        remaining -= bytesWritten;\n        checkAborted(signal);\n      }\n    }\n    return;\n  }\n  data = new Uint8Array(data.buffer\x2C data.byteOffset\x2C data.byteLength);\n  let remaining = data.byteLength;\n  if (remaining === 0) return;\n  do {\n    checkAborted(signal);\n    const { bytesWritten } =\n      await write(filehandle\x2C data\x2C 0\x2C\n                  MathMin(kWriteFileMaxChunkSize\x2C data.byteLength));\n    remaining -= bytesWritten;\n    data = new Uint8Array(\n      data.buffer\x2C\n      data.byteOffset + bytesWritten\x2C\n      data.byteLength - bytesWritten\n    );\n  } while (remaining > 0);\n}\n\nasync function readFileHandle(filehandle\x2C options) {\n  const signal = options?.signal;\n\n  checkAborted(signal);\n\n  const statFields = await binding.fstat(filehandle.fd\x2C false\x2C kUsePromises);\n\n  checkAborted(signal);\n\n  let size;\n  if ((statFields[1/* mode */] & S_IFMT) === S_IFREG) {\n    size = statFields[8/* size */];\n  } else {\n    size = 0;\n  }\n\n  if (size > kIoMaxLength)\n    throw new ERR_FS_FILE_TOO_LARGE(size);\n\n  let endOfFile = false;\n  let totalRead = 0;\n  const noSize = size === 0;\n  const buffers = [];\n  const fullBuffer = noSize ? undefined : Buffer.allocUnsafeSlow(size);\n  do {\n    checkAborted(signal);\n    let buffer;\n    let offset;\n    let length;\n    if (noSize) {\n      buffer = Buffer.allocUnsafeSlow(kReadFileUnknownBufferLength);\n      offset = 0;\n      length = kReadFileUnknownBufferLength;\n    } else {\n      buffer = fullBuffer;\n      offset = totalRead;\n      length = MathMin(size - totalRead\x2C kReadFileBufferLength);\n    }\n\n    const bytesRead = (await binding.read(filehandle.fd\x2C buffer\x2C offset\x2C\n                                          length\x2C -1\x2C kUsePromises)) || 0;\n    totalRead += bytesRead;\n    endOfFile = bytesRead === 0 || totalRead === size;\n    if (noSize && bytesRead > 0) {\n      const isBufferFull = bytesRead === kReadFileUnknownBufferLength;\n      const chunkBuffer = isBufferFull ? buffer : buffer.slice(0\x2C bytesRead);\n      ArrayPrototypePush(buffers\x2C chunkBuffer);\n    }\n  } while (!endOfFile);\n\n  let result;\n  if (size > 0) {\n    result = totalRead === size ? fullBuffer : fullBuffer.slice(0\x2C totalRead);\n  } else {\n    result = buffers.length === 1 ? buffers[0] : Buffer.concat(buffers\x2C\n                                                               totalRead);\n  }\n\n  return options.encoding ? result.toString(options.encoding) : result;\n}\n\n// All of the functions are defined as async in order to ensure that errors\n// thrown cause promise rejections rather than being thrown synchronously.\nasync function access(path\x2C mode = F_OK) {\n  path = getValidatedPath(path);\n\n  mode = getValidMode(mode\x2C 'access');\n  return binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C\n                        kUsePromises);\n}\n\nasync function cp(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  return lazyLoadCpPromises()(src\x2C dest\x2C options);\n}\n\nasync function copyFile(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n  mode = getValidMode(mode\x2C 'copyFile');\n  return binding.copyFile(pathModule.toNamespacedPath(src)\x2C\n                          pathModule.toNamespacedPath(dest)\x2C\n                          mode\x2C\n                          kUsePromises);\n}\n\n// Note that unlike fs.open() which uses numeric file descriptors\x2C\n// fsPromises.open() uses the fs.FileHandle class.\nasync function open(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  return new FileHandle(\n    await binding.openFileHandle(pathModule.toNamespacedPath(path)\x2C\n                                 flagsNumber\x2C mode\x2C kUsePromises));\n}\n\nasync function read(handle\x2C bufferOrOptions\x2C offset\x2C length\x2C position) {\n  let buffer = bufferOrOptions;\n  if (!isArrayBufferView(buffer)) {\n    if (bufferOrOptions === undefined) {\n      bufferOrOptions = {};\n    }\n    if (bufferOrOptions.buffer) {\n      buffer = bufferOrOptions.buffer;\n      validateBuffer(buffer);\n    } else {\n      buffer = Buffer.alloc(16384);\n    }\n    offset = bufferOrOptions.offset || 0;\n    length = buffer.byteLength;\n    position = bufferOrOptions.position || null;\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0)\n    return { bytesRead: length\x2C buffer };\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (!NumberIsSafeInteger(position))\n    position = -1;\n\n  const bytesRead = (await binding.read(handle.fd\x2C buffer\x2C offset\x2C length\x2C\n                                        position\x2C kUsePromises)) || 0;\n\n  return { bytesRead\x2C buffer };\n}\n\nasync function readv(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const bytesRead = (await binding.readBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                               kUsePromises)) || 0;\n  return { bytesRead\x2C buffers };\n}\n\nasync function write(handle\x2C buffer\x2C offset\x2C length\x2C position) {\n  if (buffer?.byteLength === 0)\n    return { bytesWritten: 0\x2C buffer };\n\n  if (isArrayBufferView(buffer)) {\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    const bytesWritten =\n      (await binding.writeBuffer(handle.fd\x2C buffer\x2C offset\x2C\n                                 length\x2C position\x2C kUsePromises)) || 0;\n    return { bytesWritten\x2C buffer };\n  }\n\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n  validateEncoding(buffer\x2C length);\n  const bytesWritten = (await binding.writeString(handle.fd\x2C buffer\x2C offset\x2C\n                                                  length\x2C kUsePromises)) || 0;\n  return { bytesWritten\x2C buffer };\n}\n\nasync function writev(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const bytesWritten = (await binding.writeBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                                   kUsePromises)) || 0;\n  return { bytesWritten\x2C buffers };\n}\n\nasync function rename(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                        pathModule.toNamespacedPath(newPath)\x2C\n                        kUsePromises);\n}\n\nasync function truncate(path\x2C len = 0) {\n  const fd = await open(path\x2C 'r+');\n  return handleFdClose(ftruncate(fd\x2C len)\x2C fd.close);\n}\n\nasync function ftruncate(handle\x2C len = 0) {\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  return binding.ftruncate(handle.fd\x2C len\x2C kUsePromises);\n}\n\nasync function rm(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = await validateRmOptionsPromise(path\x2C options\x2C false);\n  return rimrafPromises(path\x2C options);\n}\n\nasync function rmdir(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = validateRmdirOptions(options);\n\n  if (options.recursive) {\n    emitRecursiveRmdirWarning();\n    const stats = await stat(path);\n    if (stats.isDirectory()) {\n      return rimrafPromises(path\x2C options);\n    }\n  }\n\n  return binding.rmdir(path\x2C kUsePromises);\n}\n\nasync function fdatasync(handle) {\n  return binding.fdatasync(handle.fd\x2C kUsePromises);\n}\n\nasync function fsync(handle) {\n  return binding.fsync(handle.fd\x2C kUsePromises);\n}\n\nasync function mkdir(path\x2C options) {\n  if (typeof options === 'number' || typeof options === 'string') {\n    options = { mode: options };\n  }\n  const {\n    recursive = false\x2C\n    mode = 0o777\n  } = options || {};\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  return binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                       parseFileMode(mode\x2C 'mode'\x2C 0o777)\x2C recursive\x2C\n                       kUsePromises);\n}\n\nasync function readdir(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const result = await binding.readdir(pathModule.toNamespacedPath(path)\x2C\n                                       options.encoding\x2C\n                                       !!options.withFileTypes\x2C\n                                       kUsePromises);\n  return options.withFileTypes ?\n    getDirectoryEntriesPromise(path\x2C result) :\n    result;\n}\n\nasync function readlink(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  return binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                          options.encoding\x2C kUsePromises);\n}\n\nasync function symlink(target\x2C path\x2C type_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  return binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                         pathModule.toNamespacedPath(path)\x2C\n                         stringToSymlinkType(type)\x2C\n                         kUsePromises);\n}\n\nasync function fstat(handle\x2C options = { bigint: false }) {\n  const result = await binding.fstat(handle.fd\x2C options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function lstat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                                     options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function stat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.stat(pathModule.toNamespacedPath(path)\x2C\n                                    options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function link(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                      pathModule.toNamespacedPath(newPath)\x2C\n                      kUsePromises);\n}\n\nasync function unlink(path) {\n  path = getValidatedPath(path);\n  return binding.unlink(pathModule.toNamespacedPath(path)\x2C kUsePromises);\n}\n\nasync function fchmod(handle\x2C mode) {\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.fchmod(handle.fd\x2C mode\x2C kUsePromises);\n}\n\nasync function chmod(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C kUsePromises);\n}\n\nasync function lchmod(path\x2C mode) {\n  if (O_SYMLINK === undefined)\n    throw new ERR_METHOD_NOT_IMPLEMENTED('lchmod()');\n\n  const fd = await open(path\x2C O_WRONLY | O_SYMLINK);\n  return handleFdClose(fchmod(fd\x2C mode)\x2C fd.close);\n}\n\nasync function lchown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.lchown(pathModule.toNamespacedPath(path)\x2C\n                        uid\x2C gid\x2C kUsePromises);\n}\n\nasync function fchown(handle\x2C uid\x2C gid) {\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.fchown(handle.fd\x2C uid\x2C gid\x2C kUsePromises);\n}\n\nasync function chown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.chown(pathModule.toNamespacedPath(path)\x2C\n                       uid\x2C gid\x2C kUsePromises);\n}\n\nasync function utimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                        toUnixTimestamp(atime)\x2C\n                        toUnixTimestamp(mtime)\x2C\n                        kUsePromises);\n}\n\nasync function futimes(handle\x2C atime\x2C mtime) {\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  return binding.futimes(handle.fd\x2C atime\x2C mtime\x2C kUsePromises);\n}\n\nasync function lutimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                         toUnixTimestamp(atime)\x2C\n                         toUnixTimestamp(mtime)\x2C\n                         kUsePromises);\n}\n\nasync function realpath(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  return binding.realpath(path\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function mkdtemp(prefix\x2C options) {\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix);\n  warnOnNonPortableTemplate(prefix);\n  return binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function writeFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data) && !isCustomIterable(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(data\x2C options.encoding || 'utf8');\n  }\n\n  validateAbortSignal(options.signal);\n  if (path instanceof FileHandle)\n    return writeFileHandle(path\x2C data\x2C options.signal\x2C options.encoding);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C options.mode);\n  return handleFdClose(\n    writeFileHandle(fd\x2C data\x2C options.signal\x2C options.encoding)\x2C fd.close);\n}\n\nfunction isCustomIterable(obj) {\n  return isIterable(obj) && !isArrayBufferView(obj) && typeof obj !== 'string';\n}\n\nasync function appendFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n  options = copyObject(options);\n  options.flag = options.flag || 'a';\n  return writeFile(path\x2C data\x2C options);\n}\n\nasync function readFile(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const flag = options.flag || 'r';\n\n  if (path instanceof FileHandle)\n    return readFileHandle(path\x2C options);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C 0o666);\n  return handleFdClose(readFileHandle(fd\x2C options)\x2C fd.close);\n}\n\nmodule.exports = {\n  exports: {\n    access\x2C\n    copyFile\x2C\n    cp\x2C\n    open\x2C\n    opendir: promisify(opendir)\x2C\n    rename\x2C\n    truncate\x2C\n    rm\x2C\n    rmdir\x2C\n    mkdir\x2C\n    readdir\x2C\n    readlink\x2C\n    symlink\x2C\n    lstat\x2C\n    stat\x2C\n    link\x2C\n    unlink\x2C\n    chmod\x2C\n    lchmod\x2C\n    lchown\x2C\n    chown\x2C\n    utimes\x2C\n    lutimes\x2C\n    realpath\x2C\n    mkdtemp\x2C\n    writeFile\x2C\n    appendFile\x2C\n    readFile\x2C\n    watch\x2C\n  }\x2C\n\n  FileHandle\x2C\n  kRef\x2C\n  kUnref\x2C\n};\n
code-source-info,0x24b326975766,110,0,24173,C0O0C4O24173,,
code-creation,Function,10,76697,0x24b326977f8e,1789, node:internal/fs/promises:1:1,0x24b3269756e0,~
code-source-info,0x24b326977f8e,110,0,24173,C0O0C514O25C520O47C526O56C532O67C538O78C544O101C550O112C556O136C562O154C568O171C574O192C580O223C585O233C591O328C595O328C601O356C607O273C613O281C619O294C625O306C631O316C637O377C641O377C645O377C647O419C655O419C661O408C667O612C675O612C681O612C687O462C693O489C699O516C705O539C711O574C717O588C723O670C731O670C737O648C743O729C751O729C757O710C763O1362C771O1362C777O1362C783O787C789O805C795O821C801O848C807O882C813O913C819O927C825O956C830O970C836O984C842O1007C848O1027C854O1043C860O1056C866O1088C872O1105C878O1128C884O1147C890O1170C896O1191C902O1219C908O1248C913O1269C919O1293C925O1331C931O1412C939O1412C945O1400C950O1586C958O1586C964O1450C970O1467C976O1490C982O1509C988O1527C994O1547C1000O1566C1006O1637C1014O1637C1018O1637C1020O1694C1028O1694C1034O1662C1040O1680C1045O1750C1053O1750C1059O1728C1064O1802C1072O1802C1078O1792C1083O1858C1091O1858C1097O1843C1103O1908C1111O1908C1115O1908C1117O1953C1121O1953C1125O1953C1127O1984C1131O1984C1135O1984C1137O2013C1141O2013C1145O2013C1147O2052C1151O2052C1155O2052C1157O2099C1161O2099C1165O2099C1167O2145C1171O2145C1175O2145C1177O2182C1181O2182C1185O2182C1187O2213C1191O2213C1195O2213C1197O2247C1201O2247C1205O2247C1207O2292C1211O2275C1217O2370C1225O2370C1231O2311C1236O2327C1241O2341C1246O2352C1251O2462C1259O2462C1265O2425C1271O2540C1279O2540C1285O2514C1291O2623C1295O2623C1297O2679C1301O2679C1303O2714C1304O2714C1306O2869C1307O2869C1309O2990C1437O6836C1447O7239C1457O7296C1469O7387C1479O7424C1511O2965C1513O23730C1519O23760C1527O23766C1533O23778C1539O23792C1545O23800C1549O23819C1559O23843C1565O23855C1571O23869C1577O23877C1583O23888C1589O23899C1595O23912C1601O23926C1607O23939C1613O23950C1619O23960C1625O23970C1631O23982C1637O23993C1643O24005C1649O24017C1659O24028C1669O24040C1679O24053C1689O24067C1699O24080C1709O24095C1719O24111C1729O24125C1749O24140C1759O24154C1769O24162C1779O23745C1788O24172,,
code-creation,Function,10,76816,0x24b3269789de,27,<instance_members_initializer> node:internal/fs/promises:201:3,0x24b326976de0,~
code-source-info,0x24b3269789de,110,4472,5270,C0O4472C12O4480C26O5270,,
tick,0x7fff2038515d,76860,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Eval,10,77409,0x24b32697b65e,5, node:internal/fs/rimraf:1:1,0x24b32697b2f8,~
script-source,111,node:internal/fs/rimraf,// This file is a modified version of the rimraf module on npm. It has been\n// modified in the following ways:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  Promise\x2C\n  SafeSet\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst fs = require('fs');\nconst {\n  chmod\x2C\n  chmodSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statSync\x2C\n  unlink\x2C\n  unlinkSync\n} = fs;\nconst { sep } = require('path');\nconst { setTimeout } = require('timers');\nconst { sleep } = require('internal/util');\nconst notEmptyErrorCodes = new SafeSet(['ENOTEMPTY'\x2C 'EEXIST'\x2C 'EPERM']);\nconst retryErrorCodes = new SafeSet(\n  ['EBUSY'\x2C 'EMFILE'\x2C 'ENFILE'\x2C 'ENOTEMPTY'\x2C 'EPERM']);\nconst isWindows = process.platform === 'win32';\nconst epermHandler = isWindows ? fixWinEPERM : _rmdir;\nconst epermHandlerSync = isWindows ? fixWinEPERMSync : _rmdirSync;\nconst readdirEncoding = 'buffer';\nconst separator = Buffer.from(sep);\n\n\nfunction rimraf(path\x2C options\x2C callback) {\n  let retries = 0;\n\n  _rimraf(path\x2C options\x2C function CB(err) {\n    if (err) {\n      if (retryErrorCodes.has(err.code) && retries < options.maxRetries) {\n        retries++;\n        const delay = retries * options.retryDelay;\n        return setTimeout(_rimraf\x2C delay\x2C path\x2C options\x2C CB);\n      }\n\n      // The file is already gone.\n      if (err.code === 'ENOENT')\n        err = null;\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rimraf(path\x2C options\x2C callback) {\n  // SunOS lets the root user unlink directories. Use lstat here to make sure\n  // it's not a directory.\n  lstat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (err.code === 'ENOENT')\n        return callback(null);\n\n      // Windows can EPERM on stat.\n      if (isWindows && err.code === 'EPERM')\n        return fixWinEPERM(path\x2C options\x2C err\x2C callback);\n    } else if (stats.isDirectory()) {\n      return _rmdir(path\x2C options\x2C err\x2C callback);\n    }\n\n    unlink(path\x2C (err) => {\n      if (err) {\n        if (err.code === 'ENOENT')\n          return callback(null);\n        if (err.code === 'EISDIR')\n          return _rmdir(path\x2C options\x2C err\x2C callback);\n        if (err.code === 'EPERM') {\n          return epermHandler(path\x2C options\x2C err\x2C callback);\n        }\n      }\n\n      return callback(err);\n    });\n  });\n}\n\n\nfunction fixWinEPERM(path\x2C options\x2C originalErr\x2C callback) {\n  chmod(path\x2C 0o666\x2C (err) => {\n    if (err)\n      return callback(err.code === 'ENOENT' ? null : originalErr);\n\n    stat(path\x2C (err\x2C stats) => {\n      if (err)\n        return callback(err.code === 'ENOENT' ? null : originalErr);\n\n      if (stats.isDirectory())\n        _rmdir(path\x2C options\x2C originalErr\x2C callback);\n      else\n        unlink(path\x2C callback);\n    });\n  });\n}\n\n\nfunction _rmdir(path\x2C options\x2C originalErr\x2C callback) {\n  rmdir(path\x2C (err) => {\n    if (err) {\n      if (notEmptyErrorCodes.has(err.code))\n        return _rmchildren(path\x2C options\x2C callback);\n      if (err.code === 'ENOTDIR')\n        return callback(originalErr);\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rmchildren(path\x2C options\x2C callback) {\n  const pathBuf = Buffer.from(path);\n\n  readdir(pathBuf\x2C readdirEncoding\x2C (err\x2C files) => {\n    if (err)\n      return callback(err);\n\n    let numFiles = files.length;\n\n    if (numFiles === 0)\n      return rmdir(path\x2C callback);\n\n    let done = false;\n\n    ArrayPrototypeForEach(files\x2C (child) => {\n      const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n      rimraf(childPath\x2C options\x2C (err) => {\n        if (done)\n          return;\n\n        if (err) {\n          done = true;\n          return callback(err);\n        }\n\n        numFiles--;\n        if (numFiles === 0)\n          rmdir(path\x2C callback);\n      });\n    });\n  });\n}\n\n\nfunction rimrafPromises(path\x2C options) {\n  return new Promise((resolve\x2C reject) => {\n    rimraf(path\x2C options\x2C (err) => {\n      if (err)\n        return reject(err);\n\n      resolve();\n    });\n  });\n}\n\n\nfunction rimrafSync(path\x2C options) {\n  let stats;\n\n  try {\n    stats = lstatSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    // Windows can EPERM on stat.\n    if (isWindows && err.code === 'EPERM')\n      fixWinEPERMSync(path\x2C options\x2C err);\n  }\n\n  try {\n    // SunOS lets the root user unlink directories.\n    if (stats?.isDirectory())\n      _rmdirSync(path\x2C options\x2C null);\n    else\n      _unlinkSync(path\x2C options);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'EPERM')\n      return epermHandlerSync(path\x2C options\x2C err);\n    if (err.code !== 'EISDIR')\n      throw err;\n\n    _rmdirSync(path\x2C options\x2C err);\n  }\n}\n\n\nfunction _unlinkSync(path\x2C options) {\n  const tries = options.maxRetries + 1;\n\n  for (let i = 1; i <= tries; i++) {\n    try {\n      return unlinkSync(path);\n    } catch (err) {\n      // Only sleep if this is not the last try\x2C and the delay is greater\n      // than zero\x2C and an error was encountered that warrants a retry.\n      if (retryErrorCodes.has(err.code) &&\n          i < tries &&\n          options.retryDelay > 0) {\n        sleep(i * options.retryDelay);\n      } else if (err.code === 'ENOENT') {\n        // The file is already gone.\n        return;\n      } else if (i === tries) {\n        throw err;\n      }\n    }\n  }\n}\n\n\nfunction _rmdirSync(path\x2C options\x2C originalErr) {\n  try {\n    rmdirSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'ENOTDIR') {\n      throw originalErr || err;\n    }\n\n    if (notEmptyErrorCodes.has(err.code)) {\n      // Removing failed. Try removing all children and then retrying the\n      // original removal. Windows has a habit of not closing handles promptly\n      // when files are deleted\x2C resulting in spurious ENOTEMPTY failures. Work\n      // around that issue by retrying on Windows.\n      const pathBuf = Buffer.from(path);\n\n      ArrayPrototypeForEach(readdirSync(pathBuf\x2C readdirEncoding)\x2C (child) => {\n        const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n        rimrafSync(childPath\x2C options);\n      });\n\n      const tries = options.maxRetries + 1;\n\n      for (let i = 1; i <= tries; i++) {\n        try {\n          return fs.rmdirSync(path);\n        } catch (err) {\n          // Only sleep if this is not the last try\x2C and the delay is greater\n          // than zero\x2C and an error was encountered that warrants a retry.\n          if (retryErrorCodes.has(err.code) &&\n              i < tries &&\n              options.retryDelay > 0) {\n            sleep(i * options.retryDelay);\n          } else if (err.code === 'ENOENT') {\n            // The file is already gone.\n            return;\n          } else if (i === tries) {\n            throw err;\n          }\n        }\n      }\n    }\n\n    throw originalErr || err;\n  }\n}\n\n\nfunction fixWinEPERMSync(path\x2C options\x2C originalErr) {\n  try {\n    chmodSync(path\x2C 0o666);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    throw originalErr;\n  }\n\n  let stats;\n\n  try {\n    stats = statSync(path\x2C { throwIfNoEntry: false });\n  } catch {\n    throw originalErr;\n  }\n\n  if (stats === undefined) return;\n\n  if (stats.isDirectory())\n    _rmdirSync(path\x2C options\x2C originalErr);\n  else\n    _unlinkSync(path\x2C options);\n}\n\n\nmodule.exports = { rimraf\x2C rimrafPromises\x2C rimrafSync };\n
code-source-info,0x24b32697b65e,111,0,7453,C0O0C4O7453,,
code-creation,Function,10,77994,0x24b32697bc5e,409, node:internal/fs/rimraf:1:1,0x24b32697b5d8,~
code-source-info,0x24b32697bc5e,111,0,7453,C0O0C139O368C145O393C151O404C156O450C159O450C164O439C170O480C173O480C177O480C179O642C182O505C188O514C194O527C200O536C206O549C212O560C218O575C224O584C230O597C236O605C242O617C248O627C254O662C257O662C262O654C267O702C270O702C275O687C281O739C284O739C289O729C295O792C302O792C307O792C309O863C316O863C321O863C323O958C330O967C333O950C335O1001C345O1001C347O1060C357O1060C359O1126C361O1126C363O1154C366O1161C371O1161C376O1154C378O7396C385O7415C391O7423C397O7439C403O7411C408O7452,,
tick,0x10c67b800,78052,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b32697827d,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,LazyCompile,10,78383,0x24b32697cb5e,188,from node:buffer:295:28,0x24b3608a4b08,~
script-source,18,node:buffer,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  Error\x2C\n  MathFloor\x2C\n  MathMin\x2C\n  MathTrunc\x2C\n  NumberIsNaN\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  SymbolSpecies\x2C\n  SymbolToPrimitive\x2C\n  TypedArrayPrototypeGetByteLength\x2C\n  TypedArrayPrototypeFill\x2C\n  TypedArrayPrototypeSet\x2C\n  Uint8Array\x2C\n  Uint8ArrayPrototype\x2C\n} = primordials;\n\nconst {\n  byteLengthUtf8\x2C\n  compare: _compare\x2C\n  compareOffset\x2C\n  createFromString\x2C\n  fill: bindingFill\x2C\n  indexOfBuffer\x2C\n  indexOfNumber\x2C\n  indexOfString\x2C\n  swap16: _swap16\x2C\n  swap32: _swap32\x2C\n  swap64: _swap64\x2C\n  kMaxLength\x2C\n  kStringMaxLength\n} = internalBinding('buffer');\nconst {\n  getOwnNonIndexProperties\x2C\n  propertyFilter: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\n  }\x2C\n} = internalBinding('util');\nconst {\n  customInspectSymbol\x2C\n  isInsideNodeModules\x2C\n  lazyDOMException\x2C\n  normalizeEncoding\x2C\n  kIsEncodingSymbol\n} = require('internal/util');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n  isUint8Array\n} = require('internal/util/types');\nconst {\n  inspect: utilInspect\n} = require('internal/util/inspect');\nconst { encodings } = internalBinding('string_decoder');\n\nconst {\n  codes: {\n    ERR_BUFFER_OUT_OF_BOUNDS\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_BUFFER_SIZE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_ENCODING\n  }\x2C\n  hideStackFrames\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateBuffer\x2C\n  validateNumber\x2C\n  validateInteger\x2C\n  validateString\n} = require('internal/validators');\n// Provide validateInteger() but with kMaxLength as the default maximum value.\nconst validateOffset = (value\x2C name\x2C min = 0\x2C max = kMaxLength) =>\n  validateInteger(value\x2C name\x2C min\x2C max);\n\nconst {\n  FastBuffer\x2C\n  markAsUntransferable\x2C\n  addBufferPrototypeMethods\x2C\n  createUnsafeBuffer\n} = require('internal/buffer');\n\nconst {\n  Blob\x2C\n  resolveObjectURL\x2C\n} = require('internal/blob');\n\nFastBuffer.prototype.constructor = Buffer;\nBuffer.prototype = FastBuffer.prototype;\naddBufferPrototypeMethods(Buffer.prototype);\n\nconst constants = ObjectDefineProperties({}\x2C {\n  MAX_LENGTH: {\n    value: kMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\n  }\x2C\n  MAX_STRING_LENGTH: {\n    value: kStringMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\n  }\n});\n\nBuffer.poolSize = 8 * 1024;\nlet poolSize\x2C poolOffset\x2C allocPool;\n\nconst encodingsMap = ObjectCreate(null);\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\n\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeBuffer(poolSize).buffer;\n  markAsUntransferable(allocPool);\n  poolOffset = 0;\n}\ncreatePool();\n\nfunction alignPool() {\n  // Ensure aligned slices\n  if (poolOffset & 0x7) {\n    poolOffset |= 0x7;\n    poolOffset++;\n  }\n}\n\nlet bufferWarningAlreadyEmitted = false;\nlet nodeModulesCheckCounter = 0;\nconst bufferWarning = 'Buffer() is deprecated due to security and usability ' +\n                      'issues. Please use the Buffer.alloc()\x2C ' +\n                      'Buffer.allocUnsafe()\x2C or Buffer.from() methods instead.';\n\nfunction showFlaggedDeprecation() {\n  if (bufferWarningAlreadyEmitted ||\n      ++nodeModulesCheckCounter > 10000 ||\n      (!require('internal/options').getOptionValue('--pending-deprecation') &&\n       isInsideNodeModules())) {\n    // We don't emit a warning\x2C because we either:\n    // - Already did so\x2C or\n    // - Already checked too many times whether a call is coming\n    //   from node_modules and want to stop slowing down things\x2C or\n    // - We aren't running with `--pending-deprecation` enabled\x2C\n    //   and the code is inside `node_modules`.\n    return;\n  }\n\n  process.emitWarning(bufferWarning\x2C 'DeprecationWarning'\x2C 'DEP0005');\n  bufferWarningAlreadyEmitted = true;\n}\n\nfunction toInteger(n\x2C defaultVal) {\n  n = +n;\n  if (!NumberIsNaN(n) &&\n      n >= NumberMIN_SAFE_INTEGER &&\n      n <= NumberMAX_SAFE_INTEGER) {\n    return ((n % 1) === 0 ? n : MathFloor(n));\n  }\n  return defaultVal;\n}\n\nfunction _copy(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (!isUint8Array(source))\n    throw new ERR_INVALID_ARG_TYPE('source'\x2C ['Buffer'\x2C 'Uint8Array']\x2C source);\n  if (!isUint8Array(target))\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n\n  if (targetStart === undefined) {\n    targetStart = 0;\n  } else {\n    targetStart = toInteger(targetStart\x2C 0);\n    if (targetStart < 0)\n      throw new ERR_OUT_OF_RANGE('targetStart'\x2C '>= 0'\x2C targetStart);\n  }\n\n  if (sourceStart === undefined) {\n    sourceStart = 0;\n  } else {\n    sourceStart = toInteger(sourceStart\x2C 0);\n    if (sourceStart < 0)\n      throw new ERR_OUT_OF_RANGE('sourceStart'\x2C '>= 0'\x2C sourceStart);\n  }\n\n  if (sourceEnd === undefined) {\n    sourceEnd = source.length;\n  } else {\n    sourceEnd = toInteger(sourceEnd\x2C 0);\n    if (sourceEnd < 0)\n      throw new ERR_OUT_OF_RANGE('sourceEnd'\x2C '>= 0'\x2C sourceEnd);\n  }\n\n  if (targetStart >= target.length || sourceStart >= sourceEnd)\n    return 0;\n\n  if (sourceStart > source.length) {\n    throw new ERR_OUT_OF_RANGE('sourceStart'\x2C\n                               `<= ${source.length}`\x2C\n                               sourceStart);\n  }\n\n  return _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n}\n\nfunction _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (sourceEnd - sourceStart > target.length - targetStart)\n    sourceEnd = sourceStart + target.length - targetStart;\n\n  let nb = sourceEnd - sourceStart;\n  const sourceLen = source.length - sourceStart;\n  if (nb > sourceLen)\n    nb = sourceLen;\n\n  if (sourceStart !== 0 || sourceEnd < source.length)\n    source = new Uint8Array(source.buffer\x2C source.byteOffset + sourceStart\x2C nb);\n\n  TypedArrayPrototypeSet(target\x2C source\x2C targetStart);\n\n  return nb;\n}\n\n/**\n * The Buffer() constructor is deprecated in documentation and should not be\n * used moving forward. Rather\x2C developers should use one of the three new\n * factory APIs: Buffer.from()\x2C Buffer.allocUnsafe() or Buffer.alloc() based on\n * their specific needs. There is no runtime deprecation because of the extent\n * to which the Buffer constructor is used in the ecosystem currently -- a\n * runtime deprecation would introduce too much breakage at this time. It's not\n * likely that the Buffer constructors would ever actually be removed.\n * Deprecation Code: DEP0005\n */\nfunction Buffer(arg\x2C encodingOrOffset\x2C length) {\n  showFlaggedDeprecation();\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new ERR_INVALID_ARG_TYPE('string'\x2C 'string'\x2C arg);\n    }\n    return Buffer.alloc(arg);\n  }\n  return Buffer.from(arg\x2C encodingOrOffset\x2C length);\n}\n\nObjectDefineProperty(Buffer\x2C SymbolSpecies\x2C {\n  enumerable: false\x2C\n  configurable: true\x2C\n  get() { return FastBuffer; }\n});\n\n/**\n * Functionally equivalent to Buffer(arg\x2C encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[\x2C encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[\x2C byteOffset[\x2C length]])\n */\nBuffer.from = function from(value\x2C encodingOrOffset\x2C length) {\n  if (typeof value === 'string')\n    return fromString(value\x2C encodingOrOffset);\n\n  if (typeof value === 'object' && value !== null) {\n    if (isAnyArrayBuffer(value))\n      return fromArrayBuffer(value\x2C encodingOrOffset\x2C length);\n\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null &&\n        valueOf !== value &&\n        (typeof valueOf === 'string' || typeof valueOf === 'object')) {\n      return from(valueOf\x2C encodingOrOffset\x2C length);\n    }\n\n    const b = fromObject(value);\n    if (b)\n      return b;\n\n    if (typeof value[SymbolToPrimitive] === 'function') {\n      const primitive = value[SymbolToPrimitive]('string');\n      if (typeof primitive === 'string') {\n        return fromString(primitive\x2C encodingOrOffset);\n      }\n    }\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'first argument'\x2C\n    ['string'\x2C 'Buffer'\x2C 'ArrayBuffer'\x2C 'Array'\x2C 'Array-like Object']\x2C\n    value\n  );\n};\n\n// Identical to the built-in %TypedArray%.of()\x2C but avoids using the deprecated\n// Buffer() constructor. Must use arrow function syntax to avoid automatically\n// adding a `prototype` property and making the function a constructor.\n//\n// Refs: https://tc39.github.io/ecma262/#sec-%typedarray%.of\n// Refs: https://esdiscuss.org/topic/isconstructor#content-11\nconst of = (...items) => {\n  const newObj = createUnsafeBuffer(items.length);\n  for (let k = 0; k < items.length; k++)\n    newObj[k] = items[k];\n  return newObj;\n};\nBuffer.of = of;\n\nObjectSetPrototypeOf(Buffer\x2C Uint8Array);\n\n// The 'assertSize' method will remove itself from the callstack when an error\n// occurs. This is done simply to keep the internal details of the\n// implementation from bleeding out to users.\nconst assertSize = hideStackFrames((size) => {\n  validateNumber(size\x2C 'size');\n  if (!(size >= 0 && size <= kMaxLength)) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError('size'\x2C size);\n  }\n});\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[\x2C fill[\x2C encoding]])\n */\nBuffer.alloc = function alloc(size\x2C fill\x2C encoding) {\n  assertSize(size);\n  if (fill !== undefined && fill !== 0 && size > 0) {\n    const buf = createUnsafeBuffer(size);\n    return _fill(buf\x2C fill\x2C 0\x2C buf.length\x2C encoding);\n  }\n  return new FastBuffer(size);\n};\n\n/**\n * Equivalent to Buffer(num)\x2C by default creates a non-zero-filled Buffer\n * instance. If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafe = function allocUnsafe(size) {\n  assertSize(size);\n  return allocate(size);\n};\n\n/**\n * Equivalent to SlowBuffer(num)\x2C by default creates a non-zero-filled\n * Buffer instance that is not allocated off the pre-initialized pool.\n * If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafeSlow = function allocUnsafeSlow(size) {\n  assertSize(size);\n  return createUnsafeBuffer(size);\n};\n\n// If --zero-fill-buffers command line argument is set\x2C a zero-filled\n// buffer is returned.\nfunction SlowBuffer(length) {\n  assertSize(length);\n  return createUnsafeBuffer(length);\n}\n\nObjectSetPrototypeOf(SlowBuffer.prototype\x2C Uint8ArrayPrototype);\nObjectSetPrototypeOf(SlowBuffer\x2C Uint8Array);\n\nfunction allocate(size) {\n  if (size <= 0) {\n    return new FastBuffer();\n  }\n  if (size < (Buffer.poolSize >>> 1)) {\n    if (size > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C size);\n    poolOffset += size;\n    alignPool();\n    return b;\n  }\n  return createUnsafeBuffer(size);\n}\n\nfunction fromStringFast(string\x2C ops) {\n  const length = ops.byteLength(string);\n\n  if (length >= (Buffer.poolSize >>> 1))\n    return createFromString(string\x2C ops.encodingVal);\n\n  if (length > (poolSize - poolOffset))\n    createPool();\n  let b = new FastBuffer(allocPool\x2C poolOffset\x2C length);\n  const actual = ops.write(b\x2C string\x2C 0\x2C length);\n  if (actual !== length) {\n    // byteLength() may overestimate. That's a rare case\x2C though.\n    b = new FastBuffer(allocPool\x2C poolOffset\x2C actual);\n  }\n  poolOffset += actual;\n  alignPool();\n  return b;\n}\n\nfunction fromString(string\x2C encoding) {\n  let ops;\n  if (typeof encoding !== 'string' || encoding.length === 0) {\n    if (string.length === 0)\n      return new FastBuffer();\n    ops = encodingOps.utf8;\n    encoding = undefined;\n  } else {\n    ops = getEncodingOps(encoding);\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (string.length === 0)\n      return new FastBuffer();\n  }\n  return fromStringFast(string\x2C ops);\n}\n\nfunction fromArrayBuffer(obj\x2C byteOffset\x2C length) {\n  // Convert byteOffset to integer\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  } else {\n    byteOffset = +byteOffset;\n    if (NumberIsNaN(byteOffset))\n      byteOffset = 0;\n  }\n\n  const maxLength = obj.byteLength - byteOffset;\n\n  if (maxLength < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\n\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    // Convert length to non-negative integer.\n    length = +length;\n    if (length > 0) {\n      if (length > maxLength)\n        throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\n    } else {\n      length = 0;\n    }\n  }\n\n  return new FastBuffer(obj\x2C byteOffset\x2C length);\n}\n\nfunction fromArrayLike(obj) {\n  if (obj.length <= 0)\n    return new FastBuffer();\n  if (obj.length < (Buffer.poolSize >>> 1)) {\n    if (obj.length > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C obj.length);\n    TypedArrayPrototypeSet(b\x2C obj\x2C 0);\n    poolOffset += obj.length;\n    alignPool();\n    return b;\n  }\n  return new FastBuffer(obj);\n}\n\nfunction fromObject(obj) {\n  if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {\n    if (typeof obj.length !== 'number') {\n      return new FastBuffer();\n    }\n    return fromArrayLike(obj);\n  }\n\n  if (obj.type === 'Buffer' && ArrayIsArray(obj.data)) {\n    return fromArrayLike(obj.data);\n  }\n}\n\n// Static methods\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer;\n};\n\nBuffer.compare = function compare(buf1\x2C buf2) {\n  if (!isUint8Array(buf1)) {\n    throw new ERR_INVALID_ARG_TYPE('buf1'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf1);\n  }\n\n  if (!isUint8Array(buf2)) {\n    throw new ERR_INVALID_ARG_TYPE('buf2'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf2);\n  }\n\n  if (buf1 === buf2) {\n    return 0;\n  }\n\n  return _compare(buf1\x2C buf2);\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  return typeof encoding === 'string' && encoding.length !== 0 &&\n         normalizeEncoding(encoding) !== undefined;\n};\nBuffer[kIsEncodingSymbol] = Buffer.isEncoding;\n\nBuffer.concat = function concat(list\x2C length) {\n  validateArray(list\x2C 'list');\n\n  if (list.length === 0)\n    return new FastBuffer();\n\n  if (length === undefined) {\n    length = 0;\n    for (let i = 0; i < list.length; i++) {\n      if (list[i].length) {\n        length += list[i].length;\n      }\n    }\n  } else {\n    validateOffset(length\x2C 'length');\n  }\n\n  const buffer = Buffer.allocUnsafe(length);\n  let pos = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    if (!isUint8Array(buf)) {\n      // TODO(BridgeAR): This should not be of type ERR_INVALID_ARG_TYPE.\n      // Instead\x2C find the proper error code for this.\n      throw new ERR_INVALID_ARG_TYPE(\n        `list[${i}]`\x2C ['Buffer'\x2C 'Uint8Array']\x2C list[i]);\n    }\n    pos += _copyActual(buf\x2C buffer\x2C pos\x2C 0\x2C buf.length);\n  }\n\n  // Note: `length` is always equal to `buffer.length` at this point\n  if (pos < length) {\n    // Zero-fill the remaining bytes if the specified `length` was more than\n    // the actual total length\x2C i.e. if we have some remaining allocated bytes\n    // there were not initialized.\n    TypedArrayPrototypeFill(buffer\x2C 0\x2C pos\x2C length);\n  }\n\n  return buffer;\n};\n\nfunction base64ByteLength(str\x2C bytes) {\n  // Handle padding\n  if (StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n  if (bytes > 1 && StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n\n  // Base64 ratio: 3/4\n  return (bytes * 3) >>> 2;\n}\n\nconst encodingOps = {\n  utf8: {\n    encoding: 'utf8'\x2C\n    encodingVal: encodingsMap.utf8\x2C\n    byteLength: byteLengthUtf8\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.utf8Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.utf8Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf8\x2C dir)\n  }\x2C\n  ucs2: {\n    encoding: 'ucs2'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\n  }\x2C\n  utf16le: {\n    encoding: 'utf16le'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\n  }\x2C\n  latin1: {\n    encoding: 'latin1'\x2C\n    encodingVal: encodingsMap.latin1\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.latin1Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.latin1Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.latin1\x2C dir)\n  }\x2C\n  ascii: {\n    encoding: 'ascii'\x2C\n    encodingVal: encodingsMap.ascii\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.asciiWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.asciiSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.ascii)\x2C\n                    byteOffset\x2C\n                    encodingsMap.ascii\x2C\n                    dir)\n  }\x2C\n  base64: {\n    encoding: 'base64'\x2C\n    encodingVal: encodingsMap.base64\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.base64Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64\x2C\n                    dir)\n  }\x2C\n  base64url: {\n    encoding: 'base64url'\x2C\n    encodingVal: encodingsMap.base64url\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) =>\n      buf.base64urlWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64urlSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64url)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64url\x2C\n                    dir)\n  }\x2C\n  hex: {\n    encoding: 'hex'\x2C\n    encodingVal: encodingsMap.hex\x2C\n    byteLength: (string) => string.length >>> 1\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.hexWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.hexSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.hex)\x2C\n                    byteOffset\x2C\n                    encodingsMap.hex\x2C\n                    dir)\n  }\n};\nfunction getEncodingOps(encoding) {\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      break;\n    case 5:\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      break;\n    case 7:\n      if (encoding === 'utf16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf16le')\n        return encodingOps.utf16le;\n      break;\n    case 8:\n      if (encoding === 'utf-16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf-16le')\n        return encodingOps.utf16le;\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      break;\n    case 3:\n      if (encoding === 'hex' || StringPrototypeToLowerCase(encoding) === 'hex')\n        return encodingOps.hex;\n      break;\n    case 9:\n      if (encoding === 'base64url' ||\n          StringPrototypeToLowerCase(encoding) === 'base64url')\n        return encodingOps.base64url;\n      break;\n  }\n}\n\nfunction byteLength(string\x2C encoding) {\n  if (typeof string !== 'string') {\n    if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {\n      return string.byteLength;\n    }\n\n    throw new ERR_INVALID_ARG_TYPE(\n      'string'\x2C ['string'\x2C 'Buffer'\x2C 'ArrayBuffer']\x2C string\n    );\n  }\n\n  const len = string.length;\n  const mustMatch = (arguments.length > 2 && arguments[2] === true);\n  if (!mustMatch && len === 0)\n    return 0;\n\n  if (!encoding)\n    return (mustMatch ? -1 : byteLengthUtf8(string));\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    return (mustMatch ? -1 : byteLengthUtf8(string));\n  return ops.byteLength(string);\n}\n\nBuffer.byteLength = byteLength;\n\n// For backwards compatibility.\nObjectDefineProperty(Buffer.prototype\x2C 'parent'\x2C {\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.buffer;\n  }\n});\nObjectDefineProperty(Buffer.prototype\x2C 'offset'\x2C {\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.byteOffset;\n  }\n});\n\nBuffer.prototype.copy =\n  function copy(target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n    return _copy(this\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n  };\n\n// No need to verify that "buf.length <= MAX_UINT32" since it's a read-only\n// property of a typed array.\n// This behaves neither like String nor Uint8Array in that we set start/end\n// to their upper/lower bounds if the value passed is out of range.\nBuffer.prototype.toString = function toString(encoding\x2C start\x2C end) {\n  if (arguments.length === 0) {\n    return this.utf8Slice(0\x2C this.length);\n  }\n\n  const len = this.length;\n\n  if (start <= 0)\n    start = 0;\n  else if (start >= len)\n    return '';\n  else\n    start |= 0;\n\n  if (end === undefined || end > len)\n    end = len;\n  else\n    end |= 0;\n\n  if (end <= start)\n    return '';\n\n  if (encoding === undefined)\n    return this.utf8Slice(start\x2C end);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n\n  return ops.slice(this\x2C start\x2C end);\n};\n\nBuffer.prototype.equals = function equals(otherBuffer) {\n  if (!isUint8Array(otherBuffer)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'otherBuffer'\x2C ['Buffer'\x2C 'Uint8Array']\x2C otherBuffer);\n  }\n\n  if (this === otherBuffer)\n    return true;\n\n  if (this.byteLength !== otherBuffer.byteLength)\n    return false;\n\n  return this.byteLength === 0 || _compare(this\x2C otherBuffer) === 0;\n};\n\nlet INSPECT_MAX_BYTES = 50;\n// Override how buffers are presented by util.inspect().\nBuffer.prototype[customInspectSymbol] = function inspect(recurseTimes\x2C ctx) {\n  const max = INSPECT_MAX_BYTES;\n  const actualMax = MathMin(max\x2C this.length);\n  const remaining = this.length - max;\n  let str = StringPrototypeTrim(StringPrototypeReplace(\n    this.hexSlice(0\x2C actualMax)\x2C /(.{2})/g\x2C '$1 '));\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  // Inspect special properties as well\x2C if possible.\n  if (ctx) {\n    let extras = false;\n    const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n    const obj = ObjectCreate(null);\n    ArrayPrototypeForEach(getOwnNonIndexProperties(this\x2C filter)\x2C\n                          (key) => {\n                            extras = true;\n                            obj[key] = this[key];\n                          });\n    if (extras) {\n      if (this.length !== 0)\n        str += '\x2C ';\n      // '[Object: null prototype] {'.length === 26\n      // This is guarded with a test.\n      str += StringPrototypeSlice(utilInspect(obj\x2C {\n        ...ctx\x2C\n        breakLength: Infinity\x2C\n        compact: true\n      })\x2C 27\x2C -2);\n    }\n  }\n  return `<${this.constructor.name} ${str}>`;\n};\nBuffer.prototype.inspect = Buffer.prototype[customInspectSymbol];\n\nBuffer.prototype.compare = function compare(target\x2C\n                                            targetStart\x2C\n                                            targetEnd\x2C\n                                            sourceStart\x2C\n                                            sourceEnd) {\n  if (!isUint8Array(target)) {\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n  }\n  if (arguments.length === 1)\n    return _compare(this\x2C target);\n\n  if (targetStart === undefined)\n    targetStart = 0;\n  else\n    validateOffset(targetStart\x2C 'targetStart');\n\n  if (targetEnd === undefined)\n    targetEnd = target.length;\n  else\n    validateOffset(targetEnd\x2C 'targetEnd'\x2C 0\x2C target.length);\n\n  if (sourceStart === undefined)\n    sourceStart = 0;\n  else\n    validateOffset(sourceStart\x2C 'sourceStart');\n\n  if (sourceEnd === undefined)\n    sourceEnd = this.length;\n  else\n    validateOffset(sourceEnd\x2C 'sourceEnd'\x2C 0\x2C this.length);\n\n  if (sourceStart >= sourceEnd)\n    return (targetStart >= targetEnd ? 0 : -1);\n  if (targetStart >= targetEnd)\n    return 1;\n\n  return compareOffset(this\x2C target\x2C targetStart\x2C sourceStart\x2C targetEnd\x2C\n                       sourceEnd);\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`\x2C\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string\x2C Buffer\x2C or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding\x2C relevant if val is a string\n// - dir - true for indexOf\x2C false for lastIndexOf\nfunction bidirectionalIndexOf(buffer\x2C val\x2C byteOffset\x2C encoding\x2C dir) {\n  validateBuffer(buffer);\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = undefined;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  // Coerce to Number. Values like null and [] become 0.\n  byteOffset = +byteOffset;\n  // If the offset is undefined\x2C "foo"\x2C {}\x2C coerces to NaN\x2C search whole buffer.\n  if (NumberIsNaN(byteOffset)) {\n    byteOffset = dir ? 0 : (buffer.length || buffer.byteLength);\n  }\n  dir = !!dir;  // Cast to bool.\n\n  if (typeof val === 'number')\n    return indexOfNumber(buffer\x2C val >>> 0\x2C byteOffset\x2C dir);\n\n  let ops;\n  if (encoding === undefined)\n    ops = encodingOps.utf8;\n  else\n    ops = getEncodingOps(encoding);\n\n  if (typeof val === 'string') {\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    return ops.indexOf(buffer\x2C val\x2C byteOffset\x2C dir);\n  }\n\n  if (isUint8Array(val)) {\n    const encodingVal =\n      (ops === undefined ? encodingsMap.utf8 : ops.encodingVal);\n    return indexOfBuffer(buffer\x2C val\x2C byteOffset\x2C encodingVal\x2C dir);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'value'\x2C ['number'\x2C 'string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C val\n  );\n}\n\nBuffer.prototype.indexOf = function indexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C false);\n};\n\nBuffer.prototype.includes = function includes(val\x2C byteOffset\x2C encoding) {\n  return this.indexOf(val\x2C byteOffset\x2C encoding) !== -1;\n};\n\n// Usage:\n//    buffer.fill(number[\x2C offset[\x2C end]])\n//    buffer.fill(buffer[\x2C offset[\x2C end]])\n//    buffer.fill(string[\x2C offset[\x2C end]][\x2C encoding])\nBuffer.prototype.fill = function fill(value\x2C offset\x2C end\x2C encoding) {\n  return _fill(this\x2C value\x2C offset\x2C end\x2C encoding);\n};\n\nfunction _fill(buf\x2C value\x2C offset\x2C end\x2C encoding) {\n  if (typeof value === 'string') {\n    if (offset === undefined || typeof offset === 'string') {\n      encoding = offset;\n      offset = 0;\n      end = buf.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = buf.length;\n    }\n\n    const normalizedEncoding = normalizeEncoding(encoding);\n    if (normalizedEncoding === undefined) {\n      validateString(encoding\x2C 'encoding');\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    }\n\n    if (value.length === 0) {\n      // If value === '' default to zero.\n      value = 0;\n    } else if (value.length === 1) {\n      // Fast path: If `value` fits into a single byte\x2C use that numeric value.\n      if (normalizedEncoding === 'utf8') {\n        const code = StringPrototypeCharCodeAt(value\x2C 0);\n        if (code < 128) {\n          value = code;\n        }\n      } else if (normalizedEncoding === 'latin1') {\n        value = StringPrototypeCharCodeAt(value\x2C 0);\n      }\n    }\n  } else {\n    encoding = undefined;\n  }\n\n  if (offset === undefined) {\n    offset = 0;\n    end = buf.length;\n  } else {\n    validateOffset(offset\x2C 'offset');\n    // Invalid ranges are not set to a default\x2C so can range check early.\n    if (end === undefined) {\n      end = buf.length;\n    } else {\n      validateOffset(end\x2C 'end'\x2C 0\x2C buf.length);\n    }\n    if (offset >= end)\n      return buf;\n  }\n\n\n  if (typeof value === 'number') {\n    // OOB check\n    const byteLen = TypedArrayPrototypeGetByteLength(buf);\n    const fillLength = end - offset;\n    if (offset > end || fillLength + offset > byteLen)\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n    TypedArrayPrototypeFill(buf\x2C value\x2C offset\x2C end);\n  } else {\n    const res = bindingFill(buf\x2C value\x2C offset\x2C end\x2C encoding);\n    if (res < 0) {\n      if (res === -1)\n        throw new ERR_INVALID_ARG_VALUE('value'\x2C value);\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n  }\n\n  return buf;\n}\n\nBuffer.prototype.write = function write(string\x2C offset\x2C length\x2C encoding) {\n  // Buffer#write(string);\n  if (offset === undefined) {\n    return this.utf8Write(string\x2C 0\x2C this.length);\n  }\n  // Buffer#write(string\x2C encoding)\n  if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n\n  // Buffer#write(string\x2C offset[\x2C length][\x2C encoding])\n  } else {\n    validateOffset(offset\x2C 'offset'\x2C 0\x2C this.length);\n\n    const remaining = this.length - offset;\n\n    if (length === undefined) {\n      length = remaining;\n    } else if (typeof length === 'string') {\n      encoding = length;\n      length = remaining;\n    } else {\n      validateOffset(length\x2C 'length'\x2C 0\x2C this.length);\n      if (length > remaining)\n        length = remaining;\n    }\n  }\n\n  if (!encoding)\n    return this.utf8Write(string\x2C offset\x2C length);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  return ops.write(this\x2C string\x2C offset\x2C length);\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  if (this.length > 0) {\n    const data = new Array(this.length);\n    for (let i = 0; i < this.length; ++i)\n      data[i] = this[i];\n    return { type: 'Buffer'\x2C data };\n  }\n  return { type: 'Buffer'\x2C data: [] };\n};\n\nfunction adjustOffset(offset\x2C length) {\n  // Use Math.trunc() to convert offset to an integer value that can be larger\n  // than an Int32. Hence\x2C don't use offset | 0 or similar techniques.\n  offset = MathTrunc(offset);\n  if (offset === 0) {\n    return 0;\n  }\n  if (offset < 0) {\n    offset += length;\n    return offset > 0 ? offset : 0;\n  }\n  if (offset < length) {\n    return offset;\n  }\n  return NumberIsNaN(offset) ? 0 : length;\n}\n\nBuffer.prototype.slice = function slice(start\x2C end) {\n  const srcLength = this.length;\n  start = adjustOffset(start\x2C srcLength);\n  end = end !== undefined ? adjustOffset(end\x2C srcLength) : srcLength;\n  const newLength = end > start ? end - start : 0;\n  return new FastBuffer(this.buffer\x2C this.byteOffset + start\x2C newLength);\n};\n\nfunction swap(b\x2C n\x2C m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  // For Buffer.length < 128\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 2 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('16-bits');\n  if (len < 128) {\n    for (let i = 0; i < len; i += 2)\n      swap(this\x2C i\x2C i + 1);\n    return this;\n  }\n  return _swap16(this);\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 4 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('32-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 4) {\n      swap(this\x2C i\x2C i + 3);\n      swap(this\x2C i + 1\x2C i + 2);\n    }\n    return this;\n  }\n  return _swap32(this);\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 8 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('64-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 8) {\n      swap(this\x2C i\x2C i + 7);\n      swap(this\x2C i + 1\x2C i + 6);\n      swap(this\x2C i + 2\x2C i + 5);\n      swap(this\x2C i + 3\x2C i + 4);\n    }\n    return this;\n  }\n  return _swap64(this);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\nlet transcode;\nif (internalBinding('config').hasIntl) {\n  const {\n    icuErrName\x2C\n    transcode: _transcode\n  } = internalBinding('icu');\n\n  // Transcodes the Buffer from one encoding to another\x2C returning a new\n  // Buffer instance.\n  transcode = function transcode(source\x2C fromEncoding\x2C toEncoding) {\n    if (!isUint8Array(source)) {\n      throw new ERR_INVALID_ARG_TYPE('source'\x2C\n                                     ['Buffer'\x2C 'Uint8Array']\x2C source);\n    }\n    if (source.length === 0) return Buffer.alloc(0);\n\n    fromEncoding = normalizeEncoding(fromEncoding) || fromEncoding;\n    toEncoding = normalizeEncoding(toEncoding) || toEncoding;\n    const result = _transcode(source\x2C fromEncoding\x2C toEncoding);\n    if (typeof result !== 'number')\n      return result;\n\n    const code = icuErrName(result);\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error(`Unable to transcode Buffer [${code}]`);\n    err.code = code;\n    err.errno = result;\n    throw err;\n  };\n}\n\nfunction btoa(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (input[n].charCodeAt(0) > 0xff)\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  const buf = Buffer.from(input\x2C 'latin1');\n  return buf.toString('base64');\n}\n\nconst kBase64Digits =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction atob(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (!kBase64Digits.includes(input[n]))\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  return Buffer.from(input\x2C 'base64').toString('latin1');\n}\n\nmodule.exports = {\n  Blob\x2C\n  resolveObjectURL\x2C\n  Buffer\x2C\n  SlowBuffer\x2C\n  transcode\x2C\n  // Legacy\n  kMaxLength\x2C\n  kStringMaxLength\x2C\n  btoa\x2C\n  atob\x2C\n};\n\nObjectDefineProperties(module.exports\x2C {\n  constants: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n  INSPECT_MAX_BYTES: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() { return INSPECT_MAX_BYTES; }\x2C\n    set(val) { INSPECT_MAX_BYTES = val; }\n  }\n});\n
code-source-info,0x24b32697cb5e,18,8406,9357,C3O8444C9O8479C12O8486C17O8522C18O8526C28O8581C33O8585C39O8616C51O8623C56O8672C57O8700C63O8717C68O8717C73O8732C78O8771C95O8862C104O8869C109O8909C110O8931C113O8931C118O8954C120O8967C122O8976C123O8982C125O8999C127O8998C134O9060C136O9066C138O9065C145O9084C151O9102C155O9147C158O9154C163O9194C164O9216C182O9222C187O9216,,
tick,0x7fff20385320,81474,0,0x0,3,0x10c825337,0x24b32697bdd1,0x24b357dbe2b5,0x24b357dbd585,0x24b32697827d,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
tick,0x10c265697,81526,0,0x0,3,0x10c825337,0x24b32697bdd1,0x24b357dbe2b5,0x24b357dbd585,0x24b32697827d,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
tick,0x7fff20385158,81552,0,0x0,3,0x10c825337,0x24b32697bdd1,0x24b357dbe2b5,0x24b357dbd585,0x24b32697827d,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,LazyCompile,10,81577,0x24b32697f536,110,fromString node:buffer:431:20,0x24b3608a4ef0,~
code-source-info,0x24b32697f536,18,12457,12891,C0O12484C2O12491C8O12536C14O12543C19O12567C25O12574C30O12587C35O12594C40O12611C41O12616C46O12634C51O12644C56O12681C59O12687C64O12717C66O12746C73O12752C78O12746C79O12803C85O12810C90O12823C95O12830C100O12847C101O12854C104O12861C109O12889,,
code-creation,LazyCompile,10,81674,0x24b32697f6ee,177,fromStringFast node:buffer:412:24,0x24b3608a4e50,~
code-source-info,0x24b32697f6ee,18,11913,12436,C0O11950C5O11950C11O11973C14O11995C18O12004C21O11984C26O12016C31O12052C36O12023C41O12065C42O12069C44O12083C49O12094C51O12092C54O12080C59O12111C62O12111C65O12135C72O12150C77O12161C85O12135C91O12203C110O12203C116O12234C118O12245C123O12329C130O12348C135O12359C143O12333C149O12386C156O12400C162O12397C168O12410C171O12410C174O12425C176O12434,,
code-creation,LazyCompile,10,81732,0x24b32697f8de,36,FastBuffer node:internal/buffer:958:14,0x24b3608b1a18,~
code-source-info,0x24b32697f8de,19,26364,26453,C3O26407C7O26441C20O26407C35O26452,,
code-creation,LazyCompile,10,81767,0x24b32697f9de,23,write node:buffer:592:12,0x24b3608a5260,~
code-source-info,0x24b32697f9de,18,16525,16589,C0O16559C17O16559C22O16589,,
code-creation,LazyCompile,10,81816,0x24b32697face,42,alignPool node:buffer:158:19,0x24b3608a4888,~
code-source-info,0x24b32697face,18,3998,4102,C0O4032C4O4047C9O4060C19O4071C25O4083C34O4093C41O4101,,
tick,0x10c7d3e8f,82228,1,0x10c345dc2,2,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b326978479,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
new,MemoryChunk,0x24b376400000,262144
code-creation,Eval,10,82520,0x24b37640196e,5, node:internal/webstreams/adapters:1:1,0x24b3764015a8,~
script-source,112,node:internal/webstreams/adapters,'use strict';\n\nconst {\n  ArrayPrototypeMap\x2C\n  PromiseAll\x2C\n  PromisePrototypeThen\x2C\n  PromisePrototypeFinally\x2C\n  PromiseResolve\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ReadableStream\x2C\n  isReadableStream\x2C\n} = require('internal/webstreams/readablestream');\n\nconst {\n  WritableStream\x2C\n  isWritableStream\x2C\n} = require('internal/webstreams/writablestream');\n\nconst {\n  CountQueuingStrategy\x2C\n} = require('internal/webstreams/queuingstrategies');\n\nconst {\n  Writable\x2C\n  Readable\x2C\n  Duplex\x2C\n  destroy\x2C\n} = require('stream');\n\nconst {\n  isDestroyed\x2C\n  isReadable\x2C\n  isReadableEnded\x2C\n  isWritable\x2C\n  isWritableEnded\x2C\n} = require('internal/streams/utils');\n\nconst {\n  Buffer\x2C\n} = require('buffer');\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_STATE\x2C\n    ERR_STREAM_PREMATURE_CLOSE\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\n\nconst {\n  createDeferredPromise\x2C\n} = require('internal/util');\n\nconst {\n  validateBoolean\x2C\n  validateObject\x2C\n} = require('internal/validators');\n\nconst {\n  WriteWrap\x2C\n  ShutdownWrap\x2C\n  kReadBytesOrError\x2C\n  kLastWriteWasAsync\x2C\n  streamBaseState\x2C\n} = internalBinding('stream_wrap');\n\nconst finished = require('internal/streams/end-of-stream');\n\nconst { UV_EOF } = internalBinding('uv');\n\n/**\n * @typedef {import('../../stream').Writable} Writable\n * @typedef {import('../../stream').Readable} Readable\n * @typedef {import('./writablestream').WritableStream} WritableStream\n * @typedef {import('./readablestream').ReadableStream} ReadableStream\n *\n * @typedef {import('../abort_controller').AbortSignal} AbortSignal\n */\n\n/**\n * @param {Writable} streamWritable\n * @returns {WritableStream}\n */\nfunction newWritableStreamFromStreamWritable(streamWritable) {\n  // Not using the internal/streams/utils isWritableNodeStream utility\n  // here because it will return false if streamWritable is a Duplex\n  // whose writable option is false. For a Duplex that is not writable\x2C\n  // we want it to pass this check but return a closed WritableStream.\n  if (typeof streamWritable?._writableState !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'streamWritable'\x2C\n      'stream.Writable'\x2C\n      streamWritable);\n  }\n\n  if (isDestroyed(streamWritable) || !isWritable(streamWritable)) {\n    const writable = new WritableStream();\n    writable.close();\n    return writable;\n  }\n\n  const highWaterMark = streamWritable.writableHighWaterMark;\n  const strategy =\n    streamWritable.writableObjectMode ?\n      new CountQueuingStrategy({ highWaterMark }) :\n      { highWaterMark };\n\n  let controller;\n  let backpressurePromise;\n  let closed;\n\n  function onDrain() {\n    if (backpressurePromise !== undefined)\n      backpressurePromise.resolve();\n  }\n\n  const cleanup = finished(streamWritable\x2C (error) => {\n    if (error?.code === 'ERR_STREAM_PREMATURE_CLOSE') {\n      const err = new AbortError();\n      err.cause = error;\n      error = err;\n    }\n\n    cleanup();\n    // This is a protection against non-standard\x2C legacy streams\n    // that happen to emit an error event again after finished is called.\n    streamWritable.on('error'\x2C () => {});\n    if (error != null) {\n      if (backpressurePromise !== undefined)\n        backpressurePromise.reject(error);\n      // If closed is not undefined\x2C the error is happening\n      // after the WritableStream close has already started.\n      // We need to reject it here.\n      if (closed !== undefined) {\n        closed.reject(error);\n        closed = undefined;\n      }\n      controller.error(error);\n      controller = undefined;\n      return;\n    }\n\n    if (closed !== undefined) {\n      closed.resolve();\n      closed = undefined;\n      return;\n    }\n    controller.error(new AbortError());\n    controller = undefined;\n  });\n\n  streamWritable.on('drain'\x2C onDrain);\n\n  return new WritableStream({\n    start(c) { controller = c; }\x2C\n\n    async write(chunk) {\n      if (streamWritable.writableNeedDrain || !streamWritable.write(chunk)) {\n        backpressurePromise = createDeferredPromise();\n        return PromisePrototypeFinally(\n          backpressurePromise.promise\x2C () => {\n            backpressurePromise = undefined;\n          });\n      }\n    }\x2C\n\n    abort(reason) {\n      destroy(streamWritable\x2C reason);\n    }\x2C\n\n    close() {\n      if (closed === undefined && !isWritableEnded(streamWritable)) {\n        closed = createDeferredPromise();\n        streamWritable.end();\n        return closed.promise;\n      }\n\n      controller = undefined;\n      return PromiseResolve();\n    }\x2C\n  }\x2C strategy);\n}\n\n/**\n * @param {WritableStream} writableStream\n * @param {{\n *   decodeStrings? : boolean\x2C\n *   highWaterMark? : number\x2C\n *   objectMode? : boolean\x2C\n *   signal? : AbortSignal\x2C\n * }} [options]\n * @returns {Writable}\n */\nfunction newStreamWritableFromWritableStream(writableStream\x2C options = {}) {\n  if (!isWritableStream(writableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'writableStream'\x2C\n      'WritableStream'\x2C\n      writableStream);\n  }\n\n  validateObject(options\x2C 'options');\n  const {\n    highWaterMark\x2C\n    decodeStrings = true\x2C\n    objectMode = false\x2C\n    signal\x2C\n  } = options;\n\n  validateBoolean(objectMode\x2C 'options.objectMode');\n  validateBoolean(decodeStrings\x2C 'options.decodeStrings');\n\n  const writer = writableStream.getWriter();\n  let closed = false;\n\n  const writable = new Writable({\n    highWaterMark\x2C\n    objectMode\x2C\n    decodeStrings\x2C\n    signal\x2C\n\n    writev(chunks\x2C callback) {\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => destroy(writable\x2C error));\n        }\n      }\n\n      PromisePrototypeThen(\n        writer.ready\x2C\n        () => {\n          return PromisePrototypeThen(\n            PromiseAll(\n              ArrayPrototypeMap(\n                chunks\x2C\n                (chunk) => writer.write(chunk)))\x2C\n            done\x2C\n            done);\n        }\x2C\n        done);\n    }\x2C\n\n    write(chunk\x2C encoding\x2C callback) {\n      if (typeof chunk === 'string' && decodeStrings && !objectMode) {\n        chunk = Buffer.from(chunk\x2C encoding);\n        chunk = new Uint8Array(\n          chunk.buffer\x2C\n          chunk.byteOffset\x2C\n          chunk.byteLength);\n      }\n\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error) {\n          destroy(writable\x2C error);\n        }\n      }\n\n      PromisePrototypeThen(\n        writer.ready\x2C\n        () => {\n          return PromisePrototypeThen(\n            writer.write(chunk)\x2C\n            done\x2C\n            done);\n        }\x2C\n        done);\n    }\x2C\n\n    destroy(error\x2C callback) {\n      function done() {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => { throw error; });\n        }\n      }\n\n      if (!closed) {\n        if (error != null) {\n          PromisePrototypeThen(\n            writer.abort(error)\x2C\n            done\x2C\n            done);\n        } else {\n          PromisePrototypeThen(\n            writer.close()\x2C\n            done\x2C\n            done);\n        }\n        return;\n      }\n\n      done();\n    }\x2C\n\n    final(callback) {\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => destroy(writable\x2C error));\n        }\n      }\n\n      if (!closed) {\n        PromisePrototypeThen(\n          writer.close()\x2C\n          done\x2C\n          done);\n      }\n    }\x2C\n  });\n\n  PromisePrototypeThen(\n    writer.closed\x2C\n    () => {\n      // If the WritableStream closes before the stream.Writable has been\n      // ended\x2C we signal an error on the stream.Writable.\n      closed = true;\n      if (!isWritableEnded(writable))\n        destroy(writable\x2C new ERR_STREAM_PREMATURE_CLOSE());\n    }\x2C\n    (error) => {\n      // If the WritableStream errors before the stream.Writable has been\n      // destroyed\x2C signal an error on the stream.Writable.\n      closed = true;\n      destroy(writable\x2C error);\n    });\n\n  return writable;\n}\n\n/**\n * @param {Readable} streamReadable\n * @returns {ReadableStream}\n */\nfunction newReadableStreamFromStreamReadable(streamReadable) {\n  // Not using the internal/streams/utils isReadableNodeStream utility\n  // here because it will return false if streamReadable is a Duplex\n  // whose readable option is false. For a Duplex that is not readable\x2C\n  // we want it to pass this check but return a closed ReadableStream.\n  if (typeof streamReadable?._readableState !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'streamReadable'\x2C\n      'stream.Readable'\x2C\n      streamReadable);\n  }\n\n  if (isDestroyed(streamReadable) || !isReadable(streamReadable)) {\n    const readable = new ReadableStream();\n    readable.cancel();\n    return readable;\n  }\n\n  const objectMode = streamReadable.readableObjectMode;\n  const highWaterMark = streamReadable.readableHighWaterMark;\n  // When not running in objectMode explicitly\x2C we just fall\n  // back to a minimal strategy that just specifies the highWaterMark\n  // and no size algorithm. Using a ByteLengthQueuingStrategy here\n  // is unnecessary.\n  const strategy =\n    objectMode ?\n      new CountQueuingStrategy({ highWaterMark }) :\n      { highWaterMark };\n\n  let controller;\n\n  function onData(chunk) {\n    // Copy the Buffer to detach it from the pool.\n    if (Buffer.isBuffer(chunk) && !objectMode)\n      chunk = new Uint8Array(chunk);\n    controller.enqueue(chunk);\n    if (controller.desiredSize <= 0)\n      streamReadable.pause();\n  }\n\n  streamReadable.pause();\n\n  const cleanup = finished(streamReadable\x2C (error) => {\n    if (error?.code === 'ERR_STREAM_PREMATURE_CLOSE') {\n      const err = new AbortError();\n      err.cause = error;\n      error = err;\n    }\n\n    cleanup();\n    // This is a protection against non-standard\x2C legacy streams\n    // that happen to emit an error event again after finished is called.\n    streamReadable.on('error'\x2C () => {});\n    if (error)\n      return controller.error(error);\n    controller.close();\n  });\n\n  streamReadable.on('data'\x2C onData);\n\n  return new ReadableStream({\n    start(c) { controller = c; }\x2C\n\n    pull() { streamReadable.resume(); }\x2C\n\n    cancel(reason) {\n      destroy(streamReadable\x2C reason);\n    }\x2C\n  }\x2C strategy);\n}\n\n/**\n * @param {ReadableStream} readableStream\n * @param {{\n *   highWaterMark? : number\x2C\n *   encoding? : string\x2C\n *   objectMode? : boolean\x2C\n *   signal? : AbortSignal\x2C\n * }} [options]\n * @returns {Readable}\n */\nfunction newStreamReadableFromReadableStream(readableStream\x2C options = {}) {\n  if (!isReadableStream(readableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'readableStream'\x2C\n      'ReadableStream'\x2C\n      readableStream);\n  }\n\n  validateObject(options\x2C 'options');\n  const {\n    highWaterMark\x2C\n    encoding\x2C\n    objectMode = false\x2C\n    signal\x2C\n  } = options;\n\n  if (encoding !== undefined && !Buffer.isEncoding(encoding))\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'options.encoding');\n  validateBoolean(objectMode\x2C 'options.objectMode');\n\n  const reader = readableStream.getReader();\n  let closed = false;\n\n  const readable = new Readable({\n    objectMode\x2C\n    highWaterMark\x2C\n    encoding\x2C\n    signal\x2C\n\n    read() {\n      PromisePrototypeThen(\n        reader.read()\x2C\n        (chunk) => {\n          if (chunk.done) {\n            // Value should always be undefined here.\n            readable.push(null);\n          } else {\n            readable.push(chunk.value);\n          }\n        }\x2C\n        (error) => destroy(readable\x2C error));\n    }\x2C\n\n    destroy(error\x2C callback) {\n      function done() {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => { throw error; });\n        }\n      }\n\n      if (!closed) {\n        PromisePrototypeThen(\n          reader.cancel(error)\x2C\n          done\x2C\n          done);\n        return;\n      }\n      done();\n    }\x2C\n  });\n\n  PromisePrototypeThen(\n    reader.closed\x2C\n    () => {\n      closed = true;\n      if (!isReadableEnded(readable))\n        readable.push(null);\n    }\x2C\n    (error) => {\n      closed = true;\n      destroy(readable\x2C error);\n    });\n\n  return readable;\n}\n\n/**\n * @typedef {import('./readablestream').ReadableWritablePair\n * } ReadableWritablePair\n * @typedef {import('../../stream').Duplex} Duplex\n *\n * @param {Duplex} duplex\n * @returns {ReadableWritablePair}\n */\nfunction newReadableWritablePairFromDuplex(duplex) {\n  // Not using the internal/streams/utils isWritableNodeStream and\n  // isReadableNodestream utilities here because they will return false\n  // if the duplex was created with writable or readable options set to\n  // false. Instead\x2C we'll check the readable and writable state after\n  // and return closed WritableStream or closed ReadableStream as\n  // necessary.\n  if (typeof duplex?._writableState !== 'object' ||\n      typeof duplex?._readableState !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('duplex'\x2C 'stream.Duplex'\x2C duplex);\n  }\n\n  if (isDestroyed(duplex)) {\n    const writable = new WritableStream();\n    const readable = new ReadableStream();\n    writable.close();\n    readable.cancel();\n    return { readable\x2C writable };\n  }\n\n  const writable =\n    isWritable(duplex) ?\n      newWritableStreamFromStreamWritable(duplex) :\n      new WritableStream();\n\n  if (!isWritable(duplex))\n    writable.close();\n\n  const readable =\n    isReadable(duplex) ?\n      newReadableStreamFromStreamReadable(duplex) :\n      new ReadableStream();\n\n  if (!isReadable(duplex))\n    readable.cancel();\n\n  return { writable\x2C readable };\n}\n\n/**\n * @param {ReadableWritablePair} pair\n * @param {{\n *   allowHalfOpen? : boolean\x2C\n *   decodeStrings? : boolean\x2C\n *   encoding? : string\x2C\n *   highWaterMark? : number\x2C\n *   objectMode? : boolean\x2C\n *   signal? : AbortSignal\x2C\n * }} [options]\n * @returns\n */\nfunction newStreamDuplexFromReadableWritablePair(pair = {}\x2C options = {}) {\n  validateObject(pair\x2C 'pair');\n  const {\n    readable: readableStream\x2C\n    writable: writableStream\x2C\n  } = pair;\n\n  if (!isReadableStream(readableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'pair.readable'\x2C\n      'ReadableStream'\x2C\n      readableStream);\n  }\n  if (!isWritableStream(writableStream)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'pair.writable'\x2C\n      'WritableStream'\x2C\n      writableStream);\n  }\n\n  validateObject(options\x2C 'options');\n  const {\n    allowHalfOpen = false\x2C\n    objectMode = false\x2C\n    encoding\x2C\n    decodeStrings = true\x2C\n    highWaterMark\x2C\n    signal\x2C\n  } = options;\n\n  validateBoolean(objectMode\x2C 'options.objectMode');\n  if (encoding !== undefined && !Buffer.isEncoding(encoding))\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'options.encoding');\n\n  const writer = writableStream.getWriter();\n  const reader = readableStream.getReader();\n  let writableClosed = false;\n  let readableClosed = false;\n\n  const duplex = new Duplex({\n    allowHalfOpen\x2C\n    highWaterMark\x2C\n    objectMode\x2C\n    encoding\x2C\n    decodeStrings\x2C\n    signal\x2C\n\n    writev(chunks\x2C callback) {\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => destroy(duplex\x2C error));\n        }\n      }\n\n      PromisePrototypeThen(\n        writer.ready\x2C\n        () => {\n          return PromisePrototypeThen(\n            PromiseAll(\n              ArrayPrototypeMap(\n                chunks\x2C\n                (chunk) => writer.write(chunk)))\x2C\n            done\x2C\n            done);\n        }\x2C\n        done);\n    }\x2C\n\n    write(chunk\x2C encoding\x2C callback) {\n      if (typeof chunk === 'string' && decodeStrings && !objectMode) {\n        chunk = Buffer.from(chunk\x2C encoding);\n        chunk = new Uint8Array(\n          chunk.buffer\x2C\n          chunk.byteOffset\x2C\n          chunk.byteLength);\n      }\n\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error) {\n          destroy(duplex\x2C error);\n        }\n      }\n\n      PromisePrototypeThen(\n        writer.ready\x2C\n        () => {\n          return PromisePrototypeThen(\n            writer.write(chunk)\x2C\n            done\x2C\n            done);\n        }\x2C\n        done);\n    }\x2C\n\n    final(callback) {\n      function done(error) {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => destroy(duplex\x2C error));\n        }\n      }\n\n      if (!writableClosed) {\n        PromisePrototypeThen(\n          writer.close()\x2C\n          done\x2C\n          done);\n      }\n    }\x2C\n\n    read() {\n      PromisePrototypeThen(\n        reader.read()\x2C\n        (chunk) => {\n          if (chunk.done) {\n            duplex.push(null);\n          } else {\n            duplex.push(chunk.value);\n          }\n        }\x2C\n        (error) => destroy(duplex\x2C error));\n    }\x2C\n\n    destroy(error\x2C callback) {\n      function done() {\n        try {\n          callback(error);\n        } catch (error) {\n          // In a next tick because this is happening within\n          // a promise context\x2C and if there are any errors\n          // thrown we don't want those to cause an unhandled\n          // rejection. Let's just escape the promise and\n          // handle it separately.\n          process.nextTick(() => { throw error; });\n        }\n      }\n\n      async function closeWriter() {\n        if (!writableClosed)\n          await writer.abort(error);\n      }\n\n      async function closeReader() {\n        if (!readableClosed)\n          await reader.cancel(error);\n      }\n\n      if (!writableClosed || !readableClosed) {\n        PromisePrototypeThen(\n          PromiseAll([\n            closeWriter()\x2C\n            closeReader()\x2C\n          ])\x2C\n          done\x2C\n          done);\n        return;\n      }\n\n      done();\n    }\x2C\n  });\n\n  PromisePrototypeThen(\n    writer.closed\x2C\n    () => {\n      writableClosed = true;\n      if (!isWritableEnded(duplex))\n        destroy(duplex\x2C new ERR_STREAM_PREMATURE_CLOSE());\n    }\x2C\n    (error) => {\n      writableClosed = true;\n      readableClosed = true;\n      destroy(duplex\x2C error);\n    });\n\n  PromisePrototypeThen(\n    reader.closed\x2C\n    () => {\n      readableClosed = true;\n      if (!isReadableEnded(duplex))\n        duplex.push(null);\n    }\x2C\n    (error) => {\n      writableClosed = true;\n      readableClosed = true;\n      destroy(duplex\x2C error);\n    });\n\n  return duplex;\n}\n\n/**\n * @typedef {import('./queuingstrategies').QueuingStrategy} QueuingStrategy\n * @typedef {{}} StreamBase\n * @param {StreamBase} streamBase\n * @param {QueuingStrategy} strategy\n * @returns {WritableStream}\n */\nfunction newWritableStreamFromStreamBase(streamBase\x2C strategy) {\n  validateObject(streamBase\x2C 'streamBase');\n\n  let current;\n\n  function createWriteWrap(controller\x2C promise) {\n    const req = new WriteWrap();\n    req.handle = streamBase;\n    req.oncomplete = onWriteComplete;\n    req.async = false;\n    req.bytes = 0;\n    req.buffer = null;\n    req.controller = controller;\n    req.promise = promise;\n    return req;\n  }\n\n  function onWriteComplete(status) {\n    if (status < 0) {\n      const error = errnoException(status\x2C 'write'\x2C this.error);\n      this.promise.reject(error);\n      this.controller.error(error);\n      return;\n    }\n    this.promise.resolve();\n  }\n\n  function doWrite(chunk\x2C controller) {\n    const promise = createDeferredPromise();\n    let ret;\n    let req;\n    try {\n      req = createWriteWrap(controller\x2C promise);\n      ret = streamBase.writeBuffer(req\x2C chunk);\n      if (streamBaseState[kLastWriteWasAsync])\n        req.buffer = chunk;\n      req.async = !!streamBaseState[kLastWriteWasAsync];\n    } catch (error) {\n      promise.reject(error);\n    }\n\n    if (ret !== 0)\n      promise.reject(errnoException(ret\x2C 'write'\x2C req));\n    else if (!req.async)\n      promise.resolve();\n\n    return promise.promise;\n  }\n\n  return new WritableStream({\n    write(chunk\x2C controller) {\n      current = current !== undefined ?\n        PromisePrototypeThen(\n          current\x2C\n          () => doWrite(chunk\x2C controller)\x2C\n          (error) => controller.error(error)) :\n        doWrite(chunk\x2C controller);\n      return current;\n    }\x2C\n\n    close() {\n      const promise = createDeferredPromise();\n      const req = new ShutdownWrap();\n      req.oncomplete = () => promise.resolve();\n      const err = streamBase.shutdown(req);\n      if (err === 1)\n        promise.resolve();\n      return promise.promise;\n    }\x2C\n  }\x2C strategy);\n}\n\n/**\n * @param {StreamBase} streamBase\n * @param {QueuingStrategy} strategy\n * @returns {ReadableStream}\n */\nfunction newReadableStreamFromStreamBase(streamBase\x2C strategy\x2C options = {}) {\n  validateObject(streamBase\x2C 'streamBase');\n  validateObject(options\x2C 'options');\n\n  const {\n    ondone = () => {}\x2C\n  } = options;\n\n  if (typeof streamBase.onread === 'function')\n    throw new ERR_INVALID_STATE('StreamBase already has a consumer');\n\n  if (typeof ondone !== 'function')\n    throw new ERR_INVALID_ARG_TYPE('options.ondone'\x2C 'Function'\x2C ondone);\n\n  let controller;\n\n  streamBase.onread = (arrayBuffer) => {\n    const nread = streamBaseState[kReadBytesOrError];\n\n    if (nread === 0)\n      return;\n\n    try {\n      if (nread === UV_EOF) {\n        controller.close();\n        streamBase.readStop();\n        try {\n          ondone();\n        } catch (error) {\n          controller.error(error);\n        }\n        return;\n      }\n\n      controller.enqueue(arrayBuffer);\n\n      if (controller.desiredSize <= 0)\n        streamBase.readStop();\n    } catch (error) {\n      controller.error(error);\n      streamBase.readStop();\n    }\n  };\n\n  return new ReadableStream({\n    start(c) { controller = c; }\x2C\n\n    pull() {\n      streamBase.readStart();\n    }\x2C\n\n    cancel() {\n      const promise = createDeferredPromise();\n      try {\n        ondone();\n      } catch (error) {\n        promise.reject(error);\n        return promise.promise;\n      }\n      const req = new ShutdownWrap();\n      req.oncomplete = () => promise.resolve();\n      const err = streamBase.shutdown(req);\n      if (err === 1)\n        promise.resolve();\n      return promise.promise;\n    }\x2C\n  }\x2C strategy);\n}\n\nmodule.exports = {\n  newWritableStreamFromStreamWritable\x2C\n  newReadableStreamFromStreamReadable\x2C\n  newStreamWritableFromWritableStream\x2C\n  newStreamReadableFromReadableStream\x2C\n  newReadableWritablePairFromDuplex\x2C\n  newStreamDuplexFromReadableWritablePair\x2C\n  newWritableStreamFromStreamBase\x2C\n  newReadableStreamFromStreamBase\x2C\n};\n
code-source-info,0x24b37640196e,112,0,23840,C0O0C4O23840,,
tick,0x10c6776e3,84152,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b326978479,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Function,10,84200,0x24b37640226e,541, node:internal/webstreams/adapters:1:1,0x24b3764018e8,~
code-source-info,0x24b37640226e,112,0,23840,C0O0C162O25C168O46C174O60C180O84C186O111C192O129C198O209C201O209C206O169C212O187C218O307C221O307C226O267C232O285C238O391C241O391C246O365C252O499C255O499C260O452C266O464C272O476C278O486C284O612C287O612C292O529C298O544C304O558C310O577C316O591C322O670C325O670C330O658C336O858C339O858C344O700C355O731C361O757C367O784C373O807C379O842C385O924C388O924C393O897C399O1000C402O1000C407O961C413O980C419O1136C422O1136C427O1043C433O1056C439O1072C445O1093C451O1115C457O1186C460O1186C464O1186C466O1249C469O1249C474O1238C480O23512C487O23533C493O23572C499O23611C505O23650C511O23689C517O23726C523O23769C529O23804C535O23527C540O23839,,
tick,0x10c7c7213,84796,1,0x10c345dc2,2,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b376402337,0x24b357dbe2b5,0x24b357dbd585,0x24b326978479,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
tick,0x10c653291,85928,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b376402337,0x24b357dbe2b5,0x24b357dbd585,0x24b326978479,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Eval,10,86170,0x24b376407a56,5, node:internal/webstreams/readablestream:1:1,0x24b376406ca0,~
script-source,113,node:internal/webstreams/readablestream,'use strict';\n\n/* eslint-disable no-use-before-define */\n\nconst {\n  ArrayBuffer\x2C\n  ArrayBufferPrototypeSlice\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  DataViewCtor\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  MathMin\x2C\n  NumberIsInteger\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromisePrototypeCatch\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  PromiseAll\x2C\n  ReflectConstruct\x2C\n  Symbol\x2C\n  SymbolAsyncIterator\x2C\n  SymbolToStringTag\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_STATE\x2C\n    ERR_INVALID_THIS\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  DOMException\x2C\n} = internalBinding('messaging');\n\nconst {\n  isArrayBufferView\x2C\n  isDataView\x2C\n} = require('internal/util/types');\n\nconst {\n  createDeferredPromise\x2C\n  customInspectSymbol: kInspect\x2C\n} = require('internal/util');\n\nconst {\n  serialize\x2C\n  deserialize\x2C\n} = require('v8');\n\nconst {\n  validateObject\x2C\n} = require('internal/validators');\n\nconst {\n  kAborted\x2C\n} = require('internal/abort_controller');\n\nconst {\n  MessageChannel\x2C\n} = require('internal/worker/io');\n\nconst {\n  kDeserialize\x2C\n  kTransfer\x2C\n  kTransferList\x2C\n  makeTransferable\x2C\n} = require('internal/worker/js_transferable');\n\nconst {\n  queueMicrotask\x2C\n} = require('internal/process/task_queues');\n\nconst {\n  kIsDisturbed\x2C\n} = require('internal/streams/utils');\n\nconst {\n  ArrayBufferViewGetBuffer\x2C\n  ArrayBufferViewGetByteLength\x2C\n  ArrayBufferViewGetByteOffset\x2C\n  ArrayBufferGetByteLength\x2C\n  AsyncIterator\x2C\n  copyArrayBuffer\x2C\n  customInspect\x2C\n  dequeueValue\x2C\n  ensureIsPromise\x2C\n  enqueueValueWithSize\x2C\n  extractHighWaterMark\x2C\n  extractSizeAlgorithm\x2C\n  lazyTransfer\x2C\n  isBrandCheck\x2C\n  resetQueue\x2C\n  setPromiseHandled\x2C\n  transferArrayBuffer\x2C\n  nonOpCancel\x2C\n  nonOpPull\x2C\n  nonOpStart\x2C\n  kType\x2C\n  kState\x2C\n  kEnumerableProperty\x2C\n} = require('internal/webstreams/util');\n\nconst {\n  WritableStreamDefaultWriter\x2C\n\n  isWritableStream\x2C\n  isWritableStreamLocked\x2C\n  isWritableStreamDefaultController\x2C\n  isWritableStreamDefaultWriter\x2C\n\n  writableStreamAbort\x2C\n  writableStreamCloseQueuedOrInFlight\x2C\n  writableStreamDefaultWriterCloseWithErrorPropagation\x2C\n  writableStreamDefaultWriterRelease\x2C\n  writableStreamDefaultWriterWrite\x2C\n} = require('internal/webstreams/writablestream');\n\nconst assert = require('internal/assert');\n\nconst kCancel = Symbol('kCancel');\nconst kClose = Symbol('kClose');\nconst kChunk = Symbol('kChunk');\nconst kError = Symbol('kError');\nconst kPull = Symbol('kPull');\n\n/**\n * @typedef {import('../abort_controller').AbortSignal} AbortSignal\n * @typedef {import('./queuingstrategies').QueuingStrategy} QueuingStrategy\n * @typedef {import('./queuingstrategies').QueuingStrategySize\n * } QueuingStrategySize\n * @typedef {import('./writablestream').WritableStream} WritableStream\n *\n * @typedef {ReadableStreamDefaultController | ReadableByteStreamController\n * } ReadableStreamController\n *\n * @typedef {ReadableStreamDefaultReader | ReadableStreamBYOBReader\n * } ReadableStreamReader\n *\n * @callback UnderlyingSourceStartCallback\n * @param {ReadableStreamController} controller\n * @returns { any | Promise<void> }\n *\n * @callback UnderlyingSourcePullCallback\n * @param {ReadableStreamController} controller\n * @returns { Promise<void> }\n *\n * @callback UnderlyingSourceCancelCallback\n * @param {any} reason\n * @returns { Promise<void> }\n *\n * @typedef {{\n *   readable: ReadableStream\x2C\n *   writable: WritableStream\x2C\n * }} ReadableWritablePair\n *\n * @typedef {{\n *   preventClose? : boolean\x2C\n *   preventAbort? : boolean\x2C\n *   preventCancel? : boolean\x2C\n *   signal? : AbortSignal\x2C\n * }} StreamPipeOptions\n *\n * @typedef {{\n *   start? : UnderlyingSourceStartCallback\x2C\n *   pull? : UnderlyingSourcePullCallback\x2C\n *   cancel? : UnderlyingSourceCancelCallback\x2C\n *   type? : "bytes"\x2C\n *   autoAllocateChunkSize? : number\n * }} UnderlyingSource\n *\n */\n\nclass ReadableStream {\n  [kType] = 'ReadableStream';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {UnderlyingSource} [source]\n   * @param {QueuingStrategy} [strategy]\n   */\n  constructor(source = {}\x2C strategy = {}) {\n    if (source === null)\n      throw new ERR_INVALID_ARG_VALUE('source'\x2C 'Object'\x2C source);\n    this[kState] = {\n      disturbed: false\x2C\n      state: 'readable'\x2C\n      storedError: undefined\x2C\n      stream: undefined\x2C\n      transfer: {\n        writable: undefined\x2C\n        port1: undefined\x2C\n        port2: undefined\x2C\n        promise: undefined\x2C\n      }\n    };\n\n    // The spec requires handling of the strategy first\n    // here. Specifically\x2C if getting the size and\n    // highWaterMark from the strategy fail\x2C that has\n    // to trigger a throw before getting the details\n    // from the source. So be sure to keep these in\n    // this order.\n    const size = strategy?.size;\n    const highWaterMark = strategy?.highWaterMark;\n    const type = source.type;\n\n    if (`${type}` === 'bytes') {\n      if (size !== undefined)\n        throw new ERR_INVALID_ARG_VALUE.RangeError('strategy.size'\x2C size);\n      setupReadableByteStreamControllerFromSource(\n        this\x2C\n        source\x2C\n        extractHighWaterMark(highWaterMark\x2C 0));\n      return;\n    }\n\n    if (type !== undefined)\n      throw new ERR_INVALID_ARG_VALUE('source.type'\x2C type);\n    setupReadableStreamDefaultControllerFromSource(\n      this\x2C\n      source\x2C\n      extractHighWaterMark(highWaterMark\x2C 1)\x2C\n      extractSizeAlgorithm(size));\n\n    // eslint-disable-next-line no-constructor-return\n    return makeTransferable(this);\n  }\n\n  get [kIsDisturbed]() {\n    return this[kState].disturbed;\n  }\n\n  /**\n   * @readonly\n   * @type {boolean}\n   */\n  get locked() {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    return isReadableStreamLocked(this);\n  }\n\n  /**\n   * @param {any} [reason]\n   * @returns { Promise<void> }\n   */\n  cancel(reason = undefined) {\n    if (!isReadableStream(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStream'));\n    if (isReadableStreamLocked(this)) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError('ReadableStream is locked'));\n    }\n    return readableStreamCancel(this\x2C reason);\n  }\n\n  /**\n   * @param {{\n   *   mode? : "byob"\n   * }} [options]\n   * @returns {ReadableStreamReader}\n   */\n  getReader(options = {}) {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    validateObject(options\x2C 'options'\x2C { nullable: true\x2C allowFunction: true });\n    const mode = options?.mode;\n\n    if (mode === undefined)\n      return new ReadableStreamDefaultReader(this);\n\n    if (`${mode}` !== 'byob')\n      throw new ERR_INVALID_ARG_VALUE('options.mode'\x2C mode);\n    return new ReadableStreamBYOBReader(this);\n  }\n\n  /**\n   * @param {ReadableWritablePair} transform\n   * @param {StreamPipeOptions} [options]\n   * @returns {ReadableStream}\n   */\n  pipeThrough(transform\x2C options = {}) {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    const readable = transform?.readable;\n    if (!isReadableStream(readable)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'transform.readable'\x2C\n        'ReadableStream'\x2C\n        readable);\n    }\n    const writable = transform?.writable;\n    if (!isWritableStream(writable)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'transform.writable'\x2C\n        'WritableStream'\x2C\n        writable);\n    }\n\n    // The web platform tests require that these be handled one at a\n    // time and in a specific order. options can be null or undefined.\n    const preventAbort = options?.preventAbort;\n    const preventCancel = options?.preventCancel;\n    const preventClose = options?.preventClose;\n    const signal = options?.signal;\n\n    if (signal !== undefined && signal?.[kAborted] === undefined)\n      throw new ERR_INVALID_ARG_TYPE('options.signal'\x2C 'AbortSignal'\x2C signal);\n\n    if (isReadableStreamLocked(this))\n      throw new ERR_INVALID_STATE.TypeError('The ReadableStream is locked');\n    if (isWritableStreamLocked(writable))\n      throw new ERR_INVALID_STATE.TypeError('The WritableStream is locked');\n\n    const promise = readableStreamPipeTo(\n      this\x2C\n      writable\x2C\n      !!preventClose\x2C\n      !!preventAbort\x2C\n      !!preventCancel\x2C\n      signal);\n    setPromiseHandled(promise);\n\n    return readable;\n  }\n\n  /**\n   * @param {WritableStream} destination\n   * @param {StreamPipeOptions} [options]\n   * @returns {Promise<void>}\n   */\n  pipeTo(destination\x2C options = {}) {\n    try {\n      if (!isReadableStream(this))\n        throw new ERR_INVALID_THIS('ReadableStream');\n      if (!isWritableStream(destination)) {\n        throw new ERR_INVALID_ARG_TYPE(\n          'transform.writable'\x2C\n          'WritableStream'\x2C\n          destination);\n      }\n\n      const preventAbort = options?.preventAbort;\n      const preventCancel = options?.preventCancel;\n      const preventClose = options?.preventClose;\n      const signal = options?.signal;\n\n      if (signal !== undefined && signal?.[kAborted] === undefined)\n        throw new ERR_INVALID_ARG_TYPE('options.signal'\x2C 'AbortSignal'\x2C signal);\n\n      if (isReadableStreamLocked(this))\n        throw new ERR_INVALID_STATE.TypeError('The ReadableStream is locked');\n      if (isWritableStreamLocked(destination))\n        throw new ERR_INVALID_STATE.TypeError('The WritableStream is locked');\n\n      return readableStreamPipeTo(\n        this\x2C\n        destination\x2C\n        !!preventClose\x2C\n        !!preventAbort\x2C\n        !!preventCancel\x2C\n        signal);\n    } catch (error) {\n      return PromiseReject(error);\n    }\n  }\n\n  /**\n   * @returns {ReadableStream[]}\n   */\n  tee() {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    return readableStreamTee(this\x2C false);\n  }\n\n  /**\n   * @param {{\n   *   preventCancel? : boolean\x2C\n   * }} [options]\n   * @returns {AsyncIterable}\n   */\n  values(options = {}) {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    validateObject(options\x2C 'options');\n    const {\n      preventCancel = false\x2C\n    } = options;\n\n    const reader = new ReadableStreamDefaultReader(this);\n    let done = false;\n    let started = false;\n    let current;\n\n    // The nextSteps function is not an async function in order\n    // to make it more efficient. Because nextSteps explicitly\n    // creates a Promise and returns it in the common case\x2C\n    // making it an async function just causes two additional\n    // unnecessary Promise allocations to occur\x2C which just add\n    // cost.\n    function nextSteps() {\n      if (done)\n        return PromiseResolve({ done: true\x2C value: undefined });\n\n      if (reader[kState].stream === undefined) {\n        return PromiseReject(\n          new ERR_INVALID_STATE.TypeError(\n            'The reader is not bound to a ReadableStream'));\n      }\n      const promise = createDeferredPromise();\n\n      readableStreamDefaultReaderRead(reader\x2C {\n        [kChunk](chunk) {\n          current = undefined;\n          promise.resolve({ value: chunk\x2C done: false });\n        }\x2C\n        [kClose]() {\n          current = undefined;\n          done = true;\n          readableStreamReaderGenericRelease(reader);\n          promise.resolve({ done: true\x2C value: undefined });\n        }\x2C\n        [kError](error) {\n          current = undefined;\n          done = true;\n          readableStreamReaderGenericRelease(reader);\n          promise.reject(error);\n        }\n      });\n      return promise.promise;\n    }\n\n    async function returnSteps(value) {\n      if (done)\n        return { done: true\x2C value };\n      done = true;\n\n      if (reader[kState].stream === undefined) {\n        throw new ERR_INVALID_STATE.TypeError(\n          'The reader is not bound to a ReadableStream');\n      }\n      assert(!reader[kState].readRequests.length);\n      if (!preventCancel) {\n        const result = readableStreamReaderGenericCancel(reader\x2C value);\n        readableStreamReaderGenericRelease(reader);\n        await result;\n        return { done: true\x2C value };\n      }\n\n      readableStreamReaderGenericRelease(reader);\n      return { done: true\x2C value };\n    }\n\n    // TODO(@jasnell): Explore whether an async generator\n    // can be used here instead of a custom iterator object.\n    return ObjectSetPrototypeOf({\n      // Changing either of these functions (next or return)\n      // to async functions causes a failure in the streams\n      // Web Platform Tests that check for use of a modified\n      // Promise.prototype.then. Since the await keyword\n      // uses Promise.prototype.then\x2C it is open to prototype\n      // pollution\x2C which causes the test to fail. The other\n      // await uses here do not trigger that failure because\n      // the test that fails does not trigger those code paths.\n      next() {\n        // If this is the first read\x2C delay by one microtask\n        // to ensure that the controller has had an opportunity\n        // to properly start and perform the initial pull.\n        // TODO(@jasnell): The spec doesn't call this out so\n        // need to investigate if it's a bug in our impl or\n        // the spec.\n        if (!started) {\n          current = PromiseResolve();\n          started = true;\n        }\n        current = current !== undefined ?\n          PromisePrototypeThen(current\x2C nextSteps\x2C nextSteps) :\n          nextSteps();\n        return current;\n      }\x2C\n\n      return(error) {\n        return current ?\n          PromisePrototypeThen(\n            current\x2C\n            () => returnSteps(error)\x2C\n            () => returnSteps(error)) :\n          returnSteps(error);\n      }\x2C\n\n      [SymbolAsyncIterator]() { return this; }\n    }\x2C AsyncIterator);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      locked: this.locked\x2C\n      state: this[kState].state\x2C\n    });\n  }\n\n  [kTransfer]() {\n    if (!isReadableStream(this))\n      throw new ERR_INVALID_THIS('ReadableStream');\n    if (this.locked) {\n      this[kState].transfer.port1?.close();\n      this[kState].transfer.port1 = undefined;\n      this[kState].transfer.port2 = undefined;\n      throw new DOMException(\n        'Cannot transfer a locked ReadableStream'\x2C\n        'DataCloneError');\n    }\n\n    const {\n      writable\x2C\n      promise\x2C\n    } = lazyTransfer().newCrossRealmWritableSink(\n      this\x2C\n      this[kState].transfer.port1);\n\n    this[kState].transfer.writable = writable;\n    this[kState].transfer.promise = promise;\n\n    return {\n      data: { port: this[kState].transfer.port2 }\x2C\n      deserializeInfo:\n        'internal/webstreams/readablestream:TransferredReadableStream'\n    };\n  }\n\n  [kTransferList]() {\n    const { port1\x2C port2 } = new MessageChannel();\n    this[kState].transfer.port1 = port1;\n    this[kState].transfer.port2 = port2;\n    return [ port2 ];\n  }\n\n  [kDeserialize]({ port }) {\n    const transfer = lazyTransfer();\n    setupReadableStreamDefaultControllerFromSource(\n      this\x2C\n      new transfer.CrossRealmTransformReadableSource(port)\x2C\n      0\x2C () => 1);\n  }\n}\n\nObjectDefineProperties(ReadableStream.prototype\x2C {\n  [SymbolAsyncIterator]: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    writable: true\x2C\n    value: ReadableStream.prototype.values\x2C\n  }\x2C\n  locked: kEnumerableProperty\x2C\n  cancel: kEnumerableProperty\x2C\n  getReader: kEnumerableProperty\x2C\n  pipeThrough: kEnumerableProperty\x2C\n  pipeTo: kEnumerableProperty\x2C\n  tee: kEnumerableProperty\x2C\n});\n\nfunction TransferredReadableStream() {\n  return makeTransferable(ReflectConstruct(\n    function() {\n      this[kType] = 'ReadableStream';\n      this[kState] = {\n        disturbed: false\x2C\n        state: 'readable'\x2C\n        storedError: undefined\x2C\n        stream: undefined\x2C\n        transfer: {\n          writable: undefined\x2C\n          port: undefined\x2C\n          promise: undefined\x2C\n        }\n      };\n    }\x2C\n    []\x2C ReadableStream));\n}\nTransferredReadableStream.prototype[kDeserialize] = () => {};\n\nclass ReadableStreamBYOBRequest {\n  [kType] = 'ReadableStreamBYOBRequest';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  /**\n   * @readonly\n   * @type {ArrayBufferView}\n   */\n  get view() {\n    if (!isReadableStreamBYOBRequest(this))\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBRequest');\n    return this[kState].view;\n  }\n\n  /**\n   * @param {number} bytesWritten\n   */\n  respond(bytesWritten) {\n    if (!isReadableStreamBYOBRequest(this))\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBRequest');\n    const {\n      view\x2C\n      controller\x2C\n    } = this[kState];\n    if (controller === undefined) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'This BYOB request has been invalidated');\n    }\n\n    const viewByteLength = ArrayBufferViewGetByteLength(view);\n    const viewBuffer = ArrayBufferViewGetBuffer(view);\n    const viewBufferByteLength = ArrayBufferGetByteLength(viewBuffer);\n\n    if (viewByteLength === 0 || viewBufferByteLength === 0) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'View ArrayBuffer is zero-length or detached');\n    }\n\n    readableByteStreamControllerRespond(controller\x2C bytesWritten);\n  }\n\n  /**\n   * @param {ArrayBufferView} view\n   */\n  respondWithNewView(view) {\n    if (!isReadableStreamBYOBRequest(this))\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBRequest');\n    const {\n      controller\x2C\n    } = this[kState];\n\n    if (controller === undefined) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'This BYOB request has been invalidated');\n    }\n\n    readableByteStreamControllerRespondWithNewView(controller\x2C view);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      view: this.view\x2C\n      controller: this[kState].controller\x2C\n    });\n  }\n}\n\nObjectDefineProperties(ReadableStreamBYOBRequest.prototype\x2C {\n  view: kEnumerableProperty\x2C\n  respond: kEnumerableProperty\x2C\n  respondWithNewView: kEnumerableProperty\x2C\n});\n\nfunction createReadableStreamBYOBRequest(controller\x2C view) {\n  return ReflectConstruct(\n    function() {\n      this[kType] = 'ReadableStreamBYOBRequest';\n      this[kState] = {\n        controller\x2C\n        view\x2C\n      };\n    }\x2C\n    []\x2C\n    ReadableStreamBYOBRequest\n  );\n}\n\nclass DefaultReadRequest {\n  constructor() {\n    this[kState] = createDeferredPromise();\n  }\n\n  [kChunk](value) {\n    this[kState].resolve?.({ value\x2C done: false });\n  }\n\n  [kClose]() {\n    this[kState].resolve?.({ value: undefined\x2C done: true });\n  }\n\n  [kError](error) {\n    this[kState].reject?.(error);\n  }\n\n  get promise() { return this[kState].promise; }\n}\n\nclass ReadIntoRequest {\n  constructor() {\n    this[kState] = createDeferredPromise();\n  }\n\n  [kChunk](value) {\n    this[kState].resolve?.({ value\x2C done: false });\n  }\n\n  [kClose](value) {\n    this[kState].resolve?.({ value\x2C done: true });\n  }\n\n  [kError](error) {\n    this[kState].reject?.(error);\n  }\n\n  get promise() { return this[kState].promise; }\n}\n\nclass ReadableStreamDefaultReader {\n  [kType] = 'ReadableStreamDefaultReader';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {ReadableStream} stream\n   */\n  constructor(stream) {\n    if (!isReadableStream(stream))\n      throw new ERR_INVALID_ARG_TYPE('stream'\x2C 'ReadableStream'\x2C stream);\n    this[kState] = {\n      readRequests: []\x2C\n      stream: undefined\x2C\n      close: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n    };\n    setupReadableStreamDefaultReader(this\x2C stream);\n  }\n\n  /**\n   * @returns {Promise<{\n   *   value : any\x2C\n   *   done : boolean\n   * }>}\n   */\n  read() {\n    if (!isReadableStreamDefaultReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamDefaultReader'));\n    if (this[kState].stream === undefined) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'The reader is not attached to a stream'));\n    }\n    const readRequest = new DefaultReadRequest();\n    readableStreamDefaultReaderRead(this\x2C readRequest);\n    return readRequest.promise;\n  }\n\n  releaseLock() {\n    if (!isReadableStreamDefaultReader(this))\n      throw new ERR_INVALID_THIS('ReadableStreamDefaultReader');\n    if (this[kState].stream === undefined)\n      return;\n    if (this[kState].readRequests.length) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'Cannot release with pending read requests');\n    }\n    readableStreamReaderGenericRelease(this);\n  }\n\n  /**\n   * @readonly\n   * @type {Promise<void>}\n   */\n  get closed() {\n    if (!isReadableStreamDefaultReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamDefaultReader'));\n    return this[kState].close.promise;\n  }\n\n  /**\n   * @param {any} reason\n   * @returns {Promise<void>}\n   */\n  cancel(reason = undefined) {\n    if (!isReadableStreamDefaultReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamDefaultReader'));\n    if (this[kState].stream === undefined) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\n        'The reader is not attached to a stream'));\n    }\n    return readableStreamReaderGenericCancel(this\x2C reason);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      stream: this[kState].stream\x2C\n      readRequests: this[kState].readRequests.length\x2C\n      close: this[kState].close.promise\x2C\n    });\n  }\n}\n\nObjectDefineProperties(ReadableStreamDefaultReader.prototype\x2C {\n  closed: kEnumerableProperty\x2C\n  read: kEnumerableProperty\x2C\n  releaseLock: kEnumerableProperty\x2C\n  cancel: kEnumerableProperty\x2C\n});\n\nclass ReadableStreamBYOBReader {\n  [kType] = 'ReadableStreamBYOBReader';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {ReadableStream} stream\n   */\n  constructor(stream) {\n    if (!isReadableStream(stream))\n      throw new ERR_INVALID_ARG_TYPE('stream'\x2C 'ReadableStream'\x2C stream);\n    this[kState] = {\n      stream: undefined\x2C\n      requestIntoRequests: []\x2C\n      close: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n    };\n    setupReadableStreamBYOBReader(this\x2C stream);\n  }\n\n  /**\n   * @param {ArrayBufferView} view\n   * @returns {Promise<{\n   *   view : ArrayBufferView\x2C\n   *   done : boolean\x2C\n   * }>}\n   */\n  read(view) {\n    if (!isReadableStreamBYOBReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamBYOBReader'));\n    if (!isArrayBufferView(view)) {\n      return PromiseReject(\n        new ERR_INVALID_ARG_TYPE(\n          'view'\x2C\n          [\n            'Buffer'\x2C\n            'TypedArray'\x2C\n            'DataView'\x2C\n          ]\x2C\n          view));\n    }\n    const viewByteLength = ArrayBufferViewGetByteLength(view);\n    const viewBuffer = ArrayBufferViewGetBuffer(view);\n    const viewBufferByteLength = ArrayBufferGetByteLength(viewBuffer);\n\n    if (viewByteLength === 0 || viewBufferByteLength === 0) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'View ArrayBuffer is zero-length or detached'));\n    }\n    // Supposed to assert here that the view's buffer is not\n    // detached\x2C but there's no API available to use to check that.\n    if (this[kState].stream === undefined) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'The reader is not attached to a stream'));\n    }\n    const readIntoRequest = new ReadIntoRequest();\n    readableStreamBYOBReaderRead(this\x2C view\x2C readIntoRequest);\n    return readIntoRequest.promise;\n  }\n\n  releaseLock() {\n    if (!isReadableStreamBYOBReader(this))\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBReader');\n    if (this[kState].stream === undefined)\n      return;\n    if (this[kState].readIntoRequests.length) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'Cannot release with pending read requests');\n    }\n    readableStreamReaderGenericRelease(this);\n  }\n\n  /**\n   * @readonly\n   * @type {Promise<void>}\n   */\n  get closed() {\n    if (!isReadableStreamBYOBReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamBYOBReader'));\n    return this[kState].close.promise;\n  }\n\n  /**\n   * @param {any} reason\n   * @returns {Promise<void>}\n   */\n  cancel(reason = undefined) {\n    if (!isReadableStreamBYOBReader(this))\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamBYOBReader'));\n    if (this[kState].stream === undefined) {\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\n        'The reader is not attached to a stream'));\n    }\n    return readableStreamReaderGenericCancel(this\x2C reason);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      stream: this[kState].stream\x2C\n      requestIntoRequests: this[kState].requestIntoRequests.length\x2C\n      close: this[kState].close.promise\x2C\n    });\n  }\n}\n\nObjectDefineProperties(ReadableStreamBYOBReader.prototype\x2C {\n  closed: kEnumerableProperty\x2C\n  read: kEnumerableProperty\x2C\n  releaseLock: kEnumerableProperty\x2C\n  cancel: kEnumerableProperty\x2C\n});\n\nclass ReadableStreamDefaultController {\n  [kType] = 'ReadableStreamDefaultController';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get desiredSize() {\n    return readableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (!readableStreamDefaultControllerCanCloseOrEnqueue(this))\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\n    readableStreamDefaultControllerClose(this);\n  }\n\n  /**\n   * @param {any} chunk\n   */\n  enqueue(chunk = undefined) {\n    if (!readableStreamDefaultControllerCanCloseOrEnqueue(this))\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\n    readableStreamDefaultControllerEnqueue(this\x2C chunk);\n  }\n\n  /**\n   * @param {any} error\n   */\n  error(error = undefined) {\n    readableStreamDefaultControllerError(this\x2C error);\n  }\n\n  [kCancel](reason) {\n    return readableStreamDefaultControllerCancelSteps(this\x2C reason);\n  }\n\n  [kPull](readRequest) {\n    readableStreamDefaultControllerPullSteps(this\x2C readRequest);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C { });\n  }\n}\n\nObjectDefineProperties(ReadableStreamDefaultController.prototype\x2C {\n  desiredSize: kEnumerableProperty\x2C\n  close: kEnumerableProperty\x2C\n  enqueue: kEnumerableProperty\x2C\n  error: kEnumerableProperty\x2C\n});\n\nfunction createReadableStreamDefaultController() {\n  return ReflectConstruct(\n    function() {\n      this[kType] = 'ReadableStreamDefaultController';\n      this[kState] = {};\n    }\x2C\n    []\x2C\n    ReadableStreamDefaultController\x2C\n  );\n}\n\nclass ReadableByteStreamController {\n  [kType] = 'ReadableByteStreamController';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  /**\n   * @readonly\n   * @type {ReadableStreamBYOBRequest}\n   */\n  get byobRequest() {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\n    if (this[kState].byobRequest === null &&\n        this[kState].pendingPullIntos.length) {\n      const {\n        buffer\x2C\n        byteOffset\x2C\n        bytesFilled\x2C\n        byteLength\x2C\n      } = this[kState].pendingPullIntos[0];\n      const view =\n        new Uint8Array(\n          buffer\x2C\n          byteOffset + bytesFilled\x2C\n          byteLength - bytesFilled);\n      this[kState].byobRequest = createReadableStreamBYOBRequest(this\x2C view);\n    }\n    return this[kState].byobRequest;\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get desiredSize() {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\n    return readableByteStreamControllerGetDesiredSize(this);\n  }\n\n  close() {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\n    if (this[kState].closeRequested)\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\n    if (this[kState].stream[kState].state !== 'readable')\n      throw new ERR_INVALID_STATE.TypeError('ReadableStream is already closed');\n    readableByteStreamControllerClose(this);\n  }\n\n  /**\n   * @param {ArrayBufferView} chunk\n   */\n  enqueue(chunk) {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\n    if (!isArrayBufferView(chunk)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'chunk'\x2C\n        [\n          'Buffer'\x2C\n          'TypedArray'\x2C\n          'DataView'\x2C\n        ]\x2C\n        chunk);\n    }\n    const chunkByteLength = ArrayBufferViewGetByteLength(chunk);\n    const chunkByteOffset = ArrayBufferViewGetByteOffset(chunk);\n    const chunkBuffer = ArrayBufferViewGetBuffer(chunk);\n    const chunkBufferByteLength = ArrayBufferGetByteLength(chunkBuffer);\n    if (chunkByteLength === 0 || chunkBufferByteLength === 0) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'chunk ArrayBuffer is zero-length or detached');\n    }\n    if (this[kState].closeRequested)\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\n    if (this[kState].stream[kState].state !== 'readable')\n      throw new ERR_INVALID_STATE.TypeError('ReadableStream is already closed');\n    readableByteStreamControllerEnqueue(\n      this\x2C\n      chunkBuffer\x2C\n      chunkByteLength\x2C\n      chunkByteOffset);\n  }\n\n  /**\n   * @param {any} error\n   */\n  error(error = undefined) {\n    if (!isReadableByteStreamController(this))\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\n    readableByteStreamControllerError(this\x2C error);\n  }\n\n  [kCancel](reason) {\n    return readableByteStreamControllerCancelSteps(this\x2C reason);\n  }\n\n  [kPull](readRequest) {\n    readableByteStreamControllerPullSteps(this\x2C readRequest);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C { });\n  }\n}\n\nObjectDefineProperties(ReadableByteStreamController.prototype\x2C {\n  byobRequest: kEnumerableProperty\x2C\n  desiredSize: kEnumerableProperty\x2C\n  close: kEnumerableProperty\x2C\n  enqueue: kEnumerableProperty\x2C\n  error: kEnumerableProperty\x2C\n});\n\nfunction createReadableByteStreamController() {\n  return ReflectConstruct(\n    function() {\n      this[kType] = 'ReadableByteStreamController';\n      this[kState] = {};\n    }\x2C\n    []\x2C\n    ReadableByteStreamController\x2C\n  );\n}\n\nfunction createTeeReadableStream(start\x2C pull\x2C cancel) {\n  return ReflectConstruct(\n    function() {\n      this[kType] = 'ReadableStream';\n      this[kState] = {\n        disturbed: false\x2C\n        state: 'readable'\x2C\n        storedError: undefined\x2C\n        stream: undefined\x2C\n        transfer: {\n          writable: undefined\x2C\n          port: undefined\x2C\n          promise: undefined\x2C\n        }\n      };\n      setupReadableStreamDefaultControllerFromSource(\n        this\x2C\n        ObjectCreate(null\x2C {\n          start: { value: start }\x2C\n          pull: { value: pull }\x2C\n          cancel: { value: cancel }\n        })\x2C\n        1\x2C\n        () => 1);\n      return makeTransferable(this);\n    }\x2C []\x2C ReadableStream\x2C\n  );\n}\n\nconst isReadableStream =\n  isBrandCheck('ReadableStream');\nconst isReadableByteStreamController =\n  isBrandCheck('ReadableByteStreamController');\nconst isReadableStreamBYOBRequest =\n  isBrandCheck('ReadableStreamBYOBRequest');\nconst isReadableStreamDefaultReader =\n  isBrandCheck('ReadableStreamDefaultReader');\nconst isReadableStreamBYOBReader =\n  isBrandCheck('ReadableStreamBYOBReader');\n\n// ---- ReadableStream Implementation\n\nfunction readableStreamPipeTo(\n  source\x2C\n  dest\x2C\n  preventClose\x2C\n  preventAbort\x2C\n  preventCancel\x2C\n  signal) {\n\n  let reader;\n  let writer;\n  // Both of these can throw synchronously. We want to capture\n  // the error and return a rejected promise instead.\n  try {\n    reader = new ReadableStreamDefaultReader(source);\n    writer = new WritableStreamDefaultWriter(dest);\n  } catch (error) {\n    return PromiseReject(error);\n  }\n\n  source[kState].disturbed = true;\n\n  let shuttingDown = false;\n\n  if (signal !== undefined && signal?.[kAborted] === undefined) {\n    return PromiseReject(\n      new ERR_INVALID_ARG_TYPE(\n        'options.signal'\x2C\n        'AbortSignal'\x2C\n        signal));\n  }\n\n  const promise = createDeferredPromise();\n\n  let currentWrite = PromiseResolve();\n\n  // The error here can be undefined. The rejected arg\n  // tells us that the promise must be rejected even\n  // when error is undefine.\n  function finalize(rejected\x2C error) {\n    writableStreamDefaultWriterRelease(writer);\n    readableStreamReaderGenericRelease(reader);\n    if (signal !== undefined)\n      signal.removeEventListener('abort'\x2C abortAlgorithm);\n    if (rejected)\n      promise.reject(error);\n    else\n      promise.resolve();\n  }\n\n  async function waitForCurrentWrite() {\n    const write = currentWrite;\n    await write;\n    if (write !== currentWrite)\n      await waitForCurrentWrite();\n  }\n\n  function shutdownWithAnAction(action\x2C rejected\x2C originalError) {\n    if (shuttingDown) return;\n    shuttingDown = true;\n    if (dest[kState].state === 'writable' &&\n        !writableStreamCloseQueuedOrInFlight(dest)) {\n      PromisePrototypeThen(\n        waitForCurrentWrite()\x2C\n        complete\x2C\n        (error) => finalize(true\x2C error));\n      return;\n    }\n    complete();\n\n    function complete() {\n      PromisePrototypeThen(\n        action()\x2C\n        () => finalize(rejected\x2C originalError)\x2C\n        (error) => finalize(true\x2C error));\n    }\n  }\n\n  function shutdown(rejected\x2C error) {\n    if (shuttingDown) return;\n    shuttingDown = true;\n    if (dest[kState].state === 'writable' &&\n        !writableStreamCloseQueuedOrInFlight(dest)) {\n      PromisePrototypeThen(\n        waitForCurrentWrite()\x2C\n        () => finalize(rejected\x2C error)\x2C\n        (error) => finalize(true\x2C error));\n      return;\n    }\n    finalize(rejected\x2C error);\n  }\n\n  function abortAlgorithm() {\n    // Cannot use the AbortError class here. It must be a DOMException\n    const error = new DOMException('The operation was aborted'\x2C 'AbortError');\n    const actions = [];\n    if (!preventAbort) {\n      ArrayPrototypePush(\n        actions\x2C\n        () => {\n          if (dest[kState].state === 'writable')\n            return writableStreamAbort(dest\x2C error);\n          return PromiseResolve();\n        });\n    }\n    if (!preventCancel) {\n      ArrayPrototypePush(\n        actions\x2C\n        () => {\n          if (source[kState].state === 'readable')\n            return readableStreamCancel(source\x2C error);\n          return PromiseResolve();\n        });\n    }\n\n    shutdownWithAnAction(\n      async () => PromiseAll(actions.map((action) => action()))\x2C\n      true\x2C\n      error);\n  }\n\n  function watchErrored(stream\x2C promise\x2C action) {\n    if (stream[kState].state === 'errored')\n      action(stream[kState].storedError);\n    else\n      PromisePrototypeCatch(promise\x2C action);\n  }\n\n  function watchClosed(stream\x2C promise\x2C action) {\n    if (stream[kState].state === 'closed')\n      action(stream[kState].storedError);\n    else\n      PromisePrototypeThen(promise\x2C action\x2C () => {});\n  }\n\n  async function step() {\n    if (shuttingDown)\n      return true;\n    await writer[kState].ready.promise;\n    return new Promise((resolve\x2C reject) => {\n      readableStreamDefaultReaderRead(\n        reader\x2C\n        {\n          [kChunk](chunk) {\n            currentWrite = writableStreamDefaultWriterWrite(writer\x2C chunk);\n            setPromiseHandled(currentWrite);\n            resolve(false);\n          }\x2C\n          [kClose]: () => resolve(true)\x2C\n          [kError]: reject\x2C\n        });\n    });\n  }\n\n  async function run() {\n    // Run until step resolves as true\n    while (!await step()) {}\n  }\n\n  if (signal !== undefined) {\n    if (signal.aborted) {\n      abortAlgorithm();\n      return promise.promise;\n    }\n    signal.addEventListener('abort'\x2C abortAlgorithm\x2C { once: true });\n  }\n\n  setPromiseHandled(run());\n\n  watchErrored(source\x2C reader[kState].close.promise\x2C (error) => {\n    if (!preventAbort) {\n      return shutdownWithAnAction(\n        () => writableStreamAbort(dest\x2C error)\x2C\n        true\x2C\n        error);\n    }\n    shutdown(true\x2C error);\n  });\n\n  watchErrored(dest\x2C writer[kState].close.promise\x2C (error) => {\n    if (!preventCancel) {\n      return shutdownWithAnAction(\n        () => readableStreamCancel(source\x2C error)\x2C\n        true\x2C\n        error);\n    }\n    shutdown(true\x2C error);\n  });\n\n  watchClosed(source\x2C reader[kState].close.promise\x2C () => {\n    if (!preventClose) {\n      return shutdownWithAnAction(\n        () => writableStreamDefaultWriterCloseWithErrorPropagation(writer));\n    }\n    shutdown();\n  });\n\n  if (writableStreamCloseQueuedOrInFlight(dest) ||\n      dest[kState].state === 'closed') {\n    const error = new ERR_INVALID_STATE.TypeError(\n      'Destination WritableStream is closed');\n    if (!preventCancel) {\n      shutdownWithAnAction(\n        () => readableStreamCancel(source\x2C error)\x2C true\x2C error);\n    } else {\n      shutdown(true\x2C error);\n    }\n  }\n\n  return promise.promise;\n}\n\nfunction readableStreamTee(stream\x2C cloneForBranch2) {\n  const reader = new ReadableStreamDefaultReader(stream);\n  let reading = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1;\n  let reason2;\n  let branch1;\n  let branch2;\n  const cancelPromise = createDeferredPromise();\n\n  async function pullAlgorithm() {\n    if (reading) return;\n    reading = true;\n    const readRequest = {\n      [kChunk](value) {\n        queueMicrotask(() => {\n          reading = false;\n          const value1 = value;\n          let value2 = value;\n          if (!canceled2 && cloneForBranch2) {\n            // Structured Clone\n            value2 = deserialize(serialize(value2));\n          }\n          if (!canceled1) {\n            readableStreamDefaultControllerEnqueue(\n              branch1[kState].controller\x2C\n              value1);\n          }\n          if (!canceled2) {\n            readableStreamDefaultControllerEnqueue(\n              branch2[kState].controller\x2C\n              value2);\n          }\n        });\n      }\x2C\n      [kClose]() {\n        reading = false;\n        if (!canceled1)\n          readableStreamDefaultControllerClose(branch1[kState].controller);\n        if (!canceled2)\n          readableStreamDefaultControllerClose(branch2[kState].controller);\n        if (!canceled1 || !canceled2)\n          cancelPromise.resolve();\n      }\x2C\n      [kError]() {\n        reading = false;\n      }\x2C\n    };\n    readableStreamDefaultReaderRead(reader\x2C readRequest);\n  }\n\n  function cancel1Algorithm(reason) {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = [reason1\x2C reason2];\n      cancelPromise.resolve(readableStreamCancel(stream\x2C compositeReason));\n    }\n    return cancelPromise.promise;\n  }\n\n  function cancel2Algorithm(reason) {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = [reason1\x2C reason2];\n      cancelPromise.resolve(readableStreamCancel(stream\x2C compositeReason));\n    }\n    return cancelPromise.promise;\n  }\n\n  branch1 =\n    createTeeReadableStream(nonOpStart\x2C pullAlgorithm\x2C cancel1Algorithm);\n  branch2 =\n    createTeeReadableStream(nonOpStart\x2C pullAlgorithm\x2C cancel2Algorithm);\n\n  PromisePrototypeCatch(\n    reader[kState].close.promise\x2C\n    (error) => {\n      readableStreamDefaultControllerError(branch1[kState].controller\x2C error);\n      readableStreamDefaultControllerError(branch2[kState].controller\x2C error);\n      if (!canceled1 || !canceled2)\n        cancelPromise.resolve();\n    });\n\n  return [branch1\x2C branch2];\n}\n\nfunction readableByteStreamControllerConvertPullIntoDescriptor(desc) {\n  const {\n    buffer\x2C\n    bytesFilled\x2C\n    byteLength\x2C\n    byteOffset\x2C\n    ctor\x2C\n    elementSize\x2C\n  } = desc;\n  if (bytesFilled > byteLength)\n    throw new ERR_INVALID_STATE.RangeError('The buffer size is invalid');\n  assert(!(bytesFilled % elementSize));\n  const transferredBuffer = transferArrayBuffer(buffer);\n  return new ctor(transferredBuffer\x2C byteOffset\x2C bytesFilled / elementSize);\n}\n\nfunction isReadableStreamLocked(stream) {\n  return stream[kState].reader !== undefined;\n}\n\nfunction readableStreamCancel(stream\x2C reason) {\n  stream[kState].disturbed = true;\n  switch (stream[kState].state) {\n    case 'closed':\n      return PromiseResolve();\n    case 'errored':\n      return PromiseReject(stream[kState].storedError);\n  }\n  readableStreamClose(stream);\n  const {\n    reader\x2C\n  } = stream[kState];\n  if (reader !== undefined && readableStreamHasBYOBReader(stream)) {\n    for (let n = 0; n < reader[kState].readIntoRequests.length; n++)\n      reader[kState].readIntoRequests[n][kClose]();\n    reader[kState].readIntoRequests = [];\n  }\n\n  return PromisePrototypeThen(\n    ensureIsPromise(\n      stream[kState].controller[kCancel]\x2C\n      stream[kState].controller\x2C\n      reason)\x2C\n    () => {});\n}\n\nfunction readableStreamClose(stream) {\n  assert(stream[kState].state === 'readable');\n  stream[kState].state = 'closed';\n\n  const {\n    reader\x2C\n  } = stream[kState];\n\n  if (reader === undefined)\n    return;\n\n  reader[kState].close.resolve();\n\n  if (readableStreamHasDefaultReader(stream)) {\n    for (let n = 0; n < reader[kState].readRequests.length; n++)\n      reader[kState].readRequests[n][kClose]();\n    reader[kState].readRequests = [];\n  }\n}\n\nfunction readableStreamError(stream\x2C error) {\n  assert(stream[kState].state === 'readable');\n  stream[kState].state = 'errored';\n  stream[kState].storedError = error;\n\n  const {\n    reader\n  } = stream[kState];\n\n  if (reader === undefined)\n    return;\n\n  reader[kState].close.reject(error);\n  setPromiseHandled(reader[kState].close.promise);\n\n  if (readableStreamHasDefaultReader(stream)) {\n    for (let n = 0; n < reader[kState].readRequests.length; n++)\n      reader[kState].readRequests[n][kError](error);\n    reader[kState].readRequests = [];\n  } else {\n    assert(readableStreamHasBYOBReader(stream));\n    for (let n = 0; n < reader[kState].readIntoRequests.length; n++)\n      reader[kState].readIntoRequests[n][kError](error);\n    reader[kState].readIntoRequests = [];\n  }\n}\n\nfunction readableStreamHasDefaultReader(stream) {\n  const {\n    reader\x2C\n  } = stream[kState];\n\n  if (reader === undefined)\n    return false;\n\n  return reader[kState] !== undefined &&\n         reader[kType] === 'ReadableStreamDefaultReader';\n}\n\nfunction readableStreamGetNumReadRequests(stream) {\n  assert(readableStreamHasDefaultReader(stream));\n  return stream[kState].reader[kState].readRequests.length;\n}\n\nfunction readableStreamHasBYOBReader(stream) {\n  const {\n    reader\x2C\n  } = stream[kState];\n\n  if (reader === undefined)\n    return false;\n\n  return reader[kState] !== undefined &&\n         reader[kType] === 'ReadableStreamBYOBReader';\n}\n\nfunction readableStreamGetNumReadIntoRequests(stream) {\n  assert(readableStreamHasBYOBReader(stream));\n  return stream[kState].reader[kState].readIntoRequests.length;\n}\n\nfunction readableStreamFulfillReadRequest(stream\x2C chunk\x2C done) {\n  assert(readableStreamHasDefaultReader(stream));\n  const {\n    reader\x2C\n  } = stream[kState];\n  assert(reader[kState].readRequests.length);\n  const readRequest = ArrayPrototypeShift(reader[kState].readRequests);\n\n  // TODO(@jasnell): It's not clear under what exact conditions done\n  // will be true here. The spec requires this check but none of the\n  // WPT's or other tests trigger it. Will need to investigate how to\n  // get coverage for this.\n  if (done)\n    readRequest[kClose]();\n  else\n    readRequest[kChunk](chunk);\n}\n\nfunction readableStreamFulfillReadIntoRequest(stream\x2C chunk\x2C done) {\n  assert(readableStreamHasBYOBReader(stream));\n  const {\n    reader\x2C\n  } = stream[kState];\n  assert(reader[kState].readIntoRequests.length);\n  const readIntoRequest = ArrayPrototypeShift(reader[kState].readIntoRequests);\n  if (done)\n    readIntoRequest[kClose](chunk);\n  else\n    readIntoRequest[kChunk](chunk);\n}\n\nfunction readableStreamAddReadRequest(stream\x2C readRequest) {\n  assert(readableStreamHasDefaultReader(stream));\n  assert(stream[kState].state === 'readable');\n  ArrayPrototypePush(stream[kState].reader[kState].readRequests\x2C readRequest);\n}\n\nfunction readableStreamAddReadIntoRequest(stream\x2C readIntoRequest) {\n  assert(readableStreamHasBYOBReader(stream));\n  assert(stream[kState].state !== 'errored');\n  ArrayPrototypePush(\n    stream[kState].reader[kState].readIntoRequests\x2C\n    readIntoRequest);\n}\n\nfunction readableStreamReaderGenericCancel(reader\x2C reason) {\n  const {\n    stream\x2C\n  } = reader[kState];\n  assert(stream !== undefined);\n  return readableStreamCancel(stream\x2C reason);\n}\n\nfunction readableStreamReaderGenericInitialize(reader\x2C stream) {\n  reader[kState].stream = stream;\n  stream[kState].reader = reader;\n  switch (stream[kState].state) {\n    case 'readable':\n      reader[kState].close = createDeferredPromise();\n      break;\n    case 'closed':\n      reader[kState].close = {\n        promise: PromiseResolve()\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      break;\n    case 'errored':\n      reader[kState].close = {\n        promise: PromiseReject(stream[kState].storedError)\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      setPromiseHandled(reader[kState].close.promise);\n      break;\n  }\n}\n\nfunction readableStreamReaderGenericRelease(reader) {\n  const {\n    stream\x2C\n  } = reader[kState];\n  assert(stream !== undefined);\n  assert(stream[kState].reader === reader);\n\n  if (stream[kState].state === 'readable') {\n    reader[kState].close.reject?.(\n      new ERR_INVALID_STATE.TypeError('Reader released'));\n  } else {\n    reader[kState].close = {\n      promise: PromiseReject(\n        new ERR_INVALID_STATE.TypeError('Reader released'))\x2C\n      resolve: undefined\x2C\n      reject: undefined\x2C\n    };\n  }\n  setPromiseHandled(reader[kState].close.promise);\n  stream[kState].reader = undefined;\n  reader[kState].stream = undefined;\n}\n\nfunction readableStreamBYOBReaderRead(reader\x2C view\x2C readIntoRequest) {\n  const {\n    stream\x2C\n  } = reader[kState];\n  assert(stream !== undefined);\n  stream[kState].disturbed = true;\n  if (stream[kState].state === 'errored') {\n    readIntoRequest[kError](stream[kState].storedError);\n    return;\n  }\n  readableByteStreamControllerPullInto(\n    stream[kState].controller\x2C\n    view\x2C\n    readIntoRequest);\n}\n\nfunction readableStreamDefaultReaderRead(reader\x2C readRequest) {\n  const {\n    stream\x2C\n  } = reader[kState];\n  assert(stream !== undefined);\n  stream[kState].disturbed = true;\n  switch (stream[kState].state) {\n    case 'closed':\n      readRequest[kClose]();\n      break;\n    case 'errored':\n      readRequest[kError](stream[kState].storedError);\n      break;\n    case 'readable':\n      stream[kState].controller[kPull](readRequest);\n  }\n}\n\nfunction setupReadableStreamBYOBReader(reader\x2C stream) {\n  if (isReadableStreamLocked(stream))\n    throw new ERR_INVALID_STATE.TypeError('ReadableStream is locked');\n  const {\n    controller\x2C\n  } = stream[kState];\n  if (!isReadableByteStreamController(controller))\n    throw new ERR_INVALID_ARG_VALUE('reader'\x2C reader\x2C 'must be a byte stream');\n  readableStreamReaderGenericInitialize(reader\x2C stream);\n  reader[kState].readIntoRequests = [];\n}\n\nfunction setupReadableStreamDefaultReader(reader\x2C stream) {\n  if (isReadableStreamLocked(stream))\n    throw new ERR_INVALID_STATE.TypeError('ReadableStream is locked');\n  readableStreamReaderGenericInitialize(reader\x2C stream);\n  reader[kState].readRequests = [];\n}\n\nfunction readableStreamDefaultControllerClose(controller) {\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller))\n    return;\n  controller[kState].closeRequested = true;\n  if (!controller[kState].queue.length) {\n    readableStreamDefaultControllerClearAlgorithms(controller);\n    readableStreamClose(controller[kState].stream);\n  }\n}\n\nfunction readableStreamDefaultControllerEnqueue(controller\x2C chunk) {\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller))\n    return;\n\n  const {\n    stream\x2C\n  } = controller[kState];\n\n  if (isReadableStreamLocked(stream) &&\n      readableStreamGetNumReadRequests(stream)) {\n    readableStreamFulfillReadRequest(stream\x2C chunk\x2C false);\n  } else {\n    try {\n      const chunkSize =\n        FunctionPrototypeCall(\n          controller[kState].sizeAlgorithm\x2C\n          undefined\x2C\n          chunk);\n      enqueueValueWithSize(controller\x2C chunk\x2C chunkSize);\n    } catch (error) {\n      readableStreamDefaultControllerError(controller\x2C error);\n      throw error;\n    }\n  }\n  readableStreamDefaultControllerCallPullIfNeeded(controller);\n}\n\nfunction readableStreamDefaultControllerHasBackpressure(controller) {\n  return !readableStreamDefaultControllerShouldCallPull(controller);\n}\n\nfunction readableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  return !controller[kState].closeRequested &&\n         stream[kState].state === 'readable';\n}\n\nfunction readableStreamDefaultControllerGetDesiredSize(controller) {\n  const {\n    stream\x2C\n    highWaterMark\x2C\n    queueTotalSize\x2C\n  } = controller[kState];\n  switch (stream[kState].state) {\n    case 'errored': return null;\n    case 'closed': return 0;\n    default:\n      return highWaterMark - queueTotalSize;\n  }\n}\n\nfunction readableStreamDefaultControllerShouldCallPull(controller) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller) ||\n      !controller[kState].started)\n    return false;\n\n  if (isReadableStreamLocked(stream) &&\n      readableStreamGetNumReadRequests(stream)) {\n    return true;\n  }\n\n  const desiredSize = readableStreamDefaultControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n\n  return desiredSize > 0;\n}\n\nfunction readableStreamDefaultControllerCallPullIfNeeded(controller) {\n  if (!readableStreamDefaultControllerShouldCallPull(controller))\n    return;\n  if (controller[kState].pulling) {\n    controller[kState].pullAgain = true;\n    return;\n  }\n  assert(!controller[kState].pullAgain);\n  controller[kState].pulling = true;\n  PromisePrototypeThen(\n    ensureIsPromise(controller[kState].pullAlgorithm\x2C controller)\x2C\n    () => {\n      controller[kState].pulling = false;\n      if (controller[kState].pullAgain) {\n        controller[kState].pullAgain = false;\n        readableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n    }\x2C\n    (error) => readableStreamDefaultControllerError(controller\x2C error));\n}\n\nfunction readableStreamDefaultControllerClearAlgorithms(controller) {\n  controller[kState].pullAlgorithm = undefined;\n  controller[kState].cancelAlgorithm = undefined;\n  controller[kState].sizeAlgorithm = undefined;\n}\n\nfunction readableStreamDefaultControllerError(controller\x2C error) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (stream[kState].state === 'readable') {\n    resetQueue(controller);\n    readableStreamDefaultControllerClearAlgorithms(controller);\n    readableStreamError(stream\x2C error);\n  }\n}\n\nfunction readableStreamDefaultControllerCancelSteps(controller\x2C reason) {\n  resetQueue(controller);\n  const result = controller[kState].cancelAlgorithm(reason);\n  readableStreamDefaultControllerClearAlgorithms(controller);\n  return result;\n}\n\nfunction readableStreamDefaultControllerPullSteps(controller\x2C readRequest) {\n  const {\n    stream\x2C\n    queue\x2C\n  } = controller[kState];\n  if (queue.length) {\n    const chunk = dequeueValue(controller);\n    if (controller[kState].closeRequested && !queue.length) {\n      readableStreamDefaultControllerClearAlgorithms(controller);\n      readableStreamClose(stream);\n    } else {\n      readableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\n    readRequest[kChunk](chunk);\n    return;\n  }\n  readableStreamAddReadRequest(stream\x2C readRequest);\n  readableStreamDefaultControllerCallPullIfNeeded(controller);\n}\n\nfunction setupReadableStreamDefaultController(\n  stream\x2C\n  controller\x2C\n  startAlgorithm\x2C\n  pullAlgorithm\x2C\n  cancelAlgorithm\x2C\n  highWaterMark\x2C\n  sizeAlgorithm) {\n  assert(stream[kState].controller === undefined);\n  controller[kState] = {\n    cancelAlgorithm\x2C\n    closeRequested: false\x2C\n    highWaterMark\x2C\n    pullAgain: false\x2C\n    pullAlgorithm\x2C\n    pulling: false\x2C\n    queue: []\x2C\n    queueTotalSize: 0\x2C\n    started: false\x2C\n    sizeAlgorithm\x2C\n    stream\x2C\n  };\n  stream[kState].controller = controller;\n\n  const startResult = startAlgorithm();\n\n  PromisePrototypeThen(\n    PromiseResolve(startResult)\x2C\n    () => {\n      controller[kState].started = true;\n      assert(!controller[kState].pulling);\n      assert(!controller[kState].pullAgain);\n      readableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\x2C\n    (error) => readableStreamDefaultControllerError(controller\x2C error));\n}\n\nfunction setupReadableStreamDefaultControllerFromSource(\n  stream\x2C\n  source\x2C\n  highWaterMark\x2C\n  sizeAlgorithm) {\n  const controller = createReadableStreamDefaultController();\n  const start = source?.start;\n  const pull = source?.pull;\n  const cancel = source?.cancel;\n  const startAlgorithm = start ?\n    FunctionPrototypeBind(start\x2C source\x2C controller) :\n    nonOpStart;\n  const pullAlgorithm = pull ?\n    FunctionPrototypeBind(pull\x2C source\x2C controller) :\n    nonOpPull;\n\n  const cancelAlgorithm = cancel ?\n    FunctionPrototypeBind(cancel\x2C source) :\n    nonOpCancel;\n\n  setupReadableStreamDefaultController(\n    stream\x2C\n    controller\x2C\n    startAlgorithm\x2C\n    pullAlgorithm\x2C\n    cancelAlgorithm\x2C\n    highWaterMark\x2C\n    sizeAlgorithm);\n}\n\nfunction readableByteStreamControllerClose(controller) {\n  const {\n    closeRequested\x2C\n    pendingPullIntos\x2C\n    queueTotalSize\x2C\n    stream\x2C\n  } = controller[kState];\n\n  if (closeRequested || stream[kState].state !== 'readable')\n    return;\n\n  if (queueTotalSize) {\n    controller[kState].closeRequested = true;\n    return;\n  }\n\n  if (pendingPullIntos.length) {\n    const firstPendingPullInto = pendingPullIntos[0];\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const error = new ERR_INVALID_STATE.TypeError('Partial read');\n      readableByteStreamControllerError(controller\x2C error);\n      throw error;\n    }\n  }\n\n  readableByteStreamControllerClearAlgorithms(controller);\n  readableStreamClose(stream);\n}\n\nfunction readableByteStreamControllerCommitPullIntoDescriptor(stream\x2C desc) {\n  assert(stream[kState].state !== 'errored');\n  let done = false;\n  if (stream[kState].state === 'closed') {\n    desc.bytesFilled = 0;\n    done = true;\n  }\n\n  const filledView =\n    readableByteStreamControllerConvertPullIntoDescriptor(desc);\n\n  if (desc.type === 'default') {\n    readableStreamFulfillReadRequest(stream\x2C filledView\x2C done);\n  } else {\n    assert(desc.type === 'byob');\n    readableStreamFulfillReadIntoRequest(stream\x2C filledView\x2C done);\n  }\n}\n\nfunction readableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller[kState].byobRequest === null)\n    return;\n  controller[kState].byobRequest[kState].controller = undefined;\n  controller[kState].byobRequest[kState].view = null;\n  controller[kState].byobRequest = null;\n}\n\nfunction readableByteStreamControllerClearAlgorithms(controller) {\n  controller[kState].pullAlgorithm = undefined;\n  controller[kState].cancelAlgorithm = undefined;\n}\n\nfunction readableByteStreamControllerClearPendingPullIntos(controller) {\n  readableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller[kState].pendingPullIntos = [];\n}\n\nfunction readableByteStreamControllerGetDesiredSize(controller) {\n  const {\n    stream\x2C\n    highWaterMark\x2C\n    queueTotalSize\x2C\n  } = controller[kState];\n  switch (stream[kState].state) {\n    case 'errored': return null;\n    case 'closed': return 0;\n    default: return highWaterMark - queueTotalSize;\n  }\n}\n\nfunction readableByteStreamControllerShouldCallPull(controller) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (stream[kState].state !== 'readable' ||\n      controller[kState].closeRequested ||\n      !controller[kState].started) {\n    return false;\n  }\n  if (readableStreamHasDefaultReader(stream) &&\n      readableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (readableStreamHasBYOBReader(stream) &&\n      readableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = readableByteStreamControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n\n  return desiredSize > 0;\n}\n\nfunction readableByteStreamControllerHandleQueueDrain(controller) {\n  const {\n    closeRequested\x2C\n    queueTotalSize\x2C\n    stream\x2C\n  } = controller[kState];\n  assert(stream[kState].state === 'readable');\n  if (!queueTotalSize && closeRequested) {\n    readableByteStreamControllerClearAlgorithms(controller);\n    readableStreamClose(stream);\n    return;\n  }\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction readableByteStreamControllerPullInto(\n  controller\x2C\n  view\x2C\n  readIntoRequest) {\n  const {\n    closeRequested\x2C\n    stream\x2C\n    pendingPullIntos\x2C\n  } = controller[kState];\n  let elementSize = 1;\n  let ctor = DataViewCtor;\n  if (isArrayBufferView(view) && !isDataView(view)) {\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\n    ctor = view.constructor;\n  }\n  const buffer = ArrayBufferViewGetBuffer(view);\n  const byteOffset = ArrayBufferViewGetByteOffset(view);\n  const byteLength = ArrayBufferViewGetByteLength(view);\n  const bufferByteLength = ArrayBufferGetByteLength(buffer);\n\n  let transferredBuffer;\n  try {\n    transferredBuffer = transferArrayBuffer(buffer);\n  } catch (error) {\n    readIntoRequest[kError](error);\n    return;\n  }\n  const desc = {\n    buffer: transferredBuffer\x2C\n    bufferByteLength\x2C\n    byteOffset\x2C\n    byteLength\x2C\n    bytesFilled: 0\x2C\n    elementSize\x2C\n    ctor\x2C\n    type: 'byob'\x2C\n  };\n  if (pendingPullIntos.length) {\n    ArrayPrototypePush(pendingPullIntos\x2C desc);\n    readableStreamAddReadIntoRequest(stream\x2C readIntoRequest);\n    return;\n  }\n  if (stream[kState].state === 'closed') {\n    const emptyView = new ctor(desc.buffer\x2C byteOffset\x2C 0);\n    readIntoRequest[kClose](emptyView);\n    return;\n  }\n  if (controller[kState].queueTotalSize) {\n    if (readableByteStreamControllerFillPullIntoDescriptorFromQueue(\n      controller\x2C\n      desc)) {\n      const filledView =\n        readableByteStreamControllerConvertPullIntoDescriptor(desc);\n      readableByteStreamControllerHandleQueueDrain(controller);\n      readIntoRequest[kChunk](filledView);\n      return;\n    }\n    if (closeRequested) {\n      const error = new ERR_INVALID_STATE.TypeError('ReadableStream closed');\n      readableByteStreamControllerError(controller\x2C error);\n      readIntoRequest[kError](error);\n      return;\n    }\n  }\n  ArrayPrototypePush(pendingPullIntos\x2C desc);\n  readableStreamAddReadIntoRequest(stream\x2C readIntoRequest);\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction readableByteStreamControllerRespondInternal(controller\x2C bytesWritten) {\n  const {\n    stream\x2C\n    pendingPullIntos\x2C\n  } = controller[kState];\n  const desc = pendingPullIntos[0];\n  readableByteStreamControllerInvalidateBYOBRequest(controller);\n  if (stream[kState].state === 'closed') {\n    if (bytesWritten)\n      throw new ERR_INVALID_STATE.TypeError(\n        'Controller is closed but view is not zero-length');\n    readableByteStreamControllerRespondInClosedState(controller\x2C desc);\n  } else {\n    assert(stream[kState].state === 'readable');\n    if (!bytesWritten)\n      throw new ERR_INVALID_STATE.TypeError('View cannot be zero-length');\n    readableByteStreamControllerRespondInReadableState(\n      controller\x2C\n      bytesWritten\x2C\n      desc);\n  }\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction readableByteStreamControllerRespond(controller\x2C bytesWritten) {\n  const {\n    pendingPullIntos\x2C\n    stream\x2C\n  } = controller[kState];\n  assert(pendingPullIntos.length);\n  const desc = pendingPullIntos[0];\n\n  if (stream[kState].state === 'closed') {\n    if (bytesWritten !== 0)\n      throw new ERR_INVALID_ARG_VALUE('bytesWritten'\x2C bytesWritten);\n  } else {\n    assert(stream[kState].state === 'readable');\n\n    if (!bytesWritten)\n      throw new ERR_INVALID_ARG_VALUE('bytesWritten'\x2C bytesWritten);\n\n    if ((desc.bytesFilled + bytesWritten) > desc.byteLength)\n      throw new ERR_INVALID_ARG_VALUE.RangeError('bytesWritten'\x2C bytesWritten);\n  }\n\n  desc.buffer = transferArrayBuffer(desc.buffer);\n\n  readableByteStreamControllerRespondInternal(controller\x2C bytesWritten);\n}\n\nfunction readableByteStreamControllerRespondInClosedState(controller\x2C desc) {\n  assert(!desc.bytesFilled);\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (readableStreamHasBYOBReader(stream)) {\n    while (readableStreamGetNumReadIntoRequests(stream) > 0) {\n      readableByteStreamControllerCommitPullIntoDescriptor(\n        stream\x2C\n        readableByteStreamControllerShiftPendingPullInto(controller));\n    }\n  }\n}\n\nfunction readableByteStreamControllerFillHeadPullIntoDescriptor(\n  controller\x2C\n  size\x2C\n  desc) {\n  const {\n    pendingPullIntos\x2C\n    byobRequest\x2C\n  } = controller[kState];\n  assert(!pendingPullIntos.length || pendingPullIntos[0] === desc);\n  assert(byobRequest === null);\n  desc.bytesFilled += size;\n}\n\nfunction readableByteStreamControllerEnqueue(\n  controller\x2C\n  buffer\x2C\n  byteLength\x2C\n  byteOffset) {\n  const {\n    closeRequested\x2C\n    pendingPullIntos\x2C\n    queue\x2C\n    stream\x2C\n  } = controller[kState];\n\n  if (closeRequested || stream[kState].state !== 'readable')\n    return;\n\n  const transferredBuffer = transferArrayBuffer(buffer);\n\n  if (pendingPullIntos.length) {\n    const firstPendingPullInto = pendingPullIntos[0];\n\n    const pendingBufferByteLength =\n      ArrayBufferGetByteLength(firstPendingPullInto.buffer);\n    if (pendingBufferByteLength === 0) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'Destination ArrayBuffer is zero-length or detached');\n    }\n\n    firstPendingPullInto.buffer =\n      transferArrayBuffer(firstPendingPullInto.buffer);\n  }\n\n  readableByteStreamControllerInvalidateBYOBRequest(controller);\n\n  if (readableStreamHasDefaultReader(stream)) {\n    if (!readableStreamGetNumReadRequests(stream)) {\n      readableByteStreamControllerEnqueueChunkToQueue(\n        controller\x2C\n        transferredBuffer\x2C\n        byteOffset\x2C\n        byteLength);\n    } else {\n      assert(!queue.length);\n      const transferredView =\n        new Uint8Array(transferredBuffer\x2C byteOffset\x2C byteLength);\n      readableStreamFulfillReadRequest(stream\x2C transferredView\x2C false);\n    }\n  } else if (readableStreamHasBYOBReader(stream)) {\n    readableByteStreamControllerEnqueueChunkToQueue(\n      controller\x2C\n      transferredBuffer\x2C\n      byteOffset\x2C\n      byteLength);\n    readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(\n      controller);\n  } else {\n    assert(!isReadableStreamLocked(stream));\n    readableByteStreamControllerEnqueueChunkToQueue(\n      controller\x2C\n      transferredBuffer\x2C\n      byteOffset\x2C\n      byteLength);\n  }\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction readableByteStreamControllerEnqueueChunkToQueue(\n  controller\x2C\n  buffer\x2C\n  byteOffset\x2C\n  byteLength) {\n  ArrayPrototypePush(\n    controller[kState].queue\x2C\n    {\n      buffer\x2C\n      byteOffset\x2C\n      byteLength\x2C\n    });\n  controller[kState].queueTotalSize += byteLength;\n}\n\nfunction readableByteStreamControllerFillPullIntoDescriptorFromQueue(\n  controller\x2C\n  desc) {\n  const {\n    buffer\x2C\n    byteLength\x2C\n    byteOffset\x2C\n    bytesFilled\x2C\n    elementSize\x2C\n  } = desc;\n  const currentAlignedBytes = bytesFilled - (bytesFilled % elementSize);\n  const maxBytesToCopy = MathMin(\n    controller[kState].queueTotalSize\x2C\n    byteLength - bytesFilled);\n  const maxBytesFilled = bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - (maxBytesFilled % elementSize);\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - bytesFilled;\n    ready = true;\n  }\n  const {\n    queue\x2C\n  } = controller[kState];\n\n  while (totalBytesToCopyRemaining) {\n    const headOfQueue = queue[0];\n    const bytesToCopy = MathMin(\n      totalBytesToCopyRemaining\x2C\n      headOfQueue.byteLength);\n    const destStart = byteOffset + desc.bytesFilled;\n    const arrayBufferByteLength = ArrayBufferGetByteLength(buffer);\n    if (arrayBufferByteLength - destStart < bytesToCopy) {\n      throw new ERR_INVALID_STATE.RangeError(\n        'view ArrayBuffer size is invalid');\n    }\n    assert(arrayBufferByteLength - destStart >= bytesToCopy);\n    copyArrayBuffer(\n      buffer\x2C\n      destStart\x2C\n      headOfQueue.buffer\x2C\n      headOfQueue.byteOffset\x2C\n      bytesToCopy);\n    if (headOfQueue.byteLength === bytesToCopy) {\n      ArrayPrototypeShift(queue);\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller[kState].queueTotalSize -= bytesToCopy;\n    readableByteStreamControllerFillHeadPullIntoDescriptor(\n      controller\x2C\n      bytesToCopy\x2C\n      desc);\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (!ready) {\n    assert(!controller[kState].queueTotalSize);\n    assert(desc.bytesFilled > 0);\n    assert(desc.bytesFilled < elementSize);\n  }\n  return ready;\n}\n\nfunction readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(\n  controller) {\n  const {\n    closeRequested\x2C\n    pendingPullIntos\x2C\n    stream\x2C\n  } = controller[kState];\n  assert(!closeRequested);\n  while (pendingPullIntos.length) {\n    if (!controller[kState].queueTotalSize)\n      return;\n    const desc = pendingPullIntos[0];\n    if (readableByteStreamControllerFillPullIntoDescriptorFromQueue(\n      controller\x2C\n      desc)) {\n      readableByteStreamControllerShiftPendingPullInto(controller);\n      readableByteStreamControllerCommitPullIntoDescriptor(stream\x2C desc);\n    }\n  }\n}\n\nfunction readableByteStreamControllerRespondInReadableState(\n  controller\x2C\n  bytesWritten\x2C\n  desc) {\n  const {\n    buffer\x2C\n    bytesFilled\x2C\n    byteLength\x2C\n  } = desc;\n\n  if (bytesFilled + bytesWritten > byteLength)\n    throw new ERR_INVALID_STATE.RangeError('The buffer size is invalid');\n\n  readableByteStreamControllerFillHeadPullIntoDescriptor(\n    controller\x2C\n    bytesWritten\x2C\n    desc);\n\n  if (desc.bytesFilled < desc.elementSize)\n    return;\n\n  readableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = desc.bytesFilled % desc.elementSize;\n\n  if (remainderSize) {\n    const end = desc.byteOffset + desc.bytesFilled;\n    const start = end - remainderSize;\n    const remainder =\n      ArrayBufferPrototypeSlice(\n        buffer\x2C\n        start\x2C\n        end);\n    readableByteStreamControllerEnqueueChunkToQueue(\n      controller\x2C\n      remainder\x2C\n      0\x2C\n      ArrayBufferGetByteLength(remainder));\n  }\n  desc.bytesFilled -= remainderSize;\n  readableByteStreamControllerCommitPullIntoDescriptor(\n    controller[kState].stream\x2C\n    desc);\n  readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction readableByteStreamControllerRespondWithNewView(controller\x2C view) {\n  const {\n    stream\x2C\n    pendingPullIntos\x2C\n  } = controller[kState];\n  assert(pendingPullIntos.length);\n\n  const desc = pendingPullIntos[0];\n  assert(stream[kState].state !== 'errored');\n\n  if (!isArrayBufferView(view)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'view'\x2C\n      [\n        'Buffer'\x2C\n        'TypedArray'\x2C\n        'DataView'\x2C\n      ]\x2C\n      view);\n  }\n  const viewByteLength = ArrayBufferViewGetByteLength(view);\n  const viewByteOffset = ArrayBufferViewGetByteOffset(view);\n  const viewBuffer = ArrayBufferViewGetBuffer(view);\n  const viewBufferByteLength = ArrayBufferGetByteLength(viewBuffer);\n\n  const {\n    byteOffset\x2C\n    byteLength\x2C\n    bytesFilled\x2C\n    bufferByteLength\x2C\n  } = desc;\n\n  if (byteOffset + bytesFilled !== viewByteOffset)\n    throw new ERR_INVALID_ARG_VALUE.RangeError('view'\x2C view);\n\n  if (bytesFilled + viewByteOffset > byteLength)\n    throw new ERR_INVALID_ARG_VALUE.RangeError('view'\x2C view);\n\n  if (bufferByteLength !== viewBufferByteLength)\n    throw new ERR_INVALID_ARG_VALUE.RangeError('view'\x2C view);\n\n  desc.buffer = transferArrayBuffer(viewBuffer);\n\n  readableByteStreamControllerRespondInternal(controller\x2C viewByteLength);\n}\n\nfunction readableByteStreamControllerShiftPendingPullInto(controller) {\n  assert(controller[kState].byobRequest === null);\n  return ArrayPrototypeShift(controller[kState].pendingPullIntos);\n}\n\nfunction readableByteStreamControllerCallPullIfNeeded(controller) {\n  if (!readableByteStreamControllerShouldCallPull(controller))\n    return;\n  if (controller[kState].pulling) {\n    controller[kState].pullAgain = true;\n    return;\n  }\n  assert(!controller[kState].pullAgain);\n  controller[kState].pulling = true;\n  PromisePrototypeThen(\n    ensureIsPromise(controller[kState].pullAlgorithm\x2C controller)\x2C\n    () => {\n      controller[kState].pulling = false;\n      if (controller[kState].pullAgain) {\n        controller[kState].pullAgain = false;\n        readableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    }\x2C\n    (error) => readableByteStreamControllerError(controller\x2C error));\n}\n\nfunction readableByteStreamControllerError(controller\x2C error) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (stream[kState].state !== 'readable')\n    return;\n  readableByteStreamControllerClearPendingPullIntos(controller);\n  resetQueue(controller);\n  readableByteStreamControllerClearAlgorithms(controller);\n  readableStreamError(stream\x2C error);\n}\n\nfunction readableByteStreamControllerCancelSteps(controller\x2C reason) {\n  readableByteStreamControllerClearPendingPullIntos(controller);\n  resetQueue(controller);\n  const result = controller[kState].cancelAlgorithm(reason);\n  readableByteStreamControllerClearAlgorithms(controller);\n  return result;\n}\n\nfunction readableByteStreamControllerPullSteps(controller\x2C readRequest) {\n  const {\n    pendingPullIntos\x2C\n    queue\x2C\n    queueTotalSize\x2C\n    stream\x2C\n  } = controller[kState];\n  assert(readableStreamHasDefaultReader(stream));\n  if (queueTotalSize) {\n    assert(!readableStreamGetNumReadRequests(stream));\n    const {\n      buffer\x2C\n      byteOffset\x2C\n      byteLength\x2C\n    } = ArrayPrototypeShift(queue);\n    controller[kState].queueTotalSize -= byteLength;\n    readableByteStreamControllerHandleQueueDrain(controller);\n    const view = new Uint8Array(buffer\x2C byteOffset\x2C byteLength);\n    readRequest[kChunk](view);\n    return;\n  }\n  const {\n    autoAllocateChunkSize\x2C\n  } = controller[kState];\n  if (autoAllocateChunkSize !== undefined) {\n    try {\n      const buffer = new ArrayBuffer(autoAllocateChunkSize);\n      ArrayPrototypePush(\n        pendingPullIntos\x2C\n        {\n          buffer\x2C\n          byteOffset: 0\x2C\n          byteLength: autoAllocateChunkSize\x2C\n          bytesFilled: 0\x2C\n          elementSize: 1\x2C\n          ctor: Uint8Array\x2C\n          type: 'default'\x2C\n        });\n    } catch (error) {\n      readRequest[kError](error);\n      return;\n    }\n  }\n\n  readableStreamAddReadRequest(stream\x2C readRequest);\n  readableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction setupReadableByteStreamController(\n  stream\x2C\n  controller\x2C\n  startAlgorithm\x2C\n  pullAlgorithm\x2C\n  cancelAlgorithm\x2C\n  highWaterMark\x2C\n  autoAllocateChunkSize) {\n  assert(stream[kState].controller === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(NumberIsInteger(autoAllocateChunkSize));\n    assert(autoAllocateChunkSize > 0);\n  }\n  controller[kState] = {\n    byobRequest: null\x2C\n    closeRequested: false\x2C\n    pullAgain: false\x2C\n    pulling: false\x2C\n    started: false\x2C\n    stream\x2C\n    queue: []\x2C\n    queueTotalSize: 0\x2C\n    highWaterMark\x2C\n    pullAlgorithm\x2C\n    cancelAlgorithm\x2C\n    autoAllocateChunkSize\x2C\n    pendingPullIntos: []\x2C\n  };\n  stream[kState].controller = controller;\n\n  const startResult = startAlgorithm();\n\n  PromisePrototypeThen(\n    PromiseResolve(startResult)\x2C\n    () => {\n      controller[kState].started = true;\n      assert(!controller[kState].pulling);\n      assert(!controller[kState].pullAgain);\n      readableByteStreamControllerCallPullIfNeeded(controller);\n    }\x2C\n    (error) => readableByteStreamControllerError(controller\x2C error));\n}\n\nfunction setupReadableByteStreamControllerFromSource(\n  stream\x2C\n  source\x2C\n  highWaterMark) {\n  const controller = createReadableByteStreamController();\n  const start = source?.start;\n  const pull = source?.pull;\n  const cancel = source?.cancel;\n  const autoAllocateChunkSize = source?.autoAllocateChunkSize;\n  const startAlgorithm = start ?\n    FunctionPrototypeBind(start\x2C source\x2C controller) :\n    nonOpStart;\n  const pullAlgorithm = pull ?\n    FunctionPrototypeBind(pull\x2C source\x2C controller) :\n    nonOpPull;\n  const cancelAlgorithm = cancel ?\n    FunctionPrototypeBind(cancel\x2C source) :\n    nonOpCancel;\n\n  if (autoAllocateChunkSize === 0) {\n    throw new ERR_INVALID_ARG_VALUE(\n      'source.autoAllocateChunkSize'\x2C\n      autoAllocateChunkSize);\n  }\n  setupReadableByteStreamController(\n    stream\x2C\n    controller\x2C\n    startAlgorithm\x2C\n    pullAlgorithm\x2C\n    cancelAlgorithm\x2C\n    highWaterMark\x2C\n    autoAllocateChunkSize);\n}\n\nmodule.exports = {\n  ReadableStream\x2C\n  ReadableStreamDefaultReader\x2C\n  ReadableStreamBYOBReader\x2C\n  ReadableStreamBYOBRequest\x2C\n  ReadableByteStreamController\x2C\n  ReadableStreamDefaultController\x2C\n  TransferredReadableStream\x2C\n\n  // Exported Brand Checks\n  isReadableStream\x2C\n  isReadableByteStreamController\x2C\n  isReadableStreamBYOBRequest\x2C\n  isReadableStreamDefaultReader\x2C\n  isReadableStreamBYOBReader\x2C\n  isWritableStreamDefaultWriter\x2C\n  isWritableStreamDefaultController\x2C\n\n  readableStreamPipeTo\x2C\n  readableStreamTee\x2C\n  readableByteStreamControllerConvertPullIntoDescriptor\x2C\n  isReadableStreamLocked\x2C\n  readableStreamCancel\x2C\n  readableStreamClose\x2C\n  readableStreamError\x2C\n  readableStreamHasDefaultReader\x2C\n  readableStreamGetNumReadRequests\x2C\n  readableStreamHasBYOBReader\x2C\n  readableStreamGetNumReadIntoRequests\x2C\n  readableStreamFulfillReadRequest\x2C\n  readableStreamFulfillReadIntoRequest\x2C\n  readableStreamAddReadRequest\x2C\n  readableStreamAddReadIntoRequest\x2C\n  readableStreamReaderGenericCancel\x2C\n  readableStreamReaderGenericInitialize\x2C\n  readableStreamReaderGenericRelease\x2C\n  readableStreamBYOBReaderRead\x2C\n  readableStreamDefaultReaderRead\x2C\n  setupReadableStreamBYOBReader\x2C\n  setupReadableStreamDefaultReader\x2C\n  readableStreamDefaultControllerClose\x2C\n  readableStreamDefaultControllerEnqueue\x2C\n  readableStreamDefaultControllerHasBackpressure\x2C\n  readableStreamDefaultControllerCanCloseOrEnqueue\x2C\n  readableStreamDefaultControllerGetDesiredSize\x2C\n  readableStreamDefaultControllerShouldCallPull\x2C\n  readableStreamDefaultControllerCallPullIfNeeded\x2C\n  readableStreamDefaultControllerClearAlgorithms\x2C\n  readableStreamDefaultControllerError\x2C\n  readableStreamDefaultControllerCancelSteps\x2C\n  readableStreamDefaultControllerPullSteps\x2C\n  setupReadableStreamDefaultController\x2C\n  setupReadableStreamDefaultControllerFromSource\x2C\n  readableByteStreamControllerClose\x2C\n  readableByteStreamControllerCommitPullIntoDescriptor\x2C\n  readableByteStreamControllerInvalidateBYOBRequest\x2C\n  readableByteStreamControllerClearAlgorithms\x2C\n  readableByteStreamControllerClearPendingPullIntos\x2C\n  readableByteStreamControllerGetDesiredSize\x2C\n  readableByteStreamControllerShouldCallPull\x2C\n  readableByteStreamControllerHandleQueueDrain\x2C\n  readableByteStreamControllerPullInto\x2C\n  readableByteStreamControllerRespondInternal\x2C\n  readableByteStreamControllerRespond\x2C\n  readableByteStreamControllerRespondInClosedState\x2C\n  readableByteStreamControllerFillHeadPullIntoDescriptor\x2C\n  readableByteStreamControllerEnqueue\x2C\n  readableByteStreamControllerEnqueueChunkToQueue\x2C\n  readableByteStreamControllerFillPullIntoDescriptorFromQueue\x2C\n  readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue\x2C\n  readableByteStreamControllerRespondInReadableState\x2C\n  readableByteStreamControllerRespondWithNewView\x2C\n  readableByteStreamControllerShiftPendingPullInto\x2C\n  readableByteStreamControllerCallPullIfNeeded\x2C\n  readableByteStreamControllerError\x2C\n  readableByteStreamControllerCancelSteps\x2C\n  readableByteStreamControllerPullSteps\x2C\n  setupReadableByteStreamController\x2C\n  setupReadableByteStreamControllerFromSource\x2C\n};\n\n/* eslint-enable no-use-before-define */\n
code-source-info,0x24b376407a56,113,0,75979,C0O0C4O75979,,
tick,0x7fff203851aa,92111,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b376402337,0x24b357dbe2b5,0x24b357dbd585,0x24b326978479,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
tick,0x10c4635f1,92136,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b376402337,0x24b357dbe2b5,0x24b357dbd585,0x24b326978479,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
tick,0x7fff2029a0c5,92151,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b376402337,0x24b357dbe2b5,0x24b357dbd585,0x24b326978479,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
tick,0x7fff2029a0c5,92165,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b376402337,0x24b357dbe2b5,0x24b357dbd585,0x24b326978479,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
tick,0x7fff203564ca,92178,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b376402337,0x24b357dbe2b5,0x24b357dbd585,0x24b326978479,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Function,10,92196,0x24b37640d8ee,3454, node:internal/webstreams/readablestream:1:1,0x24b3764079d0,~
code-source-info,0x24b37640d8ee,113,0,75979,C0O0C651O68C657O83C663O112C669O134C675O157C681O173C687O198C693O223C699O234C705O253C711O269C716O295C722O319C728O330C734O355C740O379C746O397C752O414C758O428C764O448C769O458C775O481C780O502C786O687C790O687C795O687C801O555C807O584C813O611C819O637C825O660C831O744C835O744C840O726C846O822C850O822C855O785C861O806C867O925C871O925C876O865C882O911C887O992C891O992C896O962C902O975C908O1038C912O1038C917O1018C923O1095C927O1095C932O1081C938O1164C942O1164C947O1144C953O1274C957O1274C962O1206C967O1222C972O1235C977O1252C983O1349C987O1349C992O1329C998O1419C1002O1419C1007O1401C1012O1921C1016O1921C1021O1465C1027O1493C1033O1525C1039O1557C1045O1585C1051O1602C1057O1621C1063O1638C1069O1654C1075O1673C1081O1697C1087O1721C1093O1745C1099O1761C1104O1777C1110O1791C1116O1812C1122O1835C1128O1850C1134O1863C1140O1877C1146O1886C1152O1896C1157O2312C1161O2312C1166O1969C1172O2001C1178O2021C1184O2047C1189O2084C1194O2118C1200O2141C1206O2180C1212O2236C1218O2274C1224O2375C1228O2375C1232O2375C1234O2420C1238O2420C1242O2420C1244O2454C1248O2454C1252O2454C1254O2487C1258O2487C1262O2487C1264O2520C1268O2520C1272O2520C1274O2552C1278O2552C1282O2552C1304O3973C1314O4008C1322O5589C1374O13704C1384O13864C1394O14648C1404O14830C1440O3947C1442O15043C1446O15081C1460O15097C1462O15119C1472O15214C1478O15224C1499O15247C1510O15278C1521O15312C1532O15348C1543O15379C1554O15407C1559O15043C1564O15894C1569O15904C1573O15918C1597O15968C1607O16014C1633O17604C1669O15931C1671O17769C1675O17818C1689O17839C1695O17871C1701O17914C1705O17769C1722O18310C1732O18387C1742O18469C1770O18213C1784O18671C1794O18748C1804O18824C1832O18577C1854O18971C1864O19019C1896O21114C1932O18932C1934O21343C1938O21394C1952O21417C1958O21446C1964O21482C1970O21513C1974O21343C1999O21575C2009O21620C2041O24514C2077O21539C2079O24757C2083O24805C2100O24828C2110O24857C2120O24893C2130O24924C2138O24757C2168O24993C2178O25045C2212O25899C2224O25995C2234O26090C2274O24950C2276O26185C2280O26240C2301O26268C2311O26298C2321O26330C2331O26360C2339O26185C2376O26661C2386O26710C2444O29613C2459O29706C2472O29798C2518O26621C2520O29893C2524O29945C2545O29973C2555O30009C2565O30039C2575O30071C2585O30101C2593O29893C2603O31094C2609O31094C2617O31094C2619O31167C2625O31167C2633O31167C2635O31251C2641O31251C2649O31251C2651O31334C2657O31334C2665O31334C2667O31416C2673O31416C2681O31416C2683O72876C2694O72897C2704O72915C2714O72946C2724O72974C2734O73003C2744O73035C2754O73070C2764O73127C2774O73147C2784O73181C2794O73212C2804O73245C2814O73275C2824O73308C2834O73346C2844O73370C2854O73391C2864O73448C2874O73474C2884O73498C2894O73521C2904O73544C2914O73578C2924O73614C2934O73645C2944O73685C2954O73721C2964O73761C2974O73793C2984O73829C2994O73866C3004O73907C3014O73945C3024O73977C3034O74012C3044O74045C3054O74081C3064O74121C3074O74163C3084O74213C3094O74265C3104O74314C3114O74363C3124O74414C3134O74464C3144O74504C3154O74550C3164O74594C3174O74634C3184O74684C3194O74721C3204O74777C3214O74830C3224O74877C3234O74930C3244O74976C3254O75022C3264O75070C3274O75110C3284O75157C3294O75196C3304O75248C3314O75306C3324O75345C3334O75396C3344O75459C3354O75527C3364O75581C3374O75631C3384O75683C3394O75731C3404O75768C3414O75811C3424O75852C3434O75889C3444O72891C3453O75978,,
code-creation,Function,10,92398,0x24b37640eb36,16,<instance_members_initializer> node:internal/webstreams/readablestream:1008:3,0x24b37640a818,~
code-source-info,0x24b37640eb36,113,26660,26700,C3O26670C15O26700,,
code-creation,Function,10,92417,0x24b37640ebae,16,<instance_members_initializer> node:internal/webstreams/readablestream:938:3,0x24b37640a480,~
code-source-info,0x24b37640ebae,113,24992,25035,C3O25002C15O25035,,
code-creation,Function,10,92434,0x24b37640ec2e,16,<instance_members_initializer> node:internal/webstreams/readablestream:821:3,0x24b37640a158,~
code-source-info,0x24b37640ec2e,113,21574,21610,C3O21584C15O21610,,
code-creation,Function,10,92451,0x24b37640eca6,16,<instance_members_initializer> node:internal/webstreams/readablestream:727:3,0x24b376409ed0,~
code-source-info,0x24b37640eca6,113,18970,19009,C3O18980C15O19009,,
code-creation,Function,10,92468,0x24b37640ed1e,16,<instance_members_initializer> node:internal/webstreams/readablestream:595:3,0x24b3764098e8,~
code-source-info,0x24b37640ed1e,113,15967,16004,C3O15977C15O16004,,
code-creation,Function,10,92485,0x24b37640ed96,16,<instance_members_initializer> node:internal/webstreams/readablestream:184:3,0x24b376409628,~
code-source-info,0x24b37640ed96,113,3972,3998,C3O3982C15O3998,,
code-creation,Eval,10,93104,0x24b376415a36,5, node:internal/webstreams/util:1:1,0x24b376415780,~
script-source,114,node:internal/webstreams/util,'use strict';\n\nconst {\n  ArrayBufferPrototype\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  AsyncIteratorPrototype\x2C\n  FunctionPrototypeCall\x2C\n  MathMax\x2C\n  NumberIsNaN\x2C\n  ObjectCreate\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  ReflectGet\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OPERATION_FAILED\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  copyArrayBuffer\x2C\n  detachArrayBuffer\n} = internalBinding('buffer');\n\nconst {\n  isPromise\x2C\n} = require('internal/util/types');\n\nconst {\n  inspect\x2C\n} = require('util');\n\nconst {\n  getPromiseDetails\x2C\n  kPending\x2C\n} = internalBinding('util');\n\nconst assert = require('internal/assert');\n\nconst kState = Symbol('kState');\nconst kType = Symbol('kType');\n\nconst AsyncIterator = ObjectCreate(AsyncIteratorPrototype\x2C {\n  next: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    writable: true\x2C\n  }\x2C\n  return: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    writable: true\x2C\n  }\x2C\n});\n\nfunction extractHighWaterMark(value\x2C defaultHWM) {\n  if (value === undefined) return defaultHWM;\n  value = +value;\n  if (typeof value !== 'number' ||\n      NumberIsNaN(value) ||\n      value < 0)\n    throw new ERR_INVALID_ARG_VALUE.RangeError('strategy.highWaterMark'\x2C value);\n  return value;\n}\n\nfunction extractSizeAlgorithm(size) {\n  if (size === undefined) return () => 1;\n  if (typeof size !== 'function')\n    throw new ERR_INVALID_ARG_TYPE('strategy.size'\x2C 'Function'\x2C size);\n  return size;\n}\n\nfunction customInspect(depth\x2C options\x2C name\x2C data) {\n  if (depth < 0)\n    return this;\n\n  const opts = {\n    ...options\x2C\n    depth: options.depth == null ? null : options.depth - 1\n  };\n\n  return `${name} ${inspect(data\x2C opts)}`;\n}\n\n// These are defensive to work around the possibility that\n// the buffer\x2C byteLength\x2C and byteOffset properties on\n// ArrayBuffer and ArrayBufferView's may have been tampered with.\n\nfunction ArrayBufferViewGetBuffer(view) {\n  return ReflectGet(view.constructor.prototype\x2C 'buffer'\x2C view);\n}\n\nfunction ArrayBufferViewGetByteLength(view) {\n  return ReflectGet(view.constructor.prototype\x2C 'byteLength'\x2C view);\n}\n\nfunction ArrayBufferViewGetByteOffset(view) {\n  return ReflectGet(view.constructor.prototype\x2C 'byteOffset'\x2C view);\n}\n\nfunction ArrayBufferGetByteLength(view) {\n  return ReflectGet(ArrayBufferPrototype\x2C 'byteLength'\x2C view);\n}\n\nfunction isBrandCheck(brand) {\n  return (value) => {\n    return value != null &&\n           value[kState] !== undefined &&\n           value[kType] === brand;\n  };\n}\n\nfunction transferArrayBuffer(buffer) {\n  const res = detachArrayBuffer(buffer);\n  if (res === undefined) {\n    throw new ERR_OPERATION_FAILED.TypeError(\n      'The ArrayBuffer could not be transferred');\n  }\n  return res;\n}\n\nfunction dequeueValue(controller) {\n  assert(controller[kState].queue !== undefined);\n  assert(controller[kState].queueTotalSize !== undefined);\n  assert(controller[kState].queue.length);\n  const {\n    value\x2C\n    size\x2C\n  } = ArrayPrototypeShift(controller[kState].queue);\n  controller[kState].queueTotalSize =\n    MathMax(0\x2C controller[kState].queueTotalSize - size);\n  return value;\n}\n\nfunction resetQueue(controller) {\n  assert(controller[kState].queue !== undefined);\n  assert(controller[kState].queueTotalSize !== undefined);\n  controller[kState].queue = [];\n  controller[kState].queueTotalSize = 0;\n}\n\nfunction peekQueueValue(controller) {\n  assert(controller[kState].queue !== undefined);\n  assert(controller[kState].queueTotalSize !== undefined);\n  assert(controller[kState].queue.length);\n  return controller[kState].queue[0].value;\n}\n\nfunction enqueueValueWithSize(controller\x2C value\x2C size) {\n  assert(controller[kState].queue !== undefined);\n  assert(controller[kState].queueTotalSize !== undefined);\n  size = +size;\n  if (typeof size !== 'number' ||\n      size < 0 ||\n      NumberIsNaN(size) ||\n      size === Infinity) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError('size'\x2C size);\n  }\n  ArrayPrototypePush(controller[kState].queue\x2C { value\x2C size });\n  controller[kState].queueTotalSize += size;\n}\n\nfunction ensureIsPromise(fn\x2C thisArg\x2C ...args) {\n  try {\n    const value = FunctionPrototypeCall(fn\x2C thisArg\x2C ...args);\n    return isPromise(value) ? value : PromiseResolve(value);\n  } catch (error) {\n    return PromiseReject(error);\n  }\n}\n\nfunction isPromisePending(promise) {\n  if (promise === undefined) return false;\n  const details = getPromiseDetails(promise);\n  return details?.[0] === kPending;\n}\n\nfunction setPromiseHandled(promise) {\n  // Alternatively\x2C we could use the native API\n  // MarkAsHandled\x2C but this avoids the extra boundary cross\n  // and is hopefully faster at the cost of an extra Promise\n  // allocation.\n  PromisePrototypeThen(promise\x2C () => {}\x2C () => {});\n}\n\nasync function nonOpFlush() {}\n\nfunction nonOpStart() {}\n\nasync function nonOpPull() {}\n\nasync function nonOpCancel() {}\n\nasync function nonOpWrite() {}\n\nlet transfer;\nfunction lazyTransfer() {\n  if (transfer === undefined)\n    transfer = require('internal/webstreams/transfer');\n  return transfer;\n}\n\nconst kEnumerableProperty = ObjectCreate(null);\nkEnumerableProperty.enumerable = true;\n\nmodule.exports = {\n  ArrayBufferViewGetBuffer\x2C\n  ArrayBufferViewGetByteLength\x2C\n  ArrayBufferViewGetByteOffset\x2C\n  ArrayBufferGetByteLength\x2C\n  AsyncIterator\x2C\n  copyArrayBuffer\x2C\n  customInspect\x2C\n  dequeueValue\x2C\n  ensureIsPromise\x2C\n  enqueueValueWithSize\x2C\n  extractHighWaterMark\x2C\n  extractSizeAlgorithm\x2C\n  lazyTransfer\x2C\n  isBrandCheck\x2C\n  isPromisePending\x2C\n  peekQueueValue\x2C\n  resetQueue\x2C\n  setPromiseHandled\x2C\n  transferArrayBuffer\x2C\n  nonOpCancel\x2C\n  nonOpFlush\x2C\n  nonOpPull\x2C\n  nonOpStart\x2C\n  nonOpWrite\x2C\n  kType\x2C\n  kState\x2C\n  kEnumerableProperty\x2C\n};\n
code-source-info,0x24b376415a36,114,0,5698,C0O0C4O5698,,
code-creation,Function,10,93523,0x24b3764166a6,631, node:internal/webstreams/util:1:1,0x24b3764159b0,~
code-source-info,0x24b3764166a6,114,0,5698,C0O0C196O25C202O49C208O71C214O94C219O120C225O145C231O156C237O171C242O187C248O211C254O229C260O246C266O260C271O393C279O393C285O393C291O309C297O335C303O362C309O473C313O473C319O432C324O451C330O526C338O526C344O511C350O582C358O582C364O569C370O645C374O645C380O610C386O631C392O686C400O686C404O686C406O730C410O730C414O730C416O762C420O762C424O762C426O815C432O802C438O4924C439O4924C441O5096C444O5096C450O5116C451O5147C455O5156C463O5177C469O5205C475O5237C481O5269C487O5297C493O5314C499O5333C505O5350C511O5366C517O5385C523O5409C529O5433C535O5457C541O5473C547O5489C553O5509C559O5527C565O5541C571O5562C577O5585C583O5600C589O5614C595O5627C601O5641C607O5655C613O5664C619O5674C625O5171C630O5697,,
tick,0x7fff20385398,93625,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b37640dce6,0x24b357dbe2b5,0x24b357dbd585,0x24b376402337,0x24b357dbe2b5,0x24b357dbd585,0x24b326978479,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Eval,10,94588,0x24b376418b36,5, node:internal/webstreams/writablestream:1:1,0x24b376418328,~
script-source,115,node:internal/webstreams/writablestream,'use strict';\n\n/* eslint-disable no-use-before-define */\n\nconst {\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperties\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  ReflectConstruct\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_STATE\x2C\n    ERR_INVALID_THIS\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  DOMException\x2C\n} = internalBinding('messaging');\n\nconst {\n  createDeferredPromise\x2C\n  customInspectSymbol: kInspect\x2C\n} = require('internal/util');\n\nconst {\n  MessageChannel\x2C\n} = require('internal/worker/io');\n\nconst {\n  kDeserialize\x2C\n  kTransfer\x2C\n  kTransferList\x2C\n  makeTransferable\x2C\n} = require('internal/worker/js_transferable');\n\nconst {\n  customInspect\x2C\n  dequeueValue\x2C\n  ensureIsPromise\x2C\n  enqueueValueWithSize\x2C\n  extractHighWaterMark\x2C\n  extractSizeAlgorithm\x2C\n  lazyTransfer\x2C\n  isBrandCheck\x2C\n  isPromisePending\x2C\n  peekQueueValue\x2C\n  resetQueue\x2C\n  setPromiseHandled\x2C\n  nonOpCancel\x2C\n  nonOpStart\x2C\n  nonOpWrite\x2C\n  kType\x2C\n  kState\x2C\n  kEnumerableProperty\x2C\n} = require('internal/webstreams/util');\n\nconst {\n  AbortController\x2C\n} = require('internal/abort_controller');\n\nconst assert = require('internal/assert');\n\nconst kAbort = Symbol('kAbort');\nconst kCloseSentinel = Symbol('kCloseSentinel');\nconst kError = Symbol('kError');\n\n/**\n * @typedef {import('../abort_controller').AbortSignal} AbortSignal\n * @typedef {import('./queuingstrategies').QueuingStrategy\n * } QueuingStrategy\n * @typedef {import('./queuingstrategies').QueuingStrategySize\n * } QueuingStrategySize\n *\n * @callback UnderlyingSinkStartCallback\n * @param {WritableStreamDefaultController} controller\n *\n * @callback UnderlyingSinkWriteCallback\n * @param {any} chunk\n * @param {WritableStreamDefaultController} controller\n * @returns {Promise<void>}\n *\n * @callback UnderlyingSinkCloseCallback\n * @returns {Promise<void>}\n *\n * @callback UnderlyingSinkAbortCallback\n * @param {any} reason\n * @returns {Promise<void>}\n *\n * @typedef {{\n *   start? : UnderlyingSinkStartCallback\x2C\n *   write? : UnderlyingSinkWriteCallback\x2C\n *   close? : UnderlyingSinkCloseCallback\x2C\n *   abort? : UnderlyingSinkAbortCallback\x2C\n *   type? : any\x2C\n * }} UnderlyingSink\n */\n\nclass WritableStream {\n  [kType] = 'WritableStream';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {UnderlyingSink} [sink]\n   * @param {QueuingStrategy} [strategy]\n   */\n  constructor(sink = null\x2C strategy = {}) {\n    const type = sink?.type;\n    if (type !== undefined)\n      throw new ERR_INVALID_ARG_VALUE.RangeError('type'\x2C type);\n\n    this[kState] = {\n      close: createDeferredPromise()\x2C\n      closeRequest: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n      inFlightWriteRequest: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n      inFlightCloseRequest: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n      pendingAbortRequest: {\n        abort: {\n          promise: undefined\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        }\x2C\n        reason: undefined\x2C\n        wasAlreadyErroring: false\x2C\n      }\x2C\n      backpressure: false\x2C\n      controller: undefined\x2C\n      state: 'writable'\x2C\n      storedError: undefined\x2C\n      writeRequests: []\x2C\n      writer: undefined\x2C\n      transfer: {\n        readable: undefined\x2C\n        port1: undefined\x2C\n        port2: undefined\x2C\n        promise: undefined\x2C\n      }\n    };\n\n    const size = extractSizeAlgorithm(strategy?.size);\n    const highWaterMark = extractHighWaterMark(strategy?.highWaterMark\x2C 1);\n\n    setupWritableStreamDefaultControllerFromSink(\n      this\x2C\n      sink\x2C\n      highWaterMark\x2C\n      size);\n\n    // eslint-disable-next-line no-constructor-return\n    return makeTransferable(this);\n  }\n\n  /**\n   * @readonly\n   * @type {boolean}\n   */\n  get locked() {\n    if (!isWritableStream(this))\n      throw new ERR_INVALID_THIS('WritableStream');\n    return isWritableStreamLocked(this);\n  }\n\n  /**\n   * @param {any} reason\n   * @returns {Promise<vois>}\n   */\n  abort(reason = undefined) {\n    if (!isWritableStream(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStream'));\n    if (isWritableStreamLocked(this)) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError('WritableStream is locked'));\n    }\n    return writableStreamAbort(this\x2C reason);\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  close() {\n    if (!isWritableStream(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStream'));\n    if (isWritableStreamLocked(this)) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError('WritableStream is locked'));\n    }\n    if (writableStreamCloseQueuedOrInFlight(this)) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError('Failure closing WritableStream'));\n    }\n    return writableStreamClose(this);\n  }\n\n  /**\n   * @returns {WritableStreamDefaultWriter}\n   */\n  getWriter() {\n    if (!isWritableStream(this))\n      throw new ERR_INVALID_THIS('WritableStream');\n    return new WritableStreamDefaultWriter(this);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      locked: this.locked\x2C\n      state: this[kState].state\x2C\n    });\n  }\n\n  [kTransfer]() {\n    if (!isWritableStream(this))\n      throw new ERR_INVALID_THIS('WritableStream');\n    if (this.locked) {\n      this[kState].transfer.port1?.close();\n      this[kState].transfer.port1 = undefined;\n      this[kState].transfer.port2 = undefined;\n      throw new DOMException(\n        'Cannot transfer a locked WritableStream'\x2C\n        'DataCloneError');\n    }\n\n    const {\n      readable\x2C\n      promise\x2C\n    } = lazyTransfer().newCrossRealmReadableStream(\n      this\x2C\n      this[kState].transfer.port1);\n\n    this[kState].transfer.readable = readable;\n    this[kState].transfer.promise = promise;\n\n    setPromiseHandled(this[kState].transfer.promise);\n\n    return {\n      data: { port: this[kState].transfer.port2 }\x2C\n      deserializeInfo:\n        'internal/webstreams/writablestream:TransferredWritableStream'\n    };\n  }\n\n  [kTransferList]() {\n    const { port1\x2C port2 } = new MessageChannel();\n    this[kState].transfer.port1 = port1;\n    this[kState].transfer.port2 = port2;\n    return [ port2 ];\n  }\n\n  [kDeserialize]({ port }) {\n    const transfer = lazyTransfer();\n    setupWritableStreamDefaultControllerFromSink(\n      this\x2C\n      new transfer.CrossRealmTransformWritableSink(port)\x2C\n      1\x2C\n      () => 1);\n  }\n}\n\nObjectDefineProperties(WritableStream.prototype\x2C {\n  locked: kEnumerableProperty\x2C\n  abort: kEnumerableProperty\x2C\n  close: kEnumerableProperty\x2C\n  getWriter: kEnumerableProperty\x2C\n});\n\nfunction TransferredWritableStream() {\n  return makeTransferable(ReflectConstruct(\n    function() {\n      this[kType] = 'WritableStream';\n      this[kState] = {\n        close: createDeferredPromise()\x2C\n        closeRequest: {\n          promise: undefined\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        }\x2C\n        inFlightWriteRequest: {\n          promise: undefined\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        }\x2C\n        inFlightCloseRequest: {\n          promise: undefined\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        }\x2C\n        pendingAbortRequest: {\n          abort: {\n            promise: undefined\x2C\n            resolve: undefined\x2C\n            reject: undefined\x2C\n          }\x2C\n          reason: undefined\x2C\n          wasAlreadyErroring: false\x2C\n        }\x2C\n        backpressure: false\x2C\n        controller: undefined\x2C\n        state: 'writable'\x2C\n        storedError: undefined\x2C\n        writeRequests: []\x2C\n        writer: undefined\x2C\n        transfer: {\n          promise: undefined\x2C\n          port1: undefined\x2C\n          port2: undefined\x2C\n          readable: undefined\x2C\n        }\x2C\n      };\n    }\x2C\n    []\x2C WritableStream));\n}\nTransferredWritableStream.prototype[kDeserialize] = () => {};\n\nclass WritableStreamDefaultWriter {\n  [kType] = 'WritableStreamDefaultWriter';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {WritableStream} stream\n   */\n  constructor(stream) {\n    if (!isWritableStream(stream))\n      throw new ERR_INVALID_ARG_TYPE('stream'\x2C 'WritableStream'\x2C stream);\n    this[kState] = {\n      stream: undefined\x2C\n      close: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n      ready: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\n    };\n    setupWritableStreamDefaultWriter(this\x2C stream);\n  }\n\n  /**\n   * @readonly\n   * @type {Promise<void>}\n   */\n  get closed() {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\n    return this[kState].close.promise;\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get desiredSize() {\n    if (!isWritableStreamDefaultWriter(this))\n      throw new ERR_INVALID_THIS('WritableStreamDefaultWriter');\n    if (this[kState].stream === undefined) {\n      throw new ERR_INVALID_STATE.TypeError(\n        'Writer is not bound to a WritableStream');\n    }\n    return writableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  /**\n   * @readonly\n   * @type {Promise<void>}\n   */\n  get ready() {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\n    return this[kState].ready.promise;\n  }\n\n  /**\n   * @param {any} reason\n   * @returns {Promise<void>}\n   */\n  abort(reason = undefined) {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\n    if (this[kState].stream === undefined) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'Writer is not bound to a WritableStream'));\n    }\n    return writableStreamDefaultWriterAbort(this\x2C reason);\n  }\n\n  /**\n   * @returns {Promise<void>}\n   */\n  close() {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\n    const {\n      stream\x2C\n    } = this[kState];\n    if (stream === undefined) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'Writer is not bound to a WritableStream'));\n    }\n    if (writableStreamCloseQueuedOrInFlight(stream)) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError('Failure to close WritableStream'));\n    }\n    return writableStreamDefaultWriterClose(this);\n  }\n\n  releaseLock() {\n    if (!isWritableStreamDefaultWriter(this))\n      throw new ERR_INVALID_THIS('WritableStreamDefaultWriter');\n    const {\n      stream\x2C\n    } = this[kState];\n    if (stream === undefined)\n      return;\n    assert(stream[kState].writer !== undefined);\n    writableStreamDefaultWriterRelease(this);\n  }\n\n  /**\n   * @param {any} chunk\n   * @returns {Promise<void>}\n   */\n  write(chunk = undefined) {\n    if (!isWritableStreamDefaultWriter(this))\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\n    if (this[kState].stream === undefined) {\n      return PromiseReject(\n        new ERR_INVALID_STATE.TypeError(\n          'Writer is not bound to a WritableStream'));\n    }\n    return writableStreamDefaultWriterWrite(this\x2C chunk);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      stream: this[kState].stream\x2C\n      close: this[kState].close.promise\x2C\n      ready: this[kState].ready.promise\x2C\n      desiredSize: this.desiredSize\x2C\n    });\n  }\n}\n\nObjectDefineProperties(WritableStreamDefaultWriter.prototype\x2C {\n  closed: kEnumerableProperty\x2C\n  ready: kEnumerableProperty\x2C\n  desiredSize: kEnumerableProperty\x2C\n  abort: kEnumerableProperty\x2C\n  close: kEnumerableProperty\x2C\n  releaseLock: kEnumerableProperty\x2C\n  write: kEnumerableProperty\x2C\n});\n\nclass WritableStreamDefaultController {\n  [kType] = 'WritableStreamDefaultController';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  [kAbort](reason) {\n    const result = this[kState].abortAlgorithm(reason);\n    writableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  [kError]() {\n    resetQueue(this);\n  }\n\n  /**\n   * @type {any}\n   */\n  get abortReason() {\n    if (!isWritableStreamDefaultController(this))\n      throw new ERR_INVALID_THIS('WritableStreamDefaultController');\n    return this[kState].abortReason;\n  }\n\n  /**\n   * @type {AbortSignal}\n   */\n  get signal() {\n    if (!isWritableStreamDefaultController(this))\n      throw new ERR_INVALID_THIS('WritableStreamDefaultController');\n    return this[kState].abortController.signal;\n  }\n\n  /**\n   * @param {any} error\n   */\n  error(error = undefined) {\n    if (!isWritableStreamDefaultController(this))\n      throw new ERR_INVALID_THIS('WritableStreamDefaultController');\n    if (this[kState].stream[kState].state !== 'writable')\n      return;\n    writableStreamDefaultControllerError(this\x2C error);\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      stream: this[kState].stream\x2C\n    });\n  }\n}\n\nObjectDefineProperties(WritableStreamDefaultController.prototype\x2C {\n  abortReason: kEnumerableProperty\x2C\n  signal: kEnumerableProperty\x2C\n  error: kEnumerableProperty\x2C\n});\n\nfunction createWritableStreamDefaultController() {\n  return ReflectConstruct(\n    function() {\n      this[kType] = 'WritableStreamDefaultController';\n    }\x2C\n    []\x2C WritableStreamDefaultController);\n}\n\nconst isWritableStream =\n  isBrandCheck('WritableStream');\nconst isWritableStreamDefaultWriter =\n  isBrandCheck('WritableStreamDefaultWriter');\nconst isWritableStreamDefaultController =\n  isBrandCheck('WritableStreamDefaultController');\n\nfunction isWritableStreamLocked(stream) {\n  return stream[kState].writer !== undefined;\n}\n\nfunction setupWritableStreamDefaultWriter(writer\x2C stream) {\n  if (isWritableStreamLocked(stream))\n    throw new ERR_INVALID_STATE.TypeError('WritableStream is locked');\n  writer[kState].stream = stream;\n  stream[kState].writer = writer;\n  switch (stream[kState].state) {\n    case 'writable':\n      if (!writableStreamCloseQueuedOrInFlight(stream) &&\n          stream[kState].backpressure) {\n        writer[kState].ready = createDeferredPromise();\n      } else {\n        writer[kState].ready = {\n          promise: PromiseResolve()\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        };\n      }\n      setClosedPromiseToNewPromise();\n      break;\n    case 'erroring':\n      writer[kState].ready = {\n        promise: PromiseReject(stream[kState].storedError)\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      setPromiseHandled(writer[kState].ready.promise);\n      setClosedPromiseToNewPromise();\n      break;\n    case 'closed':\n      writer[kState].ready = {\n        promise: PromiseResolve()\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      writer[kState].close = {\n        promise: PromiseResolve()\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      break;\n    default:\n      writer[kState].ready = {\n        promise: PromiseReject(stream[kState].storedError)\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      writer[kState].close = {\n        promise: PromiseReject(stream[kState].storedError)\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      };\n      setPromiseHandled(writer[kState].ready.promise);\n      setPromiseHandled(writer[kState].close.promise);\n  }\n\n  function setClosedPromiseToNewPromise() {\n    writer[kState].close = createDeferredPromise();\n  }\n}\n\nfunction writableStreamAbort(stream\x2C reason) {\n  const {\n    state\x2C\n    controller\x2C\n  } = stream[kState];\n  if (state === 'closed' || state === 'errored')\n    return PromiseResolve();\n\n  controller[kState].abortReason = reason;\n  controller[kState].abortController.abort();\n\n  if (stream[kState].pendingAbortRequest.abort.promise !== undefined)\n    return stream[kState].pendingAbortRequest.abort.promise;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    reason = undefined;\n  }\n\n  const abort = createDeferredPromise();\n\n  stream[kState].pendingAbortRequest = {\n    abort\x2C\n    reason\x2C\n    wasAlreadyErroring\x2C\n  };\n\n  if (!wasAlreadyErroring)\n    writableStreamStartErroring(stream\x2C reason);\n\n  return abort.promise;\n}\n\nfunction writableStreamClose(stream) {\n  const {\n    state\x2C\n    writer\x2C\n    backpressure\x2C\n    controller\x2C\n  } = stream[kState];\n  if (state === 'closed' || state === 'errored') {\n    return PromiseReject(\n      new ERR_INVALID_STATE.TypeError('WritableStream is closed'));\n  }\n  assert(state === 'writable' || state === 'erroring');\n  assert(!writableStreamCloseQueuedOrInFlight(stream));\n  stream[kState].closeRequest = createDeferredPromise();\n  const { promise } = stream[kState].closeRequest;\n  if (writer !== undefined && backpressure && state === 'writable')\n    writer[kState].ready.resolve?.();\n  writableStreamDefaultControllerClose(controller);\n  return promise;\n}\n\nfunction writableStreamUpdateBackpressure(stream\x2C backpressure) {\n  assert(stream[kState].state === 'writable');\n  assert(!writableStreamCloseQueuedOrInFlight(stream));\n  const {\n    writer\x2C\n  } = stream[kState];\n  if (writer !== undefined && stream[kState].backpressure !== backpressure) {\n    if (backpressure) {\n      writer[kState].ready = createDeferredPromise();\n    } else {\n      writer[kState].ready.resolve?.();\n    }\n  }\n  stream[kState].backpressure = backpressure;\n}\n\nfunction writableStreamStartErroring(stream\x2C reason) {\n  assert(stream[kState].storedError === undefined);\n  assert(stream[kState].state === 'writable');\n  const {\n    controller\x2C\n    writer\x2C\n  } = stream[kState];\n  assert(controller !== undefined);\n  stream[kState].state = 'erroring';\n  stream[kState].storedError = reason;\n  if (writer !== undefined) {\n    writableStreamDefaultWriterEnsureReadyPromiseRejected(writer\x2C reason);\n  }\n  if (!writableStreamHasOperationMarkedInFlight(stream) &&\n      controller[kState].started) {\n    writableStreamFinishErroring(stream);\n  }\n}\n\nfunction writableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  assert(stream[kState].state === 'errored');\n  if (stream[kState].closeRequest.promise !== undefined) {\n    assert(stream[kState].inFlightCloseRequest.promise === undefined);\n    stream[kState].closeRequest.reject?.(stream[kState].storedError);\n    stream[kState].closeRequest = {\n      promise: undefined\x2C\n      reject: undefined\x2C\n      resolve: undefined\x2C\n    };\n  }\n  const {\n    writer\x2C\n  } = stream[kState];\n  if (writer !== undefined) {\n    writer[kState].close.reject?.(stream[kState].storedError);\n    setPromiseHandled(writer[kState].close.promise);\n  }\n}\n\nfunction writableStreamMarkFirstWriteRequestInFlight(stream) {\n  assert(stream[kState].inFlightWriteRequest.promise === undefined);\n  assert(stream[kState].writeRequests.length);\n  const writeRequest = ArrayPrototypeShift(stream[kState].writeRequests);\n  stream[kState].inFlightWriteRequest = writeRequest;\n}\n\nfunction writableStreamMarkCloseRequestInFlight(stream) {\n  assert(stream[kState].inFlightWriteRequest.promise === undefined);\n  assert(stream[kState].closeRequest.promise !== undefined);\n  stream[kState].inFlightCloseRequest = stream[kState].closeRequest;\n  stream[kState].closeRequest = {\n    promise: undefined\x2C\n    resolve: undefined\x2C\n    reject: undefined\x2C\n  };\n}\n\nfunction writableStreamHasOperationMarkedInFlight(stream) {\n  const {\n    inFlightWriteRequest\x2C\n    inFlightCloseRequest\x2C\n  } = stream[kState];\n  if (inFlightWriteRequest.promise === undefined &&\n      inFlightCloseRequest.promise === undefined) {\n    return false;\n  }\n  return true;\n}\n\nfunction writableStreamFinishInFlightWriteWithError(stream\x2C error) {\n  assert(stream[kState].inFlightWriteRequest.promise !== undefined);\n  stream[kState].inFlightWriteRequest.reject?.(error);\n  stream[kState].inFlightWriteRequest = {\n    promise: undefined\x2C\n    resolve: undefined\x2C\n    reject: undefined\x2C\n  };\n  assert(stream[kState].state === 'writable' ||\n         stream[kState].state === 'erroring');\n  writableStreamDealWithRejection(stream\x2C error);\n}\n\nfunction writableStreamFinishInFlightWrite(stream) {\n  assert(stream[kState].inFlightWriteRequest.promise !== undefined);\n  stream[kState].inFlightWriteRequest.resolve?.();\n  stream[kState].inFlightWriteRequest = {\n    promise: undefined\x2C\n    resolve: undefined\x2C\n    reject: undefined\x2C\n  };\n}\n\nfunction writableStreamFinishInFlightCloseWithError(stream\x2C error) {\n  assert(stream[kState].inFlightCloseRequest.promise !== undefined);\n  stream[kState].inFlightCloseRequest.reject?.(error);\n  stream[kState].inFlightCloseRequest = {\n    promise: undefined\x2C\n    resolve: undefined\x2C\n    reject: undefined\x2C\n  };\n  assert(stream[kState].state === 'writable' ||\n         stream[kState].state === 'erroring');\n  if (stream[kState].pendingAbortRequest.abort.promise !== undefined) {\n    stream[kState].pendingAbortRequest.abort.reject?.(error);\n    stream[kState].pendingAbortRequest = {\n      abort: {\n        promise: undefined\x2C\n        resolve: undefined\x2C\n        reject: undefined\x2C\n      }\x2C\n      reason: undefined\x2C\n      wasAlreadyErroring: false\x2C\n    };\n  }\n  writableStreamDealWithRejection(stream\x2C error);\n}\n\nfunction writableStreamFinishInFlightClose(stream) {\n  assert(stream[kState].inFlightCloseRequest.promise !== undefined);\n  stream[kState].inFlightCloseRequest.resolve?.();\n  stream[kState].inFlightCloseRequest = {\n    promise: undefined\x2C\n    resolve: undefined\x2C\n    reject: undefined\x2C\n  };\n  if (stream[kState].state === 'erroring') {\n    stream[kState].storedError = undefined;\n    if (stream[kState].pendingAbortRequest.abort.promise !== undefined) {\n      stream[kState].pendingAbortRequest.abort.resolve?.();\n      stream[kState].pendingAbortRequest = {\n        abort: {\n          promise: undefined\x2C\n          resolve: undefined\x2C\n          reject: undefined\x2C\n        }\x2C\n        reason: undefined\x2C\n        wasAlreadyErroring: false\x2C\n      };\n    }\n  }\n  stream[kState].state = 'closed';\n  if (stream[kState].writer !== undefined)\n    stream[kState].writer[kState].close.resolve?.();\n  assert(stream[kState].pendingAbortRequest.abort.promise === undefined);\n  assert(stream[kState].storedError === undefined);\n}\n\nfunction writableStreamFinishErroring(stream) {\n  assert(stream[kState].state === 'erroring');\n  assert(!writableStreamHasOperationMarkedInFlight(stream));\n  stream[kState].state = 'errored';\n  stream[kState].controller[kError]();\n  const storedError = stream[kState].storedError;\n  for (let n = 0; n < stream[kState].writeRequests.length; n++)\n    stream[kState].writeRequests[n].reject?.(storedError);\n  stream[kState].writeRequests = [];\n\n  if (stream[kState].pendingAbortRequest.abort.promise === undefined) {\n    writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream[kState].pendingAbortRequest;\n  stream[kState].pendingAbortRequest = {\n    abort: {\n      promise: undefined\x2C\n      resolve: undefined\x2C\n      reject: undefined\x2C\n    }\x2C\n    reason: undefined\x2C\n    wasAlreadyErroring: false\x2C\n  };\n  if (abortRequest.wasAlreadyErroring) {\n    abortRequest.abort.reject?.(storedError);\n    writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n  PromisePrototypeThen(\n    ensureIsPromise(\n      stream[kState].controller[kAbort]\x2C\n      stream[kState].controller\x2C\n      abortRequest.reason)\x2C\n    () => {\n      abortRequest.abort.resolve?.();\n      writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    }\x2C\n    (error) => {\n      abortRequest.abort.reject?.(error);\n      writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    });\n}\n\nfunction writableStreamDealWithRejection(stream\x2C error) {\n  const {\n    state\x2C\n  } = stream[kState];\n  if (state === 'writable') {\n    writableStreamStartErroring(stream\x2C error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  writableStreamFinishErroring(stream);\n}\n\nfunction writableStreamCloseQueuedOrInFlight(stream) {\n  if (stream[kState].closeRequest.promise === undefined &&\n      stream[kState].inFlightCloseRequest.promise === undefined) {\n    return false;\n  }\n  return true;\n}\n\nfunction writableStreamAddWriteRequest(stream) {\n  assert(isWritableStreamLocked(stream));\n  assert(stream[kState].state === 'writable');\n  const {\n    promise\x2C\n    resolve\x2C\n    reject\x2C\n  } = createDeferredPromise();\n  ArrayPrototypePush(\n    stream[kState].writeRequests\x2C\n    {\n      promise\x2C\n      resolve\x2C\n      reject\x2C\n    });\n  return promise;\n}\n\nfunction writableStreamDefaultWriterWrite(writer\x2C chunk) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  assert(stream !== undefined);\n  const {\n    controller\x2C\n  } = stream[kState];\n  const chunkSize = writableStreamDefaultControllerGetChunkSize(\n    controller\x2C\n    chunk);\n  if (stream !== writer[kState].stream) {\n    return PromiseReject(\n      new ERR_INVALID_STATE.TypeError('Mismatched WritableStreams'));\n  }\n  const {\n    state\x2C\n  } = stream[kState];\n\n  if (state === 'errored')\n    return PromiseReject(stream[kState].storedError);\n\n  if (writableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return PromiseReject(\n      new ERR_INVALID_STATE.TypeError('WritableStream is closed'));\n  }\n\n  if (state === 'erroring')\n    return PromiseReject(stream[kState].storedError);\n\n  assert(state === 'writable');\n\n  const promise = writableStreamAddWriteRequest(stream);\n  writableStreamDefaultControllerWrite(controller\x2C chunk\x2C chunkSize);\n  return promise;\n}\n\nfunction writableStreamDefaultWriterRelease(writer) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  assert(stream !== undefined);\n  assert(stream[kState].writer === writer);\n  const releasedError =\n    new ERR_INVALID_STATE.TypeError('Writer has been released');\n  writableStreamDefaultWriterEnsureReadyPromiseRejected(writer\x2C releasedError);\n  writableStreamDefaultWriterEnsureClosedPromiseRejected(writer\x2C releasedError);\n  stream[kState].writer = undefined;\n  writer[kState].stream = undefined;\n}\n\nfunction writableStreamDefaultWriterGetDesiredSize(writer) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  switch (stream[kState].state) {\n    case 'errored':\n      // Fall through\n    case 'erroring':\n      return null;\n    case 'closed':\n      return 0;\n  }\n  return writableStreamDefaultControllerGetDesiredSize(\n    stream[kState].controller);\n}\n\nfunction writableStreamDefaultWriterEnsureReadyPromiseRejected(writer\x2C error) {\n  if (isPromisePending(writer[kState].ready.promise)) {\n    writer[kState].ready.reject?.(error);\n  } else {\n    writer[kState].ready = {\n      promise: PromiseReject(error)\x2C\n      resolve: undefined\x2C\n      reject: undefined\x2C\n    };\n  }\n  setPromiseHandled(writer[kState].ready.promise);\n}\n\nfunction writableStreamDefaultWriterEnsureClosedPromiseRejected(writer\x2C error) {\n  if (isPromisePending(writer[kState].close.promise)) {\n    writer[kState].close.reject?.(error);\n  } else {\n    writer[kState].close = {\n      promise: PromiseReject(error)\x2C\n      resolve: undefined\x2C\n      reject: undefined\x2C\n    };\n  }\n  setPromiseHandled(writer[kState].close.promise);\n}\n\nfunction writableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  assert(stream !== undefined);\n  const {\n    state\x2C\n  } = stream[kState];\n  if (writableStreamCloseQueuedOrInFlight(stream) || state === 'closed')\n    return PromiseResolve();\n\n  if (state === 'errored')\n    return PromiseReject(stream[kState].storedError);\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return writableStreamDefaultWriterClose(writer);\n}\n\nfunction writableStreamDefaultWriterClose(writer) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  assert(stream !== undefined);\n  return writableStreamClose(stream);\n}\n\nfunction writableStreamDefaultWriterAbort(writer\x2C reason) {\n  const {\n    stream\x2C\n  } = writer[kState];\n  assert(stream !== undefined);\n  return writableStreamAbort(stream\x2C reason);\n}\n\nfunction writableStreamDefaultControllerWrite(controller\x2C chunk\x2C chunkSize) {\n  try {\n    enqueueValueWithSize(controller\x2C chunk\x2C chunkSize);\n  } catch (error) {\n    writableStreamDefaultControllerErrorIfNeeded(controller\x2C error);\n    return;\n  }\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (!writableStreamCloseQueuedOrInFlight(stream) &&\n      stream[kState].state === 'writable') {\n    writableStreamUpdateBackpressure(\n      stream\x2C\n      writableStreamDefaultControllerGetBackpressure(controller));\n  }\n  writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction writableStreamDefaultControllerProcessWrite(controller\x2C chunk) {\n  const {\n    stream\x2C\n    writeAlgorithm\x2C\n  } = controller[kState];\n  writableStreamMarkFirstWriteRequestInFlight(stream);\n\n  PromisePrototypeThen(\n    ensureIsPromise(writeAlgorithm\x2C controller\x2C chunk\x2C controller)\x2C\n    () => {\n      writableStreamFinishInFlightWrite(stream);\n      const {\n        state\x2C\n      } = stream[kState];\n      assert(state === 'writable' || state === 'erroring');\n      dequeueValue(controller);\n      if (!writableStreamCloseQueuedOrInFlight(stream) &&\n          state === 'writable') {\n        writableStreamUpdateBackpressure(\n          stream\x2C\n          writableStreamDefaultControllerGetBackpressure(controller));\n      }\n      writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\x2C\n    (error) => {\n      if (stream[kState].state === 'writable')\n        writableStreamDefaultControllerClearAlgorithms(controller);\n      writableStreamFinishInFlightWriteWithError(stream\x2C error);\n    });\n\n}\n\nfunction writableStreamDefaultControllerProcessClose(controller) {\n  const {\n    closeAlgorithm\x2C\n    queue\x2C\n    stream\x2C\n  } = controller[kState];\n  writableStreamMarkCloseRequestInFlight(stream);\n  dequeueValue(controller);\n  assert(!queue.length);\n  const sinkClosePromise = ensureIsPromise(closeAlgorithm\x2C controller);\n  writableStreamDefaultControllerClearAlgorithms(controller);\n  PromisePrototypeThen(\n    sinkClosePromise\x2C\n    () => writableStreamFinishInFlightClose(stream)\x2C\n    (error) => writableStreamFinishInFlightCloseWithError(stream\x2C error));\n}\n\nfunction writableStreamDefaultControllerGetDesiredSize(controller) {\n  const {\n    highWaterMark\x2C\n    queueTotalSize\x2C\n  } = controller[kState];\n  return highWaterMark - queueTotalSize;\n}\n\nfunction writableStreamDefaultControllerGetChunkSize(controller\x2C chunk) {\n  try {\n    return FunctionPrototypeCall(\n      controller[kState].sizeAlgorithm\x2C\n      undefined\x2C\n      chunk);\n  } catch (error) {\n    writableStreamDefaultControllerErrorIfNeeded(controller\x2C error);\n    return 1;\n  }\n}\n\nfunction writableStreamDefaultControllerErrorIfNeeded(controller\x2C error) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  if (stream[kState].state === 'writable')\n    writableStreamDefaultControllerError(controller\x2C error);\n}\n\nfunction writableStreamDefaultControllerError(controller\x2C error) {\n  const {\n    stream\x2C\n  } = controller[kState];\n  assert(stream[kState].state === 'writable');\n  writableStreamDefaultControllerClearAlgorithms(controller);\n  writableStreamStartErroring(stream\x2C error);\n}\n\nfunction writableStreamDefaultControllerClose(controller) {\n  enqueueValueWithSize(controller\x2C kCloseSentinel\x2C 0);\n  writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction writableStreamDefaultControllerClearAlgorithms(controller) {\n  controller[kState].writeAlgorithm = undefined;\n  controller[kState].closeAlgorithm = undefined;\n  controller[kState].abortAlgorithm = undefined;\n  controller[kState].sizeAlgorithm = undefined;\n}\n\nfunction writableStreamDefaultControllerGetBackpressure(controller) {\n  return writableStreamDefaultControllerGetDesiredSize(controller) <= 0;\n}\n\nfunction writableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  const {\n    queue\x2C\n    started\x2C\n    stream\x2C\n  } = controller[kState];\n  if (!started || stream[kState].inFlightWriteRequest.promise !== undefined)\n    return;\n\n  if (stream[kState].state === 'erroring') {\n    writableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (!queue.length)\n    return;\n\n  const value = peekQueueValue(controller);\n  if (value === kCloseSentinel)\n    writableStreamDefaultControllerProcessClose(controller);\n  else\n    writableStreamDefaultControllerProcessWrite(controller\x2C value);\n}\n\nfunction setupWritableStreamDefaultControllerFromSink(\n  stream\x2C\n  sink\x2C\n  highWaterMark\x2C\n  sizeAlgorithm) {\n  const controller = createWritableStreamDefaultController();\n  const start = sink?.start;\n  const write = sink?.write;\n  const close = sink?.close;\n  const abort = sink?.abort;\n  const startAlgorithm = start ?\n    FunctionPrototypeBind(start\x2C sink\x2C controller) :\n    nonOpStart;\n  const writeAlgorithm = write ?\n    FunctionPrototypeBind(write\x2C sink) :\n    nonOpWrite;\n  const closeAlgorithm = close ?\n    FunctionPrototypeBind(close\x2C sink) : nonOpCancel;\n  const abortAlgorithm = abort ?\n    FunctionPrototypeBind(abort\x2C sink) : nonOpCancel;\n  setupWritableStreamDefaultController(\n    stream\x2C\n    controller\x2C\n    startAlgorithm\x2C\n    writeAlgorithm\x2C\n    closeAlgorithm\x2C\n    abortAlgorithm\x2C\n    highWaterMark\x2C\n    sizeAlgorithm);\n}\n\nfunction setupWritableStreamDefaultController(\n  stream\x2C\n  controller\x2C\n  startAlgorithm\x2C\n  writeAlgorithm\x2C\n  closeAlgorithm\x2C\n  abortAlgorithm\x2C\n  highWaterMark\x2C\n  sizeAlgorithm) {\n  assert(isWritableStream(stream));\n  assert(stream[kState].controller === undefined);\n  controller[kState] = {\n    abortAlgorithm\x2C\n    abortReason: undefined\x2C\n    closeAlgorithm\x2C\n    highWaterMark\x2C\n    queue: []\x2C\n    queueTotalSize: 0\x2C\n    abortController: new AbortController()\x2C\n    sizeAlgorithm\x2C\n    started: false\x2C\n    stream\x2C\n    writeAlgorithm\x2C\n  };\n  stream[kState].controller = controller;\n\n  writableStreamUpdateBackpressure(\n    stream\x2C\n    writableStreamDefaultControllerGetBackpressure(controller));\n\n  const startResult = startAlgorithm();\n\n  PromisePrototypeThen(\n    PromiseResolve(startResult)\x2C\n    () => {\n      assert(stream[kState].state === 'writable' ||\n             stream[kState].state === 'erroring');\n      controller[kState].started = true;\n      writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\x2C\n    (error) => {\n      assert(stream[kState].state === 'writable' ||\n             stream[kState].state === 'erroring');\n      controller[kState].started = true;\n      writableStreamDealWithRejection(stream\x2C error);\n    });\n}\n\nmodule.exports = {\n  WritableStream\x2C\n  WritableStreamDefaultWriter\x2C\n  WritableStreamDefaultController\x2C\n  TransferredWritableStream\x2C\n\n  // Exported Brand Checks\n  isWritableStream\x2C\n  isWritableStreamDefaultController\x2C\n  isWritableStreamDefaultWriter\x2C\n\n  isWritableStreamLocked\x2C\n  setupWritableStreamDefaultWriter\x2C\n  writableStreamAbort\x2C\n  writableStreamClose\x2C\n  writableStreamUpdateBackpressure\x2C\n  writableStreamStartErroring\x2C\n  writableStreamRejectCloseAndClosedPromiseIfNeeded\x2C\n  writableStreamMarkFirstWriteRequestInFlight\x2C\n  writableStreamMarkCloseRequestInFlight\x2C\n  writableStreamHasOperationMarkedInFlight\x2C\n  writableStreamFinishInFlightWriteWithError\x2C\n  writableStreamFinishInFlightWrite\x2C\n  writableStreamFinishInFlightCloseWithError\x2C\n  writableStreamFinishInFlightClose\x2C\n  writableStreamFinishErroring\x2C\n  writableStreamDealWithRejection\x2C\n  writableStreamCloseQueuedOrInFlight\x2C\n  writableStreamAddWriteRequest\x2C\n  writableStreamDefaultWriterWrite\x2C\n  writableStreamDefaultWriterRelease\x2C\n  writableStreamDefaultWriterGetDesiredSize\x2C\n  writableStreamDefaultWriterEnsureReadyPromiseRejected\x2C\n  writableStreamDefaultWriterEnsureClosedPromiseRejected\x2C\n  writableStreamDefaultWriterCloseWithErrorPropagation\x2C\n  writableStreamDefaultWriterClose\x2C\n  writableStreamDefaultWriterAbort\x2C\n  writableStreamDefaultControllerWrite\x2C\n  writableStreamDefaultControllerProcessWrite\x2C\n  writableStreamDefaultControllerProcessClose\x2C\n  writableStreamDefaultControllerGetDesiredSize\x2C\n  writableStreamDefaultControllerGetChunkSize\x2C\n  writableStreamDefaultControllerErrorIfNeeded\x2C\n  writableStreamDefaultControllerError\x2C\n  writableStreamDefaultControllerClose\x2C\n  writableStreamDefaultControllerClearAlgorithms\x2C\n  writableStreamDefaultControllerGetBackpressure\x2C\n  writableStreamDefaultControllerAdvanceQueueIfNeeded\x2C\n  setupWritableStreamDefaultControllerFromSink\x2C\n  setupWritableStreamDefaultController\x2C\n};\n\n/* eslint-enable no-use-before-define */\n
code-source-info,0x24b376418b36,115,0,36581,C0O0C4O36581,,
tick,0x10c26543c,97003,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b37640dd77,0x24b357dbe2b5,0x24b357dbd585,0x24b376402337,0x24b357dbe2b5,0x24b357dbd585,0x24b326978479,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
tick,0x7fff202fa7ff,97027,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b37640dd77,0x24b357dbe2b5,0x24b357dbd585,0x24b376402337,0x24b357dbe2b5,0x24b357dbd585,0x24b326978479,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Function,10,97055,0x24b37641b9d6,1564, node:internal/webstreams/writablestream:1:1,0x24b376418ab0,~
code-source-info,0x24b37641b9d6,115,0,36581,C0O0C381O68C387O90C393O113C399O138C405O163C410O189C416O213C422O231C428O248C434O268C439O278C444O470C447O470C452O470C457O338C463O367C469O394C475O420C481O443C487O527C490O527C495O509C501O628C504O628C509O568C515O614C520O685C523O685C528O665C534O795C537O795C542O727C547O743C552O756C557O773C563O1166C566O1166C571O850C577O867C583O883C589O902C595O926C601O950C607O974C613O990C618O1006C624O1026C630O1044C636O1058C642O1079C648O1094C654O1108C660O1122C666O1131C672O1141C677O1235C680O1235C685O1214C691O1289C694O1289C698O1289C700O1333C703O1333C707O1333C709O1374C712O1374C716O1374C718O1415C721O1415C725O1415C745O2349C755O2384C787O5267C797O5427C807O6268C817O6450C851O2323C853O6665C856O6703C868O6726C874O6756C880O6786C886O6820C890O6665C895O8061C900O8071C904O8085C926O8137C936O8185C986O11471C1020O8098C1022O11724C1025O11775C1037O11798C1043O11828C1049O11864C1055O11894C1061O11924C1067O11960C1073O11990C1077O11724C1100O12059C1110O12111C1120O12224C1132O12383C1160O13179C1194O12016C1196O13313C1199O13368C1211O13396C1217O13427C1223O13457C1227O13313C1232O13712C1235O13712C1239O13712C1241O13784C1244O13784C1248O13784C1250O13873C1253O13873C1257O13873C1259O34656C1266O34677C1272O34695C1278O34726C1284O34761C1290O34818C1296O34838C1302O34875C1308O34909C1314O34935C1320O34971C1326O34994C1332O35017C1338O35053C1344O35084C1350O35137C1356O35184C1362O35226C1368O35270C1374O35316C1380O35353C1386O35399C1392O35436C1398O35468C1404O35503C1410O35542C1416O35575C1422O35611C1428O35649C1434O35694C1440O35751C1446O35809C1452O35865C1458O35901C1464O35937C1470O35977C1476O36024C1482O36071C1488O36120C1494O36167C1500O36215C1506O36255C1512O36295C1518O36345C1524O36395C1534O36450C1544O36498C1554O34671C1563O36580,,
code-creation,Function,10,97291,0x24b37641c2d6,16,<instance_members_initializer> node:internal/webstreams/writablestream:483:3,0x24b37641a330,~
code-source-info,0x24b37641c2d6,115,12058,12101,C3O12068C15O12101,,
code-creation,Function,10,97331,0x24b37641c356,16,<instance_members_initializer> node:internal/webstreams/writablestream:339:3,0x24b37641a038,~
code-source-info,0x24b37641c356,115,8136,8175,C3O8146C15O8175,,
code-creation,Function,10,97354,0x24b37641c3ce,16,<instance_members_initializer> node:internal/webstreams/writablestream:112:3,0x24b376419bf0,~
code-source-info,0x24b37641c3ce,115,2348,2374,C3O2358C15O2374,,
tick,0x7fff203572be,97386,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b37640dd77,0x24b357dbe2b5,0x24b357dbd585,0x24b376402337,0x24b357dbe2b5,0x24b357dbd585,0x24b326978479,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,LazyCompile,10,97762,0x24b37641fa76,14,isBrandCheck node:internal/webstreams/util:112:22,0x24b376415c98,~
code-source-info,0x24b37641fa76,114,2398,2541,C0O2398C9O2410C13O2539,,
code-creation,Eval,10,98315,0x24b376420cb6,5, node:internal/webstreams/queuingstrategies:1:1,0x24b3764209c0,~
script-source,116,node:internal/webstreams/queuingstrategies,'use strict';\n\nconst {\n  ObjectDefineProperties\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_THIS\x2C\n    ERR_MISSING_OPTION\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n} = require('internal/util');\n\nconst {\n  customInspect\x2C\n  isBrandCheck\x2C\n  kType\x2C\n  kState\x2C\n  kEnumerableProperty\x2C\n} = require('internal/webstreams/util');\n\nconst {\n  validateObject\x2C\n} = require('internal/validators');\n\nconst isByteLengthQueuingStrategy =\n  isBrandCheck('ByteLengthQueuingStrategy');\n\nconst isCountQueuingStrategy =\n  isBrandCheck('CountQueuingStrategy');\n\n/**\n * @callback QueuingStrategySize\n * @param {any} chunk\n * @returns {number}\n *\n * @typedef {{\n *   highWaterMark : number\x2C\n *   size? : QueuingStrategySize\x2C\n * }} QueuingStrategy\n */\n\n// eslint-disable-next-line func-name-matching\x2Cfunc-style\nconst byteSizeFunction = function size(chunk) { return chunk.byteLength; };\n\n// eslint-disable-next-line func-name-matching\x2Cfunc-style\nconst countSizeFunction = function size() { return 1; };\n\n/**\n * @type {QueuingStrategy}\n */\nclass ByteLengthQueuingStrategy {\n  [kType] = 'ByteLengthQueuingStrategy';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {{\n   *   highWaterMark : number\n   * }} init\n   */\n  constructor(init) {\n    validateObject(init\x2C 'init');\n    if (init.highWaterMark === undefined)\n      throw new ERR_MISSING_OPTION('options.highWaterMark');\n\n    // The highWaterMark value is not checked until the strategy\n    // is actually used\x2C per the spec.\n    this[kState] = {\n      highWaterMark: +init.highWaterMark\x2C\n    };\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get highWaterMark() {\n    if (!isByteLengthQueuingStrategy(this))\n      throw new ERR_INVALID_THIS('ByteLengthQueuingStrategy');\n    return this[kState].highWaterMark;\n  }\n\n  /**\n   * @type {QueuingStrategySize}\n   */\n  get size() {\n    if (!isByteLengthQueuingStrategy(this))\n      throw new ERR_INVALID_THIS('ByteLengthQueuingStrategy');\n    return byteSizeFunction;\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      highWaterMark: this.highWaterMark\x2C\n    });\n  }\n}\n\nObjectDefineProperties(ByteLengthQueuingStrategy.prototype\x2C {\n  highWaterMark: kEnumerableProperty\x2C\n  size: kEnumerableProperty\x2C\n});\n\n/**\n * @type {QueuingStrategy}\n */\nclass CountQueuingStrategy {\n  [kType] = 'CountQueuingStrategy';\n\n  get [SymbolToStringTag]() { return this[kType]; }\n\n  /**\n   * @param {{\n   *   highWaterMark : number\n   * }} init\n   */\n  constructor(init) {\n    validateObject(init\x2C 'init');\n    if (init.highWaterMark === undefined)\n      throw new ERR_MISSING_OPTION('options.highWaterMark');\n\n    // The highWaterMark value is not checked until the strategy\n    // is actually used\x2C per the spec.\n    this[kState] = {\n      highWaterMark: +init.highWaterMark\x2C\n    };\n  }\n\n  /**\n   * @readonly\n   * @type {number}\n   */\n  get highWaterMark() {\n    if (!isCountQueuingStrategy(this))\n      throw new ERR_INVALID_THIS('CountQueuingStrategy');\n    return this[kState].highWaterMark;\n  }\n\n  /**\n   * @type {QueuingStrategySize}\n   */\n  get size() {\n    if (!isCountQueuingStrategy(this))\n      throw new ERR_INVALID_THIS('CountQueuingStrategy');\n    return countSizeFunction;\n  }\n\n  [kInspect](depth\x2C options) {\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\n      highWaterMark: this.highWaterMark\x2C\n    });\n  }\n}\n\nObjectDefineProperties(CountQueuingStrategy.prototype\x2C {\n  highWaterMark: kEnumerableProperty\x2C\n  size: kEnumerableProperty\x2C\n});\n\nmodule.exports = {\n  ByteLengthQueuingStrategy\x2C\n  CountQueuingStrategy\x2C\n};\n
code-source-info,0x24b376420cb6,116,0,3631,C0O0C4O3631,,
code-creation,Function,10,98628,0x24b3764219ae,404, node:internal/webstreams/queuingstrategies:1:1,0x24b376420c30,~
code-source-info,0x24b3764219ae,116,0,3631,C0O0C35O25C40O51C45O162C48O162C53O162C58O111C64O133C70O236C73O236C78O222C83O350C86O350C91O273C97O290C102O306C108O315C114O325C119O418C122O418C127O398C133O489C136O489C140O489C142O566C145O566C149O566C151O876C155O876C157O1012C161O1012C180O1116C190O1162C209O2043C244O2232C256O2262C262O2291C266O2183C288O2384C298O2425C317O3287C352O3471C364O3501C370O3530C374O3427C379O3556C386O3577C392O3606C398O3571C403O3630,,
code-creation,Function,10,98672,0x24b376421c66,16,<instance_members_initializer> node:internal/webstreams/queuingstrategies:114:3,0x24b376421160,~
code-source-info,0x24b376421c66,116,2383,2415,C3O2393C15O2415,,
code-creation,Function,10,98721,0x24b376421cde,16,<instance_members_initializer> node:internal/webstreams/queuingstrategies:58:3,0x24b376420f58,~
code-source-info,0x24b376421cde,116,1115,1152,C3O1125C15O1152,,
tick,0x7fff2038515d,98760,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b37640235f,0x24b357dbe2b5,0x24b357dbd585,0x24b326978479,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,LazyCompile,10,99066,0x24b376422a56,251,promisify node:internal/util:324:19,0x24b3c05aa860,~
script-source,12,node:internal/util,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_NO_CRYPTO\x2C\n    ERR_UNKNOWN_SIGNAL\n  }\x2C\n  uvErrmapGet\x2C\n  overrideStackTrace\x2C\n} = require('internal/errors');\nconst { signals } = internalBinding('constants').os;\nconst {\n  getHiddenValue\x2C\n  setHiddenValue\x2C\n  arrow_message_private_symbol: kArrowMessagePrivateSymbolIndex\x2C\n  decorated_private_symbol: kDecoratedPrivateSymbolIndex\x2C\n  sleep: _sleep\x2C\n  toUSVString: _toUSVString\x2C\n} = internalBinding('util');\nconst { isNativeError } = internalBinding('types');\n\nconst noCrypto = !process.versions.openssl;\n\nconst experimentalWarnings = new SafeSet();\n\nconst colorRegExp = /\\u001b\\[\\d\\d?m/g; // eslint-disable-line no-control-regex\n\nconst unpairedSurrogateRe =\n  /(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\nfunction toUSVString(val) {\n  const str = `${val}`;\n  // As of V8 5.5\x2C `str.search()` (and `unpairedSurrogateRe[@@search]()`) are\n  // slower than `unpairedSurrogateRe.exec()`.\n  const match = RegExpPrototypeExec(unpairedSurrogateRe\x2C str);\n  if (!match)\n    return str;\n  return _toUSVString(str\x2C match.index);\n}\n\nlet uvBinding;\n\nfunction lazyUv() {\n  uvBinding ??= internalBinding('uv');\n  return uvBinding;\n}\n\nfunction removeColors(str) {\n  return StringPrototypeReplace(str\x2C colorRegExp\x2C '');\n}\n\nfunction isError(e) {\n  // An error could be an instance of Error while not being a native error\n  // or could be from a different realm and not be instance of Error but still\n  // be a native error.\n  return isNativeError(e) || e instanceof Error;\n}\n\n// Keep a list of deprecation codes that have been warned on so we only warn on\n// each one once.\nconst codesWarned = new SafeSet();\n\nlet validateString;\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set\x2C then it is a no-op.\nfunction deprecate(fn\x2C msg\x2C code) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Lazy-load to avoid a circular dependency.\n  if (validateString === undefined)\n    ({ validateString } = require('internal/validators'));\n\n  if (code !== undefined)\n    validateString(code\x2C 'code');\n\n  let warned = false;\n  function deprecated(...args) {\n    if (!warned) {\n      warned = true;\n      if (code !== undefined) {\n        if (!codesWarned.has(code)) {\n          process.emitWarning(msg\x2C 'DeprecationWarning'\x2C code\x2C deprecated);\n          codesWarned.add(code);\n        }\n      } else {\n        process.emitWarning(msg\x2C 'DeprecationWarning'\x2C deprecated);\n      }\n    }\n    if (new.target) {\n      return ReflectConstruct(fn\x2C args\x2C new.target);\n    }\n    return ReflectApply(fn\x2C this\x2C args);\n  }\n\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  ObjectSetPrototypeOf(deprecated\x2C fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype\x2C as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nfunction decorateErrorStack(err) {\n  if (!(isError(err) && err.stack) ||\n      getHiddenValue(err\x2C kDecoratedPrivateSymbolIndex) === true)\n    return;\n\n  const arrow = getHiddenValue(err\x2C kArrowMessagePrivateSymbolIndex);\n\n  if (arrow) {\n    err.stack = arrow + err.stack;\n    setHiddenValue(err\x2C kDecoratedPrivateSymbolIndex\x2C true);\n  }\n}\n\nfunction assertCrypto() {\n  if (noCrypto)\n    throw new ERR_NO_CRYPTO();\n}\n\n// Return undefined if there is no match.\n// Move the "slow cases" to a separate function to make sure this function gets\n// inlined properly. That prioritizes the common case.\nfunction normalizeEncoding(enc) {\n  if (enc == null || enc === 'utf8' || enc === 'utf-8') return 'utf8';\n  return slowCases(enc);\n}\n\nfunction slowCases(enc) {\n  switch (enc.length) {\n    case 4:\n      if (enc === 'UTF8') return 'utf8';\n      if (enc === 'ucs2' || enc === 'UCS2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf8') return 'utf8';\n      if (enc === 'ucs2') return 'utf16le';\n      break;\n    case 3:\n      if (enc === 'hex' || enc === 'HEX' ||\n          `${enc}`.toLowerCase() === 'hex')\n        return 'hex';\n      break;\n    case 5:\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      if (enc === 'UTF-8') return 'utf8';\n      if (enc === 'ASCII') return 'ascii';\n      if (enc === 'UCS-2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf-8') return 'utf8';\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      break;\n    case 6:\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      if (enc === 'BASE64') return 'base64';\n      if (enc === 'LATIN1' || enc === 'BINARY') return 'latin1';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      break;\n    case 7:\n      if (enc === 'utf16le' || enc === 'UTF16LE' ||\n          `${enc}`.toLowerCase() === 'utf16le')\n        return 'utf16le';\n      break;\n    case 8:\n      if (enc === 'utf-16le' || enc === 'UTF-16LE' ||\n        `${enc}`.toLowerCase() === 'utf-16le')\n        return 'utf16le';\n      break;\n    case 9:\n      if (enc === 'base64url' || enc === 'BASE64URL' ||\n          `${enc}`.toLowerCase() === 'base64url')\n        return 'base64url';\n      break;\n    default:\n      if (enc === '') return 'utf8';\n  }\n}\n\nfunction emitExperimentalWarning(feature) {\n  if (experimentalWarnings.has(feature)) return;\n  const msg = `${feature} is an experimental feature. This feature could ` +\n       'change at any time';\n  experimentalWarnings.add(feature);\n  process.emitWarning(msg\x2C 'ExperimentalWarning');\n}\n\nfunction filterDuplicateStrings(items\x2C low) {\n  const map = new SafeMap();\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const key = StringPrototypeToLowerCase(item);\n    if (low) {\n      map.set(key\x2C key);\n    } else {\n      map.set(key\x2C item);\n    }\n  }\n  return ArrayPrototypeSort(ArrayFrom(map.values()));\n}\n\nfunction cachedResult(fn) {\n  let result;\n  return () => {\n    if (result === undefined)\n      result = fn();\n    return ArrayPrototypeSlice(result);\n  };\n}\n\n// Useful for Wrapping an ES6 Class with a constructor Function that\n// does not require the new keyword. For instance:\n//   class A { constructor(x) {this.x = x;}}\n//   const B = createClassWrapper(A);\n//   B() instanceof A // true\n//   B() instanceof B // true\nfunction createClassWrapper(type) {\n  function fn(...args) {\n    return ReflectConstruct(type\x2C args\x2C new.target || type);\n  }\n  // Mask the wrapper function name and length values\n  ObjectDefineProperties(fn\x2C {\n    name: { value: type.name }\x2C\n    length: { value: type.length }\n  });\n  ObjectSetPrototypeOf(fn\x2C type);\n  fn.prototype = type.prototype;\n  return fn;\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined)\n    return signalsToNamesMapping;\n\n  signalsToNamesMapping = ObjectCreate(null);\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction convertToValidSignal(signal) {\n  if (typeof signal === 'number' && getSignalsToNamesMapping()[signal])\n    return signal;\n\n  if (typeof signal === 'string') {\n    const signalName = signals[StringPrototypeToUpperCase(signal)];\n    if (signalName) return signalName;\n  }\n\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\n\nfunction getConstructorOf(obj) {\n  while (obj) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '') {\n      return descriptor.value;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n  }\n\n  return null;\n}\n\nfunction getSystemErrorName(err) {\n  const entry = uvErrmapGet(err);\n  return entry ? entry[0] : `Unknown system error ${err}`;\n}\n\nfunction getSystemErrorMap() {\n  return lazyUv().getErrorMap();\n}\n\nconst kCustomPromisifiedSymbol = SymbolFor('nodejs.util.promisify.custom');\nconst kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');\n\nlet validateFunction;\n\nfunction promisify(original) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateFunction === undefined)\n    ({ validateFunction } = require('internal/validators'));\n\n  validateFunction(original\x2C 'original');\n\n  if (original[kCustomPromisifiedSymbol]) {\n    const fn = original[kCustomPromisifiedSymbol];\n\n    validateFunction(fn\x2C 'util.promisify.custom');\n\n    return ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n      value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments\x2C e.g. ['bytesRead'\x2C 'buffer'] for fs.read.\n  const argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve\x2C reject) => {\n      ArrayPrototypePush(args\x2C (err\x2C ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          const obj = {};\n          for (let i = 0; i < argumentNames.length; i++)\n            obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original\x2C this\x2C args);\n    });\n  }\n\n  ObjectSetPrototypeOf(fn\x2C ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n    value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\n  });\n  return ObjectDefineProperties(\n    fn\x2C\n    ObjectGetOwnPropertyDescriptors(original)\n  );\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// The built-in Array#join is slower in v8 6.0\nfunction join(output\x2C separator) {\n  let str = '';\n  if (output.length !== 0) {\n    const lastIndex = output.length - 1;\n    for (let i = 0; i < lastIndex; i++) {\n      // It is faster not to use a template string here\n      str += output[i];\n      str += separator;\n    }\n    str += output[lastIndex];\n  }\n  return str;\n}\n\n// As of V8 6.6\x2C depending on the size of the array\x2C this is anywhere\n// between 1.5-10x faster than the two-arg version of Array#splice()\nfunction spliceOne(list\x2C index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nconst kNodeModulesRE = /^(.*)[\\\\/]node_modules[\\\\/]/;\n\nlet getStructuredStack;\n\nfunction isInsideNodeModules() {\n  if (getStructuredStack === undefined) {\n    // Lazy-load to avoid a circular dependency.\n    const { runInNewContext } = require('vm');\n    // Use `runInNewContext()` to get something tamper-proof and\n    // side-effect-free. Since this is currently only used for a deprecated API\x2C\n    // the perf implications should be okay.\n    getStructuredStack = runInNewContext(`(function() {\n      try { Error.stackTraceLimit = Infinity; } catch {}\n      return function structuredStack() {\n        const e = new Error();\n        overrideStackTrace.set(e\x2C (err\x2C trace) => trace);\n        return e.stack;\n      };\n    })()`\x2C { overrideStackTrace }\x2C { filename: 'structured-stack' });\n  }\n\n  const stack = getStructuredStack();\n\n  // Iterate over all stack frames and look for the first one not coming\n  // from inside Node.js itself:\n  if (ArrayIsArray(stack)) {\n    for (const frame of stack) {\n      const filename = frame.getFileName();\n      // If a filename does not start with / or contain \\\x2C\n      // it's likely from Node.js core.\n      if (!RegExpPrototypeTest(/^\\/|\\\\/\x2C filename))\n        continue;\n      return RegExpPrototypeTest(kNodeModulesRE\x2C filename);\n    }\n  }\n  return false;\n}\n\nfunction once(callback) {\n  let called = false;\n  return function(...args) {\n    if (called) return;\n    called = true;\n    ReflectApply(callback\x2C this\x2C args);\n  };\n}\n\nlet validateUint32;\n\nfunction sleep(msec) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateUint32 === undefined)\n    ({ validateUint32 } = require('internal/validators'));\n\n  validateUint32(msec\x2C 'msec');\n  _sleep(msec);\n}\n\nfunction createDeferredPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res\x2C rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise\x2C resolve\x2C reject };\n}\n\nlet _DOMException;\nconst lazyDOMExceptionClass = () => {\n  _DOMException ??= internalBinding('messaging').DOMException;\n  return _DOMException;\n};\n\nconst lazyDOMException = hideStackFrames((message\x2C name) => {\n  _DOMException ??= internalBinding('messaging').DOMException;\n  return new _DOMException(message\x2C name);\n});\n\nfunction structuredClone(value) {\n  const {\n    DefaultSerializer\x2C\n    DefaultDeserializer\x2C\n  } = require('v8');\n  const ser = new DefaultSerializer();\n  ser._getDataCloneError = hideStackFrames((message) =>\n    lazyDOMException(message\x2C 'DataCloneError'));\n  ser.writeValue(value);\n  const serialized = ser.releaseBuffer();\n\n  const des = new DefaultDeserializer(serialized);\n  return des.readValue();\n}\n\nmodule.exports = {\n  assertCrypto\x2C\n  cachedResult\x2C\n  convertToValidSignal\x2C\n  createClassWrapper\x2C\n  createDeferredPromise\x2C\n  decorateErrorStack\x2C\n  deprecate\x2C\n  emitExperimentalWarning\x2C\n  filterDuplicateStrings\x2C\n  getConstructorOf\x2C\n  getSystemErrorMap\x2C\n  getSystemErrorName\x2C\n  isError\x2C\n  isInsideNodeModules\x2C\n  join\x2C\n  lazyDOMException\x2C\n  lazyDOMExceptionClass\x2C\n  normalizeEncoding\x2C\n  once\x2C\n  promisify\x2C\n  sleep\x2C\n  spliceOne\x2C\n  structuredClone\x2C\n  toUSVString\x2C\n  removeColors\x2C\n\n  // Symbol used to customize promisify conversion\n  customPromisifyArgs: kCustomPromisifyArgsSymbol\x2C\n\n  // Symbol used to provide a custom inspect function for an object as an\n  // alternative to using 'inspect'\n  customInspectSymbol: SymbolFor('nodejs.util.inspect.custom')\x2C\n\n  // Used by the buffer module to capture an internal reference to the\n  // default isEncoding implementation\x2C just in case userland overrides it.\n  kIsEncodingSymbol: Symbol('kIsEncodingSymbol')\x2C\n  kVmBreakFirstLineSymbol: Symbol('kVmBreakFirstLineSymbol')\n};\n
code-source-info,0x24b376422a56,12,8845,10349,C0O8845C17O8907C25O8947C33O8971C38O8950C55O9007C68O9007C73O9050C80O9063C82O9062C87O9107C94O9116C96O9115C100O9148C110O9148C115O9200C126O9232C136O9273C143O9207C148O9339C149O9502C156O9511C158O9510C161O9502C163O10066C174O10091C180O10091C185O10066C190O10127C201O10152C211O10191C218O10127C223O10258C234O10301C240O10301C245O10265C250O10347,,
tick,0x7fff20384e6c,100121,0,0x0,3,0x10c825337,0x24b326978499,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,LazyCompile,10,100288,0x24b3764242b6,65,EventEmitterMixin node:internal/event_target:827:27,0x24b3bc5b69a0,~
script-source,38,node:internal/event_target,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  Boolean\x2C\n  Error\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ReflectApply\x2C\n  SafeArrayIterator\x2C\n  SafeFinalizationRegistry\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SafeWeakSet\x2C\n  String\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_EVENT_RECURSION\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_INVALID_THIS\x2C\n  }\n} = require('internal/errors');\nconst { validateObject\x2C validateString } = require('internal/validators');\n\nconst { customInspectSymbol } = require('internal/util');\nconst { inspect } = require('util');\n\nconst kIsEventTarget = SymbolFor('nodejs.event_target');\nconst kIsNodeEventTarget = Symbol('kIsNodeEventTarget');\n\nconst EventEmitter = require('events');\nconst {\n  kMaxEventTargetListeners\x2C\n  kMaxEventTargetListenersWarned\x2C\n} = EventEmitter;\n\nconst kEvents = Symbol('kEvents');\nconst kIsBeingDispatched = Symbol('kIsBeingDispatched');\nconst kStop = Symbol('kStop');\nconst kTarget = Symbol('kTarget');\nconst kHandlers = Symbol('khandlers');\nconst kWeakHandler = Symbol('kWeak');\n\nconst kHybridDispatch = SymbolFor('nodejs.internal.kHybridDispatch');\nconst kCreateEvent = Symbol('kCreateEvent');\nconst kNewListener = Symbol('kNewListener');\nconst kRemoveListener = Symbol('kRemoveListener');\nconst kIsNodeStyleListener = Symbol('kIsNodeStyleListener');\nconst kTrustEvent = Symbol('kTrustEvent');\n\nconst { now } = require('internal/perf/utils');\n\n// TODO(joyeecheung): V8 snapshot does not support instance member\n// initializers for now:\n// https://bugs.chromium.org/p/v8/issues/detail?id=10704\nconst kType = Symbol('type');\nconst kDefaultPrevented = Symbol('defaultPrevented');\nconst kCancelable = Symbol('cancelable');\nconst kTimestamp = Symbol('timestamp');\nconst kBubbles = Symbol('bubbles');\nconst kComposed = Symbol('composed');\nconst kPropagationStopped = Symbol('propagationStopped');\n\nconst isTrustedSet = new SafeWeakSet();\nconst isTrusted = ObjectGetOwnPropertyDescriptor({\n  get isTrusted() {\n    return isTrustedSet.has(this);\n  }\n}\x2C 'isTrusted').get;\n\nfunction isEvent(value) {\n  return typeof value?.[kType] === 'string';\n}\n\nclass Event {\n  constructor(type\x2C options = null) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('type');\n    validateObject(options\x2C 'options'\x2C {\n      allowArray: true\x2C allowFunction: true\x2C nullable: true\x2C\n    });\n    const { cancelable\x2C bubbles\x2C composed } = { ...options };\n    this[kCancelable] = !!cancelable;\n    this[kBubbles] = !!bubbles;\n    this[kComposed] = !!composed;\n    this[kType] = `${type}`;\n    this[kDefaultPrevented] = false;\n    this[kTimestamp] = now();\n    this[kPropagationStopped] = false;\n    if (options?.[kTrustEvent]) {\n      isTrustedSet.add(this);\n    }\n\n    // isTrusted is special (LegacyUnforgeable)\n    ObjectDefineProperty(this\x2C 'isTrusted'\x2C {\n      get: isTrusted\x2C\n      enumerable: true\x2C\n      configurable: false\n    });\n    this[kTarget] = null;\n    this[kIsBeingDispatched] = false;\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n\n    return `${name} ${inspect({\n      type: this[kType]\x2C\n      defaultPrevented: this[kDefaultPrevented]\x2C\n      cancelable: this[kCancelable]\x2C\n      timeStamp: this[kTimestamp]\x2C\n    }\x2C opts)}`;\n  }\n\n  stopImmediatePropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kStop] = true;\n  }\n\n  preventDefault() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kDefaultPrevented] = true;\n  }\n\n  get target() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  get currentTarget() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  get srcElement() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  get type() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kType];\n  }\n\n  get cancelable() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kCancelable];\n  }\n\n  get defaultPrevented() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kCancelable] && this[kDefaultPrevented];\n  }\n\n  get timeStamp() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTimestamp];\n  }\n\n\n  // The following are non-op and unused properties/methods from Web API Event.\n  // These are not supported in Node.js and are provided purely for\n  // API completeness.\n\n  composedPath() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? [this[kTarget]] : [];\n  }\n\n  get returnValue() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return !this.defaultPrevented;\n  }\n\n  get bubbles() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kBubbles];\n  }\n\n  get composed() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kComposed];\n  }\n\n  get eventPhase() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? Event.AT_TARGET : Event.NONE;\n  }\n\n  get cancelBubble() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kPropagationStopped];\n  }\n\n  set cancelBubble(value) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    if (value) {\n      this.stopPropagation();\n    }\n  }\n\n  stopPropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kPropagationStopped] = true;\n  }\n\n  static NONE = 0;\n  static CAPTURING_PHASE = 1;\n  static AT_TARGET = 2;\n  static BUBBLING_PHASE = 3;\n}\n\nconst kEnumerableProperty = ObjectCreate(null);\nkEnumerableProperty.enumerable = true;\n\nObjectDefineProperties(\n  Event.prototype\x2C {\n    [SymbolToStringTag]: {\n      writable: false\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: 'Event'\x2C\n    }\x2C\n    stopImmediatePropagation: kEnumerableProperty\x2C\n    preventDefault: kEnumerableProperty\x2C\n    target: kEnumerableProperty\x2C\n    currentTarget: kEnumerableProperty\x2C\n    srcElement: kEnumerableProperty\x2C\n    type: kEnumerableProperty\x2C\n    cancelable: kEnumerableProperty\x2C\n    defaultPrevented: kEnumerableProperty\x2C\n    timeStamp: kEnumerableProperty\x2C\n    composedPath: kEnumerableProperty\x2C\n    returnValue: kEnumerableProperty\x2C\n    bubbles: kEnumerableProperty\x2C\n    composed: kEnumerableProperty\x2C\n    eventPhase: kEnumerableProperty\x2C\n    cancelBubble: kEnumerableProperty\x2C\n    stopPropagation: kEnumerableProperty\x2C\n  });\n\nclass NodeCustomEvent extends Event {\n  constructor(type\x2C options) {\n    super(type\x2C options);\n    if (options?.detail) {\n      this.detail = options.detail;\n    }\n  }\n}\n\n// Weak listener cleanup\n// This has to be lazy for snapshots to work\nlet weakListenersState = null;\n// The resource needs to retain the callback so that it doesn't\n// get garbage collected now that it's weak.\nlet objectToWeakListenerMap = null;\nfunction weakListeners() {\n  weakListenersState ??= new SafeFinalizationRegistry(\n    (listener) => listener.remove()\n  );\n  objectToWeakListenerMap ??= new SafeWeakMap();\n  return { registry: weakListenersState\x2C map: objectToWeakListenerMap };\n}\n\n// The listeners for an EventTarget are maintained as a linked list.\n// Unfortunately\x2C the way EventTarget is defined\x2C listeners are accounted\n// using the tuple [handler\x2Ccapture]\x2C and even if we don't actually make\n// use of capture or bubbling\x2C in order to be spec compliant we have to\n// take on the additional complexity of supporting it. Fortunately\x2C using\n// the linked list makes dispatching faster\x2C even if adding/removing is\n// slower.\nclass Listener {\n  constructor(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n              isNodeStyleListener\x2C weak) {\n    this.next = undefined;\n    if (previous !== undefined)\n      previous.next = this;\n    this.previous = previous;\n    this.listener = listener;\n    // TODO(benjamingr) these 4 can be 'flags' to save 3 slots\n    this.once = once;\n    this.capture = capture;\n    this.passive = passive;\n    this.isNodeStyleListener = isNodeStyleListener;\n    this.removed = false;\n    this.weak = Boolean(weak); // Don't retain the object\n\n    if (this.weak) {\n      this.callback = new SafeWeakRef(listener);\n      weakListeners().registry.register(listener\x2C this\x2C this);\n      // Make the retainer retain the listener in a WeakMap\n      weakListeners().map.set(weak\x2C listener);\n      this.listener = this.callback;\n    } else if (typeof listener === 'function') {\n      this.callback = listener;\n      this.listener = listener;\n    } else {\n      this.callback = FunctionPrototypeBind(listener.handleEvent\x2C listener);\n      this.listener = listener;\n    }\n  }\n\n  same(listener\x2C capture) {\n    const myListener = this.weak ? this.listener.deref() : this.listener;\n    return myListener === listener && this.capture === capture;\n  }\n\n  remove() {\n    if (this.previous !== undefined)\n      this.previous.next = this.next;\n    if (this.next !== undefined)\n      this.next.previous = this.previous;\n    this.removed = true;\n    if (this.weak)\n      weakListeners().registry.unregister(this);\n  }\n}\n\nfunction initEventTarget(self) {\n  self[kEvents] = new SafeMap();\n  self[kMaxEventTargetListeners] = EventEmitter.defaultMaxListeners;\n  self[kMaxEventTargetListenersWarned] = false;\n}\n\nclass EventTarget {\n  // Used in checking whether an object is an EventTarget. This is a well-known\n  // symbol as EventTarget may be used cross-realm.\n  // Ref: https://github.com/nodejs/node/pull/33661\n  static [kIsEventTarget] = true;\n\n  constructor() {\n    initEventTarget(this);\n  }\n\n  [kNewListener](size\x2C type\x2C listener\x2C once\x2C capture\x2C passive) {\n    if (this[kMaxEventTargetListeners] > 0 &&\n        size > this[kMaxEventTargetListeners] &&\n        !this[kMaxEventTargetListenersWarned]) {\n      this[kMaxEventTargetListenersWarned] = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventTarget memory leak detected. ' +\n                          `${size} ${type} listeners ` +\n                          `added to ${inspect(this\x2C { depth: -1 })}. Use ` +\n                          'events.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.target = this;\n      w.type = type;\n      w.count = size;\n      process.emitWarning(w);\n    }\n  }\n  [kRemoveListener](size\x2C type\x2C listener\x2C capture) {}\n\n  addEventListener(type\x2C listener\x2C options = {}) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (arguments.length < 2)\n      throw new ERR_MISSING_ARGS('type'\x2C 'listener');\n\n    // We validateOptions before the shouldAddListeners check because the spec\n    // requires us to hit getters.\n    const {\n      once\x2C\n      capture\x2C\n      passive\x2C\n      signal\x2C\n      isNodeStyleListener\x2C\n      weak\x2C\n    } = validateEventListenerOptions(options);\n\n    if (!shouldAddListener(listener)) {\n      // The DOM silently allows passing undefined as a second argument\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error(`addEventListener called with ${listener}` +\n                          ' which has no effect.');\n      w.name = 'AddEventListenerArgumentTypeWarning';\n      w.target = this;\n      w.type = type;\n      process.emitWarning(w);\n      return;\n    }\n    type = String(type);\n\n    if (signal) {\n      if (signal.aborted) {\n        return;\n      }\n      // TODO(benjamingr) make this weak somehow? ideally the signal would\n      // not prevent the event target from GC.\n      signal.addEventListener('abort'\x2C () => {\n        this.removeEventListener(type\x2C listener\x2C options);\n      }\x2C { once: true\x2C [kWeakHandler]: this });\n    }\n\n    let root = this[kEvents].get(type);\n\n    if (root === undefined) {\n      root = { size: 1\x2C next: undefined };\n      // This is the first handler in our linked list.\n      new Listener(root\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                   isNodeStyleListener\x2C weak);\n      this[kNewListener](root.size\x2C type\x2C listener\x2C once\x2C capture\x2C passive);\n      this[kEvents].set(type\x2C root);\n      return;\n    }\n\n    let handler = root.next;\n    let previous = root;\n\n    // We have to walk the linked list to see if we have a match\n    while (handler !== undefined && !handler.same(listener\x2C capture)) {\n      previous = handler;\n      handler = handler.next;\n    }\n\n    if (handler !== undefined) { // Duplicate! Ignore\n      return;\n    }\n\n    new Listener(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                 isNodeStyleListener\x2C weak);\n    root.size++;\n    this[kNewListener](root.size\x2C type\x2C listener\x2C once\x2C capture\x2C passive);\n  }\n\n  removeEventListener(type\x2C listener\x2C options = {}) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (!shouldAddListener(listener))\n      return;\n\n    type = String(type);\n    const capture = options?.capture === true;\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined)\n      return;\n\n    let handler = root.next;\n    while (handler !== undefined) {\n      if (handler.same(listener\x2C capture)) {\n        handler.remove();\n        root.size--;\n        if (root.size === 0)\n          this[kEvents].delete(type);\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n        break;\n      }\n      handler = handler.next;\n    }\n  }\n\n  dispatchEvent(event) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n\n    if (!(event instanceof Event))\n      throw new ERR_INVALID_ARG_TYPE('event'\x2C 'Event'\x2C event);\n\n    if (event[kIsBeingDispatched])\n      throw new ERR_EVENT_RECURSION(event.type);\n\n    this[kHybridDispatch](event\x2C event.type\x2C event);\n\n    return event.defaultPrevented !== true;\n  }\n\n  [kHybridDispatch](nodeValue\x2C type\x2C event) {\n    const createEvent = () => {\n      if (event === undefined) {\n        event = this[kCreateEvent](nodeValue\x2C type);\n        event[kTarget] = this;\n        event[kIsBeingDispatched] = true;\n      }\n      return event;\n    };\n    if (event !== undefined) {\n      event[kTarget] = this;\n      event[kIsBeingDispatched] = true;\n    }\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined) {\n      if (event !== undefined)\n        event[kIsBeingDispatched] = false;\n      return true;\n    }\n\n    let handler = root.next;\n    let next;\n\n    while (handler !== undefined &&\n           (handler.passive || event?.[kStop] !== true)) {\n      // Cache the next item in case this iteration removes the current one\n      next = handler.next;\n\n      if (handler.removed) {\n        // Deal with the case an event is removed while event handlers are\n        // Being processed (removeEventListener called from a listener)\n        handler = next;\n        continue;\n      }\n      if (handler.once) {\n        handler.remove();\n        root.size--;\n        const { listener\x2C capture } = handler;\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n      }\n\n      try {\n        let arg;\n        if (handler.isNodeStyleListener) {\n          arg = nodeValue;\n        } else {\n          arg = createEvent();\n        }\n        const callback = handler.weak ?\n          handler.callback.deref() : handler.callback;\n        let result;\n        if (callback) {\n          result = FunctionPrototypeCall(callback\x2C this\x2C arg);\n          if (!handler.isNodeStyleListener) {\n            arg[kIsBeingDispatched] = false;\n          }\n        }\n        if (result !== undefined && result !== null)\n          addCatch(result);\n      } catch (err) {\n        emitUncaughtException(err);\n      }\n\n      handler = next;\n    }\n\n    if (event !== undefined)\n      event[kIsBeingDispatched] = false;\n  }\n\n  [kCreateEvent](nodeValue\x2C type) {\n    return new NodeCustomEvent(type\x2C { detail: nodeValue });\n  }\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n\n    return `${name} ${inspect({}\x2C opts)}`;\n  }\n}\n\nObjectDefineProperties(EventTarget.prototype\x2C {\n  addEventListener: kEnumerableProperty\x2C\n  removeEventListener: kEnumerableProperty\x2C\n  dispatchEvent: kEnumerableProperty\x2C\n  [SymbolToStringTag]: {\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: 'EventTarget'\x2C\n  }\n});\n\nfunction initNodeEventTarget(self) {\n  initEventTarget(self);\n}\n\nclass NodeEventTarget extends EventTarget {\n  static [kIsNodeEventTarget] = true;\n  static defaultMaxListeners = 10;\n\n  constructor() {\n    super();\n    initNodeEventTarget(this);\n  }\n\n  setMaxListeners(n) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    EventEmitter.setMaxListeners(n\x2C this);\n  }\n\n  getMaxListeners() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return this[kMaxEventTargetListeners];\n  }\n\n  eventNames() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return ArrayFrom(this[kEvents].keys());\n  }\n\n  listenerCount(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    const root = this[kEvents].get(String(type));\n    return root !== undefined ? root.size : 0;\n  }\n\n  off(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  removeListener(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  on(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  addListener(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n  emit(type\x2C arg) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    validateString(type\x2C 'type');\n    const hadListeners = this.listenerCount(type) > 0;\n    this[kHybridDispatch](arg\x2C type);\n    return hadListeners;\n  }\n\n  once(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C\n                          { once: true\x2C [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  removeAllListeners(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    if (type !== undefined) {\n      this[kEvents].delete(String(type));\n    } else {\n      this[kEvents].clear();\n    }\n\n    return this;\n  }\n}\n\nObjectDefineProperties(NodeEventTarget.prototype\x2C {\n  setMaxListeners: kEnumerableProperty\x2C\n  getMaxListeners: kEnumerableProperty\x2C\n  eventNames: kEnumerableProperty\x2C\n  listenerCount: kEnumerableProperty\x2C\n  off: kEnumerableProperty\x2C\n  removeListener: kEnumerableProperty\x2C\n  on: kEnumerableProperty\x2C\n  addListener: kEnumerableProperty\x2C\n  once: kEnumerableProperty\x2C\n  emit: kEnumerableProperty\x2C\n  removeAllListeners: kEnumerableProperty\x2C\n});\n\n// EventTarget API\n\nfunction shouldAddListener(listener) {\n  if (typeof listener === 'function' ||\n      typeof listener?.handleEvent === 'function') {\n    return true;\n  }\n\n  if (listener == null)\n    return false;\n\n  throw new ERR_INVALID_ARG_TYPE('listener'\x2C 'EventListener'\x2C listener);\n}\n\nfunction validateEventListenerOptions(options) {\n  if (typeof options === 'boolean')\n    return { capture: options };\n\n  if (options === null)\n    return {};\n  validateObject(options\x2C 'options'\x2C {\n    allowArray: true\x2C allowFunction: true\x2C\n  });\n  return {\n    once: Boolean(options.once)\x2C\n    capture: Boolean(options.capture)\x2C\n    passive: Boolean(options.passive)\x2C\n    signal: options.signal\x2C\n    weak: options[kWeakHandler]\x2C\n    isNodeStyleListener: Boolean(options[kIsNodeStyleListener])\n  };\n}\n\n// Test whether the argument is an event object. This is far from a fool-proof\n// test\x2C for example this input will result in a false positive:\n// > isEventTarget({ constructor: EventTarget })\n// It stands in its current implementation as a compromise.\n// Ref: https://github.com/nodejs/node/pull/33661\nfunction isEventTarget(obj) {\n  return obj?.constructor?.[kIsEventTarget];\n}\n\nfunction isNodeEventTarget(obj) {\n  return obj?.constructor?.[kIsNodeEventTarget];\n}\n\nfunction addCatch(promise) {\n  const then = promise.then;\n  if (typeof then === 'function') {\n    FunctionPrototypeCall(then\x2C promise\x2C undefined\x2C function(err) {\n      // The callback is called with nextTick to avoid a follow-up\n      // rejection from this promise.\n      emitUncaughtException(err);\n    });\n  }\n}\n\nfunction emitUncaughtException(err) {\n  process.nextTick(() => { throw err; });\n}\n\nfunction makeEventHandler(handler) {\n  // Event handlers are dispatched in the order they were first set\n  // See https://github.com/nodejs/node/pull/35949#issuecomment-722496598\n  function eventHandler(...args) {\n    if (typeof eventHandler.handler !== 'function') {\n      return;\n    }\n    return ReflectApply(eventHandler.handler\x2C this\x2C args);\n  }\n  eventHandler.handler = handler;\n  return eventHandler;\n}\n\nfunction defineEventHandler(emitter\x2C name) {\n  // 8.1.5.1 Event handlers - basically `on[eventName]` attributes\n  ObjectDefineProperty(emitter\x2C `on${name}`\x2C {\n    get() {\n      return this[kHandlers]?.get(name)?.handler;\n    }\x2C\n    set(value) {\n      if (!this[kHandlers]) {\n        this[kHandlers] = new SafeMap();\n      }\n      let wrappedHandler = this[kHandlers]?.get(name);\n      if (wrappedHandler) {\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size--;\n          const size = this[kEvents].get(name).size;\n          this[kRemoveListener](size\x2C name\x2C wrappedHandler.handler\x2C false);\n        }\n        wrappedHandler.handler = value;\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size++;\n          const size = this[kEvents].get(name).size;\n          this[kNewListener](size\x2C name\x2C value\x2C false\x2C false\x2C false);\n        }\n      } else {\n        wrappedHandler = makeEventHandler(value);\n        this.addEventListener(name\x2C wrappedHandler);\n      }\n      this[kHandlers].set(name\x2C wrappedHandler);\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\n  });\n}\n\nconst EventEmitterMixin = (Superclass) => {\n  class MixedEventEmitter extends Superclass {\n    constructor(...args) {\n      args = new SafeArrayIterator(args);\n      super(...args);\n      FunctionPrototypeCall(EventEmitter\x2C this);\n    }\n  }\n  const protoProps = ObjectGetOwnPropertyDescriptors(EventEmitter.prototype);\n  delete protoProps.constructor;\n  ObjectDefineProperties(MixedEventEmitter.prototype\x2C protoProps);\n  return MixedEventEmitter;\n};\n\nmodule.exports = {\n  Event\x2C\n  EventEmitterMixin\x2C\n  EventTarget\x2C\n  NodeEventTarget\x2C\n  defineEventHandler\x2C\n  initEventTarget\x2C\n  initNodeEventTarget\x2C\n  kCreateEvent\x2C\n  kNewListener\x2C\n  kTrustEvent\x2C\n  kRemoveListener\x2C\n  kEvents\x2C\n  kWeakHandler\x2C\n  isEventTarget\x2C\n};\n
code-source-info,0x24b3764242b6,38,23423,23845,C0O23475C23O23659C30O23691C33O23704C38O23659C43O23718C47O23751C52O23792C57O23751C62O23818C64O23843,,
tick,0x7fff203572be,101881,0,0x0,3,0x10c825337,0x24b3269784ab,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
tick,0x10c74d583,102106,0,0x0,0,0x10c61b0d2,0x24b32697861d,0x24b357dbe2b5,0x24b357dbd585,0x24b326974202,0x24b357dbe2b5,0x24b357dbd585,0x24b326973aea,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Eval,10,102666,0x24b3764269f6,5, node:internal/modules/esm/translators:1:1,0x24b376426540,~
script-source,117,node:internal/modules/esm/translators,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  Boolean\x2C\n  JSONParse\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectKeys\x2C\n  PromisePrototypeThen\x2C\n  PromiseReject\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  SyntaxErrorPrototype\x2C\n  globalThis: { WebAssembly }\x2C\n} = primordials;\n\nlet _TYPES = null;\nfunction lazyTypes() {\n  if (_TYPES !== null) return _TYPES;\n  return _TYPES = require('internal/util/types');\n}\n\nconst { readFileSync } = require('fs');\nconst { extname\x2C isAbsolute } = require('path');\nconst {\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst {\n  Module: CJSModule\x2C\n  cjsParseCache\n} = require('internal/modules/cjs/loader');\nconst internalURLModule = require('internal/url');\nconst createDynamicModule = require(\n  'internal/modules/esm/create_dynamic_module');\nconst { fileURLToPath\x2C URL } = require('url');\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { emitExperimentalWarning } = require('internal/util');\nconst {\n  ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\n} = require('internal/errors').codes;\nconst { maybeCacheSourceMap } = require('internal/source_map/source_map_cache');\nconst moduleWrap = internalBinding('module_wrap');\nconst { ModuleWrap } = moduleWrap;\nconst { getOptionValue } = require('internal/options');\nconst experimentalImportMetaResolve =\n    getOptionValue('--experimental-import-meta-resolve');\nconst asyncESM = require('internal/process/esm_loader');\nconst { emitWarningSync } = require('internal/process/warning');\nconst { TextDecoder } = require('internal/encoding');\n\nlet cjsParse;\nasync function initCJSParse() {\n  if (typeof WebAssembly === 'undefined') {\n    cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\n  } else {\n    const { parse\x2C init } =\n        require('internal/deps/cjs-module-lexer/dist/lexer');\n    await init();\n    cjsParse = parse;\n  }\n}\n\nconst translators = new SafeMap();\nexports.translators = translators;\nexports.enrichCJSError = enrichCJSError;\n\nlet DECODER = null;\nfunction assertBufferSource(body\x2C allowString\x2C hookName) {\n  if (allowString && typeof body === 'string') {\n    return;\n  }\n  const { isArrayBufferView\x2C isAnyArrayBuffer } = lazyTypes();\n  if (isArrayBufferView(body) || isAnyArrayBuffer(body)) {\n    return;\n  }\n  throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n    `${allowString ? 'string\x2C ' : ''}array buffer\x2C or typed array`\x2C\n    hookName\x2C\n    'source'\x2C\n    body\n  );\n}\n\nfunction stringify(body) {\n  if (typeof body === 'string') return body;\n  assertBufferSource(body\x2C false\x2C 'transformSource');\n  DECODER = DECODER === null ? new TextDecoder() : DECODER;\n  return DECODER.decode(body);\n}\n\nfunction errPath(url) {\n  const parsed = new URL(url);\n  if (parsed.protocol === 'file:') {\n    return fileURLToPath(parsed);\n  }\n  return url;\n}\n\nasync function importModuleDynamically(specifier\x2C { url }) {\n  return asyncESM.esmLoader.import(specifier\x2C url);\n}\n\nfunction createImportMetaResolve(defaultParentUrl) {\n  return async function resolve(specifier\x2C parentUrl = defaultParentUrl) {\n    return PromisePrototypeThen(\n      asyncESM.esmLoader.resolve(specifier\x2C parentUrl)\x2C\n      ({ url }) => url\x2C\n      (error) => (\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT' ?\n          error.url : PromiseReject(error))\n    );\n  };\n}\n\nfunction initializeImportMeta(meta\x2C { url }) {\n  // Alphabetical\n  if (experimentalImportMetaResolve)\n    meta.resolve = createImportMetaResolve(url);\n  meta.url = url;\n}\n\n// Strategy for loading a standard JavaScript module.\ntranslators.set('module'\x2C async function moduleStrategy(url\x2C source\x2C isMain) {\n  assertBufferSource(source\x2C true\x2C 'load');\n  source = stringify(source);\n  maybeCacheSourceMap(url\x2C source);\n  debug(`Translating StandardModule ${url}`);\n  const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n  moduleWrap.callbackMap.set(module\x2C {\n    initializeImportMeta\x2C\n    importModuleDynamically\x2C\n  });\n  return module;\n});\n\n/**\n * @param {Error | any} err\n * @param {string} [content] Content of the file\x2C if known.\n * @param {string} [filename] Useful only if `content` is unknown.\n */\nfunction enrichCJSError(err\x2C content\x2C filename) {\n  if (err != null && ObjectGetPrototypeOf(err) === SyntaxErrorPrototype &&\n      hasEsmSyntax(content || readFileSync(filename\x2C 'utf-8'))) {\n    // Emit the warning synchronously because we are in the middle of handling\n    // a SyntaxError that will throw and likely terminate the process before an\n    // asynchronous warning would be emitted.\n    emitWarningSync(\n      'To load an ES module\x2C set "type": "module" in the package.json or use ' +\n      'the .mjs extension.'\n    );\n  }\n}\n\n// Strategy for loading a node-style CommonJS module\nconst isWindows = process.platform === 'win32';\nconst winSepRegEx = /\\//g;\ntranslators.set('commonjs'\x2C async function commonjsStrategy(url\x2C source\x2C\n                                                            isMain) {\n  debug(`Translating CJSModule ${url}`);\n\n  let filename = internalURLModule.fileURLToPath(new URL(url));\n  if (isWindows)\n    filename = StringPrototypeReplace(filename\x2C winSepRegEx\x2C '\\\\');\n\n  if (!cjsParse) await initCJSParse();\n  const { module\x2C exportNames } = cjsPreparseModuleExports(filename);\n  const namesWithDefault = exportNames.has('default') ?\n    [...exportNames] : ['default'\x2C ...exportNames];\n\n  return new ModuleWrap(url\x2C undefined\x2C namesWithDefault\x2C function() {\n    debug(`Loading CJSModule ${url}`);\n\n    let exports;\n    if (asyncESM.esmLoader.cjsCache.has(module)) {\n      exports = asyncESM.esmLoader.cjsCache.get(module);\n      asyncESM.esmLoader.cjsCache.delete(module);\n    } else {\n      try {\n        exports = CJSModule._load(filename\x2C undefined\x2C isMain);\n      } catch (err) {\n        enrichCJSError(err\x2C undefined\x2C filename);\n        throw err;\n      }\n    }\n\n    for (const exportName of exportNames) {\n      if (!ObjectPrototypeHasOwnProperty(exports\x2C exportName) ||\n          exportName === 'default')\n        continue;\n      // We might trigger a getter -> dont fail.\n      let value;\n      try {\n        value = exports[exportName];\n      } catch {}\n      this.setExport(exportName\x2C value);\n    }\n    this.setExport('default'\x2C exports);\n  });\n});\n\nfunction cjsPreparseModuleExports(filename) {\n  let module = CJSModule._cache[filename];\n  if (module) {\n    const cached = cjsParseCache.get(module);\n    if (cached)\n      return { module\x2C exportNames: cached.exportNames };\n  }\n  const loaded = Boolean(module);\n  if (!loaded) {\n    module = new CJSModule(filename);\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n    CJSModule._cache[filename] = module;\n  }\n\n  let source;\n  try {\n    source = readFileSync(filename\x2C 'utf8');\n  } catch {}\n\n  let exports\x2C reexports;\n  try {\n    ({ exports\x2C reexports } = cjsParse(source || ''));\n  } catch {\n    exports = [];\n    reexports = [];\n  }\n\n  const exportNames = new SafeSet(new SafeArrayIterator(exports));\n\n  // Set first for cycles.\n  cjsParseCache.set(module\x2C { source\x2C exportNames\x2C loaded });\n\n  if (reexports.length) {\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n  }\n  ArrayPrototypeForEach(reexports\x2C (reexport) => {\n    let resolved;\n    try {\n      resolved = CJSModule._resolveFilename(reexport\x2C module);\n    } catch {\n      return;\n    }\n    const ext = extname(resolved);\n    if ((ext === '.js' || ext === '.cjs' || !CJSModule._extensions[ext]) &&\n        isAbsolute(resolved)) {\n      const { exportNames: reexportNames } = cjsPreparseModuleExports(resolved);\n      for (const name of reexportNames)\n        exportNames.add(name);\n    }\n  });\n\n  return { module\x2C exportNames };\n}\n\n// Strategy for loading a node builtin CommonJS module that isn't\n// through normal resolution\ntranslators.set('builtin'\x2C async function builtinStrategy(url) {\n  debug(`Translating BuiltinModule ${url}`);\n  // Slice 'node:' scheme\n  const id = StringPrototypeSlice(url\x2C 5);\n  const module = loadNativeModule(id\x2C url);\n  if (!StringPrototypeStartsWith(url\x2C 'node:') || !module) {\n    throw new ERR_UNKNOWN_BUILTIN_MODULE(url);\n  }\n  debug(`Loading BuiltinModule ${url}`);\n  return module.getESMFacade();\n});\n\n// Strategy for loading a JSON file\ntranslators.set('json'\x2C async function jsonStrategy(url\x2C source) {\n  emitExperimentalWarning('Importing JSON modules');\n  assertBufferSource(source\x2C true\x2C 'load');\n  debug(`Loading JSONModule ${url}`);\n  const pathname = StringPrototypeStartsWith(url\x2C 'file:') ?\n    fileURLToPath(url) : null;\n  let modulePath;\n  let module;\n  if (pathname) {\n    modulePath = isWindows ?\n      StringPrototypeReplace(pathname\x2C winSepRegEx\x2C '\\\\') : pathname;\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  source = stringify(source);\n  if (pathname) {\n    // A require call could have been called on the same file during loading and\n    // that resolves synchronously. To make sure we always return the identical\n    // export\x2C we have to check again if the module already exists or not.\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  try {\n    const exports = JSONParse(stripBOM(source));\n    module = {\n      exports\x2C\n      loaded: true\n    };\n  } catch (err) {\n    // TODO (BridgeAR): We could add a NodeCore error that wraps the JSON\n    // parse error instead of just manipulating the original error message.\n    // That would allow to add further properties and maybe additional\n    // debugging information.\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n  if (pathname) {\n    CJSModule._cache[modulePath] = module;\n  }\n  return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n    debug(`Parsing JSONModule ${url}`);\n    this.setExport('default'\x2C module.exports);\n  });\n});\n\n// Strategy for loading a wasm module\ntranslators.set('wasm'\x2C async function(url\x2C source) {\n  emitExperimentalWarning('Importing Web Assembly modules');\n\n  assertBufferSource(source\x2C false\x2C 'load');\n\n  debug(`Translating WASMModule ${url}`);\n\n  let compiled;\n  try {\n    compiled = await WebAssembly.compile(source);\n  } catch (err) {\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n\n  const imports =\n      ArrayPrototypeMap(WebAssembly.Module.imports(compiled)\x2C\n                        ({ module }) => module);\n  const exports =\n    ArrayPrototypeMap(WebAssembly.Module.exports(compiled)\x2C\n                      ({ name }) => name);\n\n  return createDynamicModule(imports\x2C exports\x2C url\x2C (reflect) => {\n    const { exports } = new WebAssembly.Instance(compiled\x2C reflect.imports);\n    for (const expt of ObjectKeys(exports))\n      reflect.exports[expt].set(exports[expt]);\n  }).module;\n});\n
code-source-info,0x24b3764269f6,117,0,11226,C0O0C4O11226,,
code-creation,Function,10,103607,0x24b376427296,773, node:internal/modules/esm/translators:1:1,0x24b376426970,~
code-source-info,0x24b376427296,117,0,11226,C0O0C201O25C207O50C213O71C219O82C225O95C231O119C237O152C243O166C249O190C255O207C261O228C266O239C272O250C278O276C284O300C290O329C301O367C307O413C308O413C310O558C316O558C321O541C327O605C333O605C338O581C344O590C350O682C356O682C361O632C367O648C373O668C379O772C385O772C390O741C396O754C402O838C408O838C412O838C414O891C420O891C424O891C426O980C432O980C437O957C443O972C449O1008C455O1008C460O1041C473O1042C479O1008C481O1122C487O1122C492O1094C498O1226C504O1226C509O1252C514O1158C520O1188C526O1292C532O1292C537O1268C543O1360C546O1360C550O1360C552O1415C555O1400C561O1454C567O1454C572O1435C577O1525C580O1525C584O1525C586O1596C592O1596C596O1596C598O1664C604O1664C609O1644C615O1725C621O1725C626O1709C632O1760C633O1760C635O2084C637O2084C643O2099C645O2119C649O2134C651O2157C655O2190C656O2190C658O3712C671O3712C677O4902C684O4911C687O4894C689O4944C693O4944C695O4963C708O4963C714O7967C727O7967C733O8416C746O8416C752O10364C765O10364C772O11225,,
tick,0x10c265599,103730,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b326973af8,0x24b357dbe2b5,0x24b357dbd585,0x24b32696945c,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b64,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Eval,10,103936,0x24b3764288ae,5, node:internal/modules/esm/create_dynamic_module:1:1,0x24b3764286d8,~
script-source,118,node:internal/modules/esm/create_dynamic_module,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  JSONStringify\x2C\n  ObjectCreate\x2C\n  SafeSet\x2C\n} = primordials;\n\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\n\nfunction createImport(impt\x2C index) {\n  const imptPath = JSONStringify(impt);\n  return `import * as $import_${index} from ${imptPath};\nimport.meta.imports[${imptPath}] = $import_${index};`;\n}\n\nfunction createExport(expt) {\n  const name = `${expt}`;\n  return `let $${name};\nexport { $${name} as ${name} };\nimport.meta.exports.${name} = {\n  get: () => $${name}\x2C\n  set: (v) => $${name} = v\x2C\n};`;\n}\n\nconst createDynamicModule = (imports\x2C exports\x2C url = ''\x2C evaluate) => {\n  debug('creating ESM facade for %s with exports: %j'\x2C url\x2C exports);\n  const source = `\n${ArrayPrototypeJoin(ArrayPrototypeMap(imports\x2C createImport)\x2C '\\n')}\n${ArrayPrototypeJoin(ArrayPrototypeMap(exports\x2C createExport)\x2C '\\n')}\nimport.meta.done();\n`;\n  const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n  const m = new ModuleWrap(`${url}`\x2C undefined\x2C source\x2C 0\x2C 0);\n\n  const readyfns = new SafeSet();\n  const reflect = {\n    exports: ObjectCreate(null)\x2C\n    onReady: (cb) => { readyfns.add(cb); }\x2C\n  };\n\n  if (imports.length)\n    reflect.imports = ObjectCreate(null);\n\n  callbackMap.set(m\x2C {\n    initializeImportMeta: (meta\x2C wrap) => {\n      meta.exports = reflect.exports;\n      if (reflect.imports)\n        meta.imports = reflect.imports;\n      meta.done = () => {\n        evaluate(reflect);\n        reflect.onReady = (cb) => cb(reflect);\n        for (const fn of readyfns) {\n          readyfns.delete(fn);\n          fn(reflect);\n        }\n      };\n    }\x2C\n  });\n\n  return {\n    module: m\x2C\n    reflect\x2C\n  };\n};\n\nmodule.exports = createDynamicModule;\n
code-source-info,0x24b3764288ae,118,0,1756,C0O0C4O1756,,
code-creation,Function,10,104101,0x24b376428ad6,111, node:internal/modules/esm/create_dynamic_module:1:1,0x24b376428828,~
code-source-info,0x24b376428ad6,118,0,1756,C0O0C39O25C45O47C51O68C57O85C63O101C69O140C72O140C77O173C90O174C96O140C98O642C103O1718C105O1733C110O1755,,
tick,0x10cc9116c,104644,1,0x10c345dc2,3,0x10c4a5769,0x24b357dbe294,0x24b357dbd585,0x24b326967b97,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,Eval,10,104698,0x24b376429aae,5, node:internal/vm/module:1:1,0x24b376429568,~
script-source,119,node:internal/vm/module,'use strict';\n\nconst assert = require('internal/assert');\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeSome\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  ReflectApply\x2C\n  SafeWeakMap\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n  TypeError\x2C\n} = primordials;\n\nconst { isContext } = internalBinding('contextify');\nconst {\n  isModuleNamespaceObject\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst {\n  getConstructorOf\x2C\n  customInspectSymbol\x2C\n  emitExperimentalWarning\x2C\n} = require('internal/util');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_VM_MODULE_ALREADY_LINKED\x2C\n  ERR_VM_MODULE_DIFFERENT_CONTEXT\x2C\n  ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA\x2C\n  ERR_VM_MODULE_LINKING_ERRORED\x2C\n  ERR_VM_MODULE_NOT_MODULE\x2C\n  ERR_VM_MODULE_STATUS\x2C\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateUint32\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst binding = internalBinding('module_wrap');\nconst {\n  ModuleWrap\x2C\n  kUninstantiated\x2C\n  kInstantiating\x2C\n  kInstantiated\x2C\n  kEvaluating\x2C\n  kEvaluated\x2C\n  kErrored\x2C\n} = binding;\n\nconst STATUS_MAP = {\n  [kUninstantiated]: 'unlinked'\x2C\n  [kInstantiating]: 'linking'\x2C\n  [kInstantiated]: 'linked'\x2C\n  [kEvaluating]: 'evaluating'\x2C\n  [kEvaluated]: 'evaluated'\x2C\n  [kErrored]: 'errored'\x2C\n};\n\nlet globalModuleId = 0;\nconst defaultModuleName = 'vm:module';\nconst wrapToModuleMap = new SafeWeakMap();\n\nconst kWrap = Symbol('kWrap');\nconst kContext = Symbol('kContext');\nconst kPerContextModuleId = Symbol('kPerContextModuleId');\nconst kLink = Symbol('kLink');\n\nclass Module {\n  constructor(options) {\n    emitExperimentalWarning('VM Modules');\n\n    if (new.target === Module) {\n      // eslint-disable-next-line no-restricted-syntax\n      throw new TypeError('Module is not a constructor');\n    }\n\n    const {\n      context\x2C\n      sourceText\x2C\n      syntheticExportNames\x2C\n      syntheticEvaluationSteps\x2C\n    } = options;\n\n    if (context !== undefined) {\n      validateObject(context\x2C 'context');\n      if (!isContext(context)) {\n        throw new ERR_INVALID_ARG_TYPE('options.context'\x2C 'vm.Context'\x2C\n                                       context);\n      }\n    }\n\n    let { identifier } = options;\n    if (identifier !== undefined) {\n      validateString(identifier\x2C 'options.identifier');\n    } else if (context === undefined) {\n      identifier = `${defaultModuleName}(${globalModuleId++})`;\n    } else if (context[kPerContextModuleId] !== undefined) {\n      const curId = context[kPerContextModuleId];\n      identifier = `${defaultModuleName}(${curId})`;\n      context[kPerContextModuleId] += 1;\n    } else {\n      identifier = `${defaultModuleName}(0)`;\n      ObjectDefineProperty(context\x2C kPerContextModuleId\x2C {\n        value: 1\x2C\n        writable: true\x2C\n        enumerable: false\x2C\n        configurable: true\x2C\n      });\n    }\n\n    if (sourceText !== undefined) {\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C sourceText\x2C\n                                   options.lineOffset\x2C options.columnOffset\x2C\n                                   options.cachedData);\n\n      binding.callbackMap.set(this[kWrap]\x2C {\n        initializeImportMeta: options.initializeImportMeta\x2C\n        importModuleDynamically: options.importModuleDynamically ?\n          importModuleDynamicallyWrap(options.importModuleDynamically) :\n          undefined\x2C\n      });\n    } else {\n      assert(syntheticEvaluationSteps);\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C\n                                   syntheticExportNames\x2C\n                                   syntheticEvaluationSteps);\n    }\n\n    wrapToModuleMap.set(this[kWrap]\x2C this);\n\n    this[kContext] = context;\n  }\n\n  get identifier() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kWrap].url;\n  }\n\n  get context() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kContext];\n  }\n\n  get namespace() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must not be unlinked or linking');\n    }\n    return this[kWrap].getNamespace();\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return STATUS_MAP[this[kWrap].getStatus()];\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS('must be errored');\n    }\n    return this[kWrap].getError();\n  }\n\n  async link(linker) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateFunction(linker\x2C 'linker');\n    if (this.status === 'linked') {\n      throw new ERR_VM_MODULE_ALREADY_LINKED();\n    }\n    if (this.status !== 'unlinked') {\n      throw new ERR_VM_MODULE_STATUS('must be unlinked');\n    }\n    await this[kLink](linker);\n    this[kWrap].instantiate();\n  }\n\n  async evaluate(options = {}) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n\n    validateObject(options\x2C 'options');\n\n    let timeout = options.timeout;\n    if (timeout === undefined) {\n      timeout = -1;\n    } else {\n      validateUint32(timeout\x2C 'options.timeout'\x2C true);\n    }\n    const { breakOnSigint = false } = options;\n    validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\n    const status = this[kWrap].getStatus();\n    if (status !== kInstantiated &&\n        status !== kEvaluated &&\n        status !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS(\n        'must be one of linked\x2C evaluated\x2C or errored'\n      );\n    }\n    await this[kWrap].evaluate(timeout\x2C breakOnSigint);\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || Module;\n    const o = ObjectCreate({ constructor });\n    o.status = this.status;\n    o.identifier = this.identifier;\n    o.context = this.context;\n\n    ObjectSetPrototypeOf(o\x2C ObjectGetPrototypeOf(this));\n    ObjectDefineProperty(o\x2C SymbolToStringTag\x2C {\n      value: constructor.name\x2C\n      configurable: true\n    });\n\n    // Lazy to avoid circular dependency\n    const { inspect } = require('internal/util/inspect');\n    return inspect(o\x2C { ...options\x2C customInspect: false });\n  }\n}\n\nconst kDependencySpecifiers = Symbol('kDependencySpecifiers');\nconst kNoError = Symbol('kNoError');\n\nclass SourceTextModule extends Module {\n  #error = kNoError;\n  #statusOverride;\n\n  constructor(sourceText\x2C options = {}) {\n    validateString(sourceText\x2C 'sourceText');\n    validateObject(options\x2C 'options');\n\n    const {\n      lineOffset = 0\x2C\n      columnOffset = 0\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n      context\x2C\n      identifier\x2C\n      cachedData\x2C\n    } = options;\n\n    validateInt32(lineOffset\x2C 'options.lineOffset');\n    validateInt32(columnOffset\x2C 'options.columnOffset');\n\n    if (initializeImportMeta !== undefined &&\n        typeof initializeImportMeta !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.initializeImportMeta'\x2C 'function'\x2C initializeImportMeta);\n    }\n\n    if (importModuleDynamically !== undefined &&\n        typeof importModuleDynamically !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.importModuleDynamically'\x2C 'function'\x2C\n        importModuleDynamically);\n    }\n\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.cachedData'\x2C\n        ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n        cachedData\n      );\n    }\n\n    super({\n      sourceText\x2C\n      context\x2C\n      identifier\x2C\n      lineOffset\x2C\n      columnOffset\x2C\n      cachedData\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n    });\n\n    this[kLink] = async (linker) => {\n      this.#statusOverride = 'linking';\n\n      const promises = this[kWrap].link(async (identifier\x2C assert) => {\n        const module = await linker(identifier\x2C this\x2C { assert });\n        if (module[kWrap] === undefined) {\n          throw new ERR_VM_MODULE_NOT_MODULE();\n        }\n        if (module.context !== this.context) {\n          throw new ERR_VM_MODULE_DIFFERENT_CONTEXT();\n        }\n        if (module.status === 'errored') {\n          // TODO(devsnek): replace with ERR_VM_MODULE_LINK_FAILURE\n          // and error cause proposal.\n          throw new ERR_VM_MODULE_LINKING_ERRORED();\n        }\n        if (module.status === 'unlinked') {\n          await module[kLink](linker);\n        }\n        return module[kWrap];\n      });\n\n      try {\n        if (promises !== undefined) {\n          await PromiseAll(promises);\n        }\n      } catch (e) {\n        this.#error = e;\n        throw e;\n      } finally {\n        this.#statusOverride = undefined;\n      }\n    };\n\n    this[kDependencySpecifiers] = undefined;\n  }\n\n  get dependencySpecifiers() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kDependencySpecifiers] === undefined) {\n      this[kDependencySpecifiers] = this[kWrap].getStaticDependencySpecifiers();\n    }\n    return this[kDependencySpecifiers];\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return 'errored';\n    }\n    if (this.#statusOverride) {\n      return this.#statusOverride;\n    }\n    return super.status;\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return this.#error;\n    }\n    return super.error;\n  }\n\n  createCachedData() {\n    const { status } = this;\n    if (status === 'evaluating' ||\n        status === 'evaluated' ||\n        status === 'errored') {\n      throw new ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA();\n    }\n    return this[kWrap].createCachedData();\n  }\n}\n\nclass SyntheticModule extends Module {\n  constructor(exportNames\x2C evaluateCallback\x2C options = {}) {\n    if (!ArrayIsArray(exportNames) ||\n      ArrayPrototypeSome(exportNames\x2C (e) => typeof e !== 'string')) {\n      throw new ERR_INVALID_ARG_TYPE('exportNames'\x2C\n                                     'Array of unique strings'\x2C\n                                     exportNames);\n    } else {\n      ArrayPrototypeForEach(exportNames\x2C (name\x2C i) => {\n        if (ArrayPrototypeIndexOf(exportNames\x2C name\x2C i + 1) !== -1) {\n          throw new ERR_INVALID_ARG_VALUE(`exportNames.${name}`\x2C\n                                          name\x2C\n                                          'is duplicated');\n        }\n      });\n    }\n    validateFunction(evaluateCallback\x2C 'evaluateCallback');\n\n    validateObject(options\x2C 'options');\n\n    const { context\x2C identifier } = options;\n\n    super({\n      syntheticExportNames: exportNames\x2C\n      syntheticEvaluationSteps: evaluateCallback\x2C\n      context\x2C\n      identifier\x2C\n    });\n\n    this[kLink] = () => this[kWrap].link(() => {\n      assert.fail('link callback should not be called');\n    });\n  }\n\n  setExport(name\x2C value) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateString(name\x2C 'name');\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must be linked');\n    }\n    this[kWrap].setExport(name\x2C value);\n  }\n}\n\nfunction importModuleDynamicallyWrap(importModuleDynamically) {\n  const importModuleDynamicallyWrapper = async (...args) => {\n    const m = await ReflectApply(importModuleDynamically\x2C this\x2C args);\n    if (isModuleNamespaceObject(m)) {\n      return m;\n    }\n    if (!m || m[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (m.status === 'errored') {\n      throw m.error;\n    }\n    return m.namespace;\n  };\n  return importModuleDynamicallyWrapper;\n}\n\nmodule.exports = {\n  Module\x2C\n  SourceTextModule\x2C\n  SyntheticModule\x2C\n  importModuleDynamicallyWrap\x2C\n  getModuleFromWrap: (wrap) => wrapToModuleMap.get(wrap)\x2C\n};\n
code-source-info,0x24b376429aae,119,0,12310,C0O0C4O12310,,
code-creation,Function,10,105626,0x24b37642ad0e,872, node:internal/vm/module:1:1,0x24b376429a28,~
code-source-info,0x24b37642ad0e,119,0,12310,C0O0C156O30C162O30C166O30C168O68C174O84C180O109C186O134C192O156C198O172C204O196C210O220C216O244C222O258C228O274C233O289C238O299C244O320C250O371C253O371C258O357C264O462C270O462C275O412C281O439C287O576C293O576C298O504C304O524C309O547C315O858C321O858C326O884C331O612C337O636C343O661C349O693C355O728C361O771C367O804C373O832C379O1014C385O1014C390O902C396O921C402O941C408O958C414O976C420O994C426O1063C429O1063C433O1063C435O1216C438O1105C444O1119C449O1138C454O1156C460O1173C465O1188C471O1202C477O1245C484O1250C488O1268C495O1283C499O1300C506O1314C510O1330C517O1343C521O1357C528O1374C532O1387C539O1403C543O1414C550O1245C552O1450C553O1450C555O1479C557O1479C559O1516C561O1516C566O1516C568O1550C571O1550C575O1550C577O1584C580O1584C584O1584C586O1632C589O1632C593O1632C595O1677C598O1677C602O1677C660O5923C688O6683C691O6683C695O6683C697O6733C700O6733C704O6733C736O6785C799O10265C827O12150C834O12171C840O12181C846O12201C852O12220C856O12270C866O12165C871O12309,,
code-creation,Function,10,105699,0x24b37642b24e,30,<instance_members_initializer> node:internal/vm/module:256:3,0x24b37642a098,~
code-source-info,0x24b37642b24e,119,6796,6832,C3O6805C29O6832,,
tick,0x10c1e8142,105953,0,0x0,0,0x24b357dbd55b,0x24b37642adb0,0x24b357dbe2b5,0x24b357dbd585,0x24b326967b97,0x24b357dbe2b5,0x24b357dbd585,0x24b3269633c1,0x24b357dbe2b5,0x24b357dbd585,0x24b32695f1bc,0x24b3269439f2,0x24b357dbd30d
code-creation,LazyCompile,10,106115,0x24b37642c6be,16,ESMLoader node:internal/modules/esm/loader:52:1,0x24b326968bf0,~
code-source-info,0x24b37642c6be,103,1392,1392,C0O1392C15O1392,,
code-creation,LazyCompile,10,106212,0x24b37642d656,27,ModuleMap node:internal/modules/esm/module_map:15:14,0x24b32696ab48,~
code-source-info,0x24b37642d656,104,430,447,C3O436C7O442C11O436C26O446,,
code-creation,LazyCompile,10,106283,0x24b37642d8b6,13,desc.value node:internal/per_context/primordials:325:32,0x24b3c0589da0,~
code-source-info,0x24b37642d8b6,6,9496,9555,C0O9513C7O9520C12O9543,,
code-creation,LazyCompile,10,106326,0x24b37642d9be,13,SafeIterator node:internal/per_context/primordials:270:16,0x24b3c05897f0,~
code-source-info,0x24b37642d9be,6,7785,7845,C0O7804C3O7821C7O7819C12O7844,,
code-creation,LazyCompile,10,106373,0x24b37642daf6,13,next node:internal/per_context/primordials:273:9,0x24b3c05898b8,~
code-source-info,0x24b37642daf6,6,7854,7899,C0O7865C3O7882C8O7872C12O7893,,
code-creation,Function,11,106444,0x114304180,108,next node:internal/per_context/primordials:273:9,0x24b3c05898b8,^
code-source-info,0x114304180,6,7854,7899,,,
code-creation,Function,11,106480,0x114304280,684,nativeModuleRequire node:internal/bootstrap/loaders:332:29,0x24b3c058f908,^
code-source-info,0x114304280,9,10315,10658,,,
code-creation,Function,11,106511,0x1143045c0,1300,compileForInternalLoader node:internal/bootstrap/loaders:299:27,0x24b3c058f838,^
code-source-info,0x1143045c0,9,9528,10089,,,
code-creation,Function,11,106585,0x114304b80,444,getCLIOptionsFromBinding node:internal/options:18:34,0x24b326942870,^
code-source-info,0x114304b80,94,497,598,,,
code-creation,Function,11,106606,0x114304dc0,180,isBrandCheck node:internal/webstreams/util:112:22,0x24b376415c98,^
code-source-info,0x114304dc0,114,2398,2541,,,
code-creation,Function,11,106635,0x114304f00,576,internalBinding node:internal/bootstrap/loaders:164:45,0x24b3c058f388,^
code-source-info,0x114304f00,9,5115,5353,,,
code-creation,LazyCompile,10,106854,0x24b37642dffe,152,deprecate node:internal/util:96:19,0x24b3c05aa0e8,~
code-source-info,0x24b37642dffe,12,2408,3584,C0O2408C26O2428C31O2440C37O2454C42O2470C44O2480C45O2535C53O2573C61O2595C66O2576C83O2631C87O2659C100O2659C105O2705C106O2705C108O3280C121O3280C126O3320C129O3327C135O3520C141O3546C145O3541C149O3564C151O3582,,
code-creation,LazyCompile,10,106962,0x24b37642e5de,28,getEmbedderOptions node:internal/options:32:28,0x24b326942910,~
code-source-info,0x24b37642e5de,94,760,877,C0O767C6O795C11O813C17O811C23O852C27O875,,
code-creation,LazyCompile,10,107116,0x24b37642e886,315,Module._initPaths node:internal/modules/cjs/loader:1221:29,0x24b3269623f8,~
code-source-info,0x24b37642e886,100,38121,39077,C0O38144C9O38164C14O38168C22O38182C28O38182C33O38221C42O38241C47O38245C55O38257C61O38257C66O38452C74O38468C77O38473C85O38489C93O38473C103O38511C106O38516C114O38532C125O38516C131O38572C140O38573C143O38578C157O38578C169O38617C173O38636C180O38665C183O38670C191O38670C198O38636C203O38712C210O38741C213O38746C221O38746C228O38712C233O38789C237O38809C244O38843C249O38871C254O38902C257O38907C262O38871C270O38925C273O38843C279O38809C284O38948C286O38960C292O39021C297O39042C302O39062C305O39042C309O39040C314O39076,,
tick,0x10c767762,107242,0,0x0,0,0x10c61a8b7,0x24b326949174,0x24b37642e903,0x24b32695f1da,0x24b3269439f2,0x24b357dbd30d
code-creation,Eval,10,107416,0x24b3764317e6,5, node:internal/modules/run_main:1:1,0x24b3764315e0,~
script-source,120,node:internal/modules/run_main,'use strict';\n\nconst {\n  StringPrototypeEndsWith\x2C\n} = primordials;\nconst CJSLoader = require('internal/modules/cjs/loader');\nconst { Module\x2C toRealPath\x2C readPackageScope } = CJSLoader;\nconst { getOptionValue } = require('internal/options');\nconst path = require('path');\n\nfunction resolveMainPath(main) {\n  // Note extension resolution for the main entry point can be deprecated in a\n  // future major.\n  // Module._findPath is monkey-patchable here.\n  let mainPath = Module._findPath(path.resolve(main)\x2C null\x2C true);\n  if (!mainPath)\n    return;\n\n  const preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n  if (!preserveSymlinksMain)\n    mainPath = toRealPath(mainPath);\n\n  return mainPath;\n}\n\nfunction shouldUseESMLoader(mainPath) {\n  const userLoader = getOptionValue('--experimental-loader');\n  if (userLoader)\n    return true;\n  const esModuleSpecifierResolution =\n    getOptionValue('--experimental-specifier-resolution');\n  if (esModuleSpecifierResolution === 'node')\n    return true;\n  // Determine the module format of the main\n  if (mainPath && StringPrototypeEndsWith(mainPath\x2C '.mjs'))\n    return true;\n  if (!mainPath || StringPrototypeEndsWith(mainPath\x2C '.cjs'))\n    return false;\n  const pkg = readPackageScope(mainPath);\n  return pkg && pkg.data.type === 'module';\n}\n\nfunction runMainESM(mainPath) {\n  const { loadESM } = require('internal/process/esm_loader');\n  const { pathToFileURL } = require('internal/url');\n\n  handleMainPromise(loadESM((esmLoader) => {\n    const main = path.isAbsolute(mainPath) ?\n      pathToFileURL(mainPath).href :\n      mainPath;\n    return esmLoader.import(main);\n  }));\n}\n\nasync function handleMainPromise(promise) {\n  // Handle a Promise from running code that potentially does Top-Level Await.\n  // In that case\x2C it makes sense to set the exit code to a specific non-zero\n  // value if the main code never finishes running.\n  function handler() {\n    if (process.exitCode === undefined)\n      process.exitCode = 13;\n  }\n  process.on('exit'\x2C handler);\n  try {\n    return await promise;\n  } finally {\n    process.off('exit'\x2C handler);\n  }\n}\n\n// For backwards compatibility\x2C we have to run a bunch of\n// monkey-patchable code that belongs to the CJS loader (exposed by\n// `require('module')`) even when the entry point is ESM.\nfunction executeUserEntryPoint(main = process.argv[1]) {\n  const resolvedMain = resolveMainPath(main);\n  const useESMLoader = shouldUseESMLoader(resolvedMain);\n  if (useESMLoader) {\n    runMainESM(resolvedMain || main);\n  } else {\n    // Module._load is the monkey-patchable CJS module loader.\n    Module._load(main\x2C null\x2C true);\n  }\n}\n\nmodule.exports = {\n  executeUserEntryPoint\x2C\n  handleMainPromise\x2C\n};\n
code-source-info,0x24b3764317e6,120,0,2695,C0O0C4O2695,,
code-creation,Function,10,107614,0x24b376431ade,149, node:internal/modules/run_main:1:1,0x24b376431760,~
code-source-info,0x24b376431ade,120,0,2695,C0O0C60O25C66O85C72O85C77O133C83O141C89O153C95O212C101O212C106O193C112O254C118O254C122O254C124O2627C131O2648C137O2673C143O2642C148O2694,,
code-creation,LazyCompile,10,107743,0x24b3764320c6,163,initializeESMLoader node:internal/bootstrap/pre_execution:431:29,0x24b357dbf820,~
code-source-info,0x24b3764320c6,93,13703,14791,C0O13785C6O13785C13O13834C16O13830C21O13828C25O13852C30O13856C34O13876C40O13905C41O13912C42O14012C48O14012C53O13928C58O13968C63O14058C69O14058C74O14259C79O14217C83O14329C88O14290C92O14495C100O14499C106O14615C112O14615C117O14564C122O14572C127O14590C132O14661C138O14661C143O14680C145O14690C149O14704C151O14724C155O14748C157O14767C162O14790,,
code-creation,LazyCompile,10,107812,0x24b3764322de,5,get hasLoadedAnyUserCJSModule node:internal/modules/cjs/loader:74:32,0x24b3269618e8,~
code-source-info,0x24b3764322de,100,2306,2346,C0O2311C4O2344,,
code-creation,LazyCompile,10,107849,0x24b376432386,21,assert node:internal/assert:11:16,0x24b3608977b8,~
script-source,16,node:internal/assert,'use strict';\n\nlet error;\nfunction lazyError() {\n  if (!error) {\n    error = require('internal/errors').codes.ERR_INTERNAL_ASSERTION;\n  }\n  return error;\n}\n\nfunction assert(value\x2C message) {\n  if (!value) {\n    const ERR_INTERNAL_ASSERTION = lazyError();\n    throw new ERR_INTERNAL_ASSERTION(message);\n  }\n}\n\nfunction fail(message) {\n  const ERR_INTERNAL_ASSERTION = lazyError();\n  throw new ERR_INTERNAL_ASSERTION(message);\n}\n\nassert.fail = fail;\n\nmodule.exports = assert;\n
code-source-info,0x24b376432386,16,172,307,C0O193C4O242C7O242C11O259C13O265C18O259C20O306,,
code-creation,LazyCompile,10,107939,0x24b376432586,53,loadPreloadModules node:internal/bootstrap/pre_execution:474:28,0x24b357dbf910,~
code-source-info,0x24b376432586,93,15267,15587,C0O15354C8O15354C13O15385C15O15422C21O15429C26O15505C32O15505C37O15505C42O15472C47O15549C52O15586,,
code-creation,LazyCompile,10,107981,0x24b37643276e,50,initializeFrozenIntrinsics node:internal/bootstrap/pre_execution:466:36,0x24b357dbf8c0,~
code-source-info,0x24b37643276e,93,15016,15238,C0O15023C8O15027C14O15072C17O15080C28O15080C34O15192C40O15192C45O15229C49O15237,,
code-creation,LazyCompile,10,108045,0x24b376432896,80,executeUserEntryPoint node:internal/modules/run_main:74:31,0x24b376431980,~
code-source-info,0x24b376432896,120,2320,2625,C7O2336C14O2340C22O2370C25O2370C30O2416C33O2416C38O2452C40O2476C45O2487C50O2476C56O2588C61O2595C73O2595C79O2624,,
code-creation,LazyCompile,10,108136,0x24b376432ce6,68,resolveMainPath node:internal/modules/run_main:11:25,0x24b376431818,~
code-source-info,0x24b376432ce6,120,296,710,C0O468C5O475C12O485C15O490C20O490C30O475C36O520C38O539C39O546C40O579C48O579C53O625C55O656C60O667C65O692C67O708,,
tick,0x7fff201caec5,108293,0,0x0,3,0x10c825337,0x24b376432d04,0x24b3764328af,0x24b357dbd331
code-creation,LazyCompile,10,108491,0x24b376432ee6,436,Module._findPath node:internal/modules/cjs/loader:494:28,0x24b326961c08,~
code-source-info,0x24b376432ee6,100,14309,16913,C0O14362C5O14367C10O14367C16O14390C18O14417C26O14440C30O14460C36O14467C41O14480C42O14493C43O14518C45O14526C51O14537C57O14537C62O14535C66O14588C69O14595C76O14605C80O14619C82O14634C84O14647C85O14655C87O14691C93O14698C100O14709C103O14752C107O14759C111O14709C119O14772C121O14764C125O14794C127O14820C134O14856C137O14836C143O14925C145O14938C149O14930C154O15023C156O15028C160O15037C165O15052C172O15066C177O15071C179O15086C183O15140C186O15140C192O15180C194O15209C196O15232C197O15261C202O15266C207O15266C214O15301C216O15327C219O15327C224O15347C228O15375C229O15382C234O15409C238O15434C244O15470C249O15486C254O15486C262O15536C265O15547C272O15596C278O16210C283O16226C288O16226C296O16272C299O16283C304O16330C308O16401C312O16435C320O16460C325O16442C330O16482C342O16493C348O16551C354O16571C359O16656C363O16688C371O16713C376O16695C381O16733C396O16744C402O16800C406O16822C409O16829C416O16850C420O16868C422O16884C423O14947C428O14912C434O16898C435O16911,,
code-creation,LazyCompile,10,108603,0x24b376433296,45,isAbsolute node:path:1156:13,0x24b3bc5a8c38,~
code-source-info,0x24b376433296,35,35448,35594,C0O35461C8O35461C13O35507C19O35514C26O35532C31O35532C39O35571C41O35567C44O35590,,
code-creation,LazyCompile,10,108804,0x24b3764334b6,85,stat node:internal/modules/cjs/loader:151:14,0x24b3269611a8,~
code-source-info,0x24b3764334b6,100,4627,5024,C0O4642C5O4658C10O4658C17O4688C23O4733C28O4743C33O4743C39O4762C41O4788C43O4802C44O4824C49O4824C54O4856C61O4889C66O4969C71O4979C76O4979C82O5008C84O5022,,
code-creation,LazyCompile,10,108849,0x24b3764335f6,3,toNamespacedPath node:path:1266:19,0x24b3bc5a8d28,~
code-source-info,0x24b3764335f6,35,38609,38669,C0O38653C2O38665,,
code-creation,LazyCompile,10,109015,0x24b3764336be,44,tryExtensions node:internal/modules/cjs/loader:400:23,0x24b3269614c8,~
code-source-info,0x24b3764336be,100,11501,11685,C0O11536C2O11548C6O11541C11O11584C16O11600C19O11594C23O11584C29O11619C31O11641C33O11657C34O11557C39O11523C42O11670C43O11683,,
code-creation,LazyCompile,10,109068,0x24b3764337ee,50,tryFile node:internal/modules/cjs/loader:384:17,0x24b326961428,~
code-source-info,0x24b3764337ee,100,11077,11271,C0O11114C3O11114C8O11135C9O11142C14O11149C15O11156C16O11159C24O11184C26O11198C31O11210C36O11210C41O11231C42O11238C45O11245C49O11269,,
code-creation,LazyCompile,10,109219,0x24b376433986,109,shouldUseESMLoader node:internal/modules/run_main:26:28,0x24b376431868,~
code-source-info,0x24b376433986,120,739,1299,C0O773C8O773C13O816C15O836C16O848C17O891C25O891C30O948C32O980C37O996C38O1008C39O1056C45O1072C51O1072C58O1119C59O1131C60O1134C66O1151C72O1151C79O1198C80O1211C81O1226C86O1226C91O1256C93O1274C98O1279C105O1284C108O1297,,
code-creation,LazyCompile,10,109493,0x24b376433c6e,619,Module._load node:internal/modules/cjs/loader:757:24,0x24b326961ee8,~
code-source-info,0x24b376433c6e,100,23190,26108,C0O23224C2O23253C6O23271C14O23331C23O23271C28O23561C42O23572C47O23604C54O23624C58O23657C60O23714C63O23721C70O23727C74O23745C76O23787C88O23787C93O23857C99O23875C102O23882C106O23925C107O23954C111O23962C112O23977C119O24005C121O24063C124O24070C138O24070C144O24115C152O24119C159O24210C167O24210C173O24265C178O24265C184O24300C189O24311C198O24343C205O24349C210O24343C211O24416C215O24424C216O24453C219O24460C226O24466C230O24480C232O24518C244O24518C249O24584C255O24626C260O24640C265O24640C271O24665C273O24709C279O24725C282O24732C286O24775C287O24782C288O24807C294O24854C298O24862C299O24888C304O24888C310O24927C315O24934C324O24969C328O24977C329O25063C344O25079C350O25112C354O25130C359O25149C363O25163C365O25173C369O25187C372O25194C379O25211C383O25223C387O25255C394O25303C398O25334C403O25359C409O25359C414O25379C426O25385C427O25412C432O25431C436O25445C444O25452C446O25469C450O25505C458O25533C460O25586C467O25592C475O25612C481O25616C487O25666C493O25666C499O25717C501O25727C506O25749C522O25749C529O25843C537O25870C541O25885C547O25870C555O25912C559O25940C565O25912C573O25970C575O25949C580O26016C586O26044C594O26053C598O26016C614O26098C618O26106,,
tick,0x7fff203201df,109758,0,0x0,3,0x10c825337,0x24b3764328df,0x24b357dbd331
code-creation,LazyCompile,10,109914,0x24b3764343d6,809,Module._resolveFilename node:internal/modules/cjs/loader:848:35,0x24b326961f70,~
code-source-info,0x24b3764343d6,100,26145,29133,C0O26184C10O26188C19O26241C23O26254C29O26254C36O26291C38O26306C39O26318C41O26328C51O26387C57O26412C63O26391C69O26447C79O26447C88O26501C96O26501C105O26558C111O26571C119O26571C128O26627C136O26627C142O26679C144O26721C151O26770C164O26770C170O26801C173O26835C175O26850C181O26856C185O26840C190O26902C198O26907C202O26922C206O26948C212O26948C217O26939C221O27002C225O27009C231O27009C238O27075C240O27094C244O27080C249O27121C257O27167C262O27126C269O27187C277O27224C282O27187C287O27103C292O27062C295O26865C300O26822C305O27283C311O27312C315O27327C321O27327C330O27384C340O27441C348O27390C353O27384C356O27470C360O27485C366O27485C373O27530C380O27540C389O27558C390O27569C397O27573C402O27602C406O27626C412O27602C420O27657C428O27661C441O27706C447O27748C453O27779C457O27800C463O27779C471O27845C478O27748C485O27868C491O27894C497O27713C502O27900C516O27933C520O27939C528O27944C533O27984C539O27990C543O27984C544O28031C546O28031C547O28128C551O28128C556O28178C560O28178C566O28210C568O28251C570O28259C575O28286C583O28293C589O28306C596O28312C604O28312C609O28268C613O28352C617O28359C625O28380C629O28400C631O28420C632O28506C636O28513C654O28513C660O28557C662O28571C664O28587C665O28611C668O28635C673O28647C677O28705C683O28745C692O28764C698O28705C703O28666C709O28686C715O28686C721O28617C724O28789C730O28812C742O28843C749O28850C754O28861C756O28879C763O28920C771O28920C776O28904C780O29031C788O29031C794O29053C796O29062C800O29086C802O29103C806O29121C808O29121,,
code-creation,LazyCompile,10,110051,0x24b37643498e,28,canBeRequiredByUsers node:internal/bootstrap/loaders:240:30,0x24b3c058f668,~
code-source-info,0x24b37643498e,9,7353,7449,C0O7376C5O7389C10O7393C15O7393C21O7406C23O7424C27O7445,,
code-creation,LazyCompile,10,110138,0x24b376434c46,327,Module._resolveLookupPaths node:internal/modules/cjs/loader:667:38,0x24b326961db8,~
code-source-info,0x24b376434c46,100,19946,21123,C0O19968C5O19985C10O19985C17O20022C25O20022C30O20066C31O20078C32O20121C39O20125C47O20159C52O20185C59O20192C66O20205C72O20205C80O20239C87O20256C93O20256C101O20290C108O20309C114O20322C120O20322C128O20356C133O20387C138O20404C145O20414C152O20421C161O20439C166O20475C171O20447C177O20501C191O20501C196O20565C202O20572C212O20591C213O20638C217O20661C223O20675C229O20846C234O20858C248O20858C253O20913C255O20930C256O20938C264O21005C272O20938C277O21031C286O21032C289O21037C294O21052C299O21037C311O21066C319O21066C324O21104C326O21121,,
code-creation,LazyCompile,10,110213,0x24b376434f0e,104,logger node:internal/util/debuglog:96:18,0x24b3bc5bb478,~
code-source-info,0x24b376434f0e,40,2899,3124,C0O2899C3O2931C30O2955C35O2962C38O2970C39O2985C45O3002C49O2992C53O3007C54O3022C60O3039C66O3048C70O3029C75O3053C76O3069C80O3076C87O3089C92O3085C98O3076C103O3114,,
code-creation,LazyCompile,10,110293,0x24b376435066,3, node:internal/per_context/primordials:276:21,0x24b3c0589960,~
code-source-info,0x24b376435066,6,7920,7949,C0O7931C2O7943,,
code-creation,LazyCompile,10,110423,0x24b37643513e,155,debug node:internal/util/debuglog:76:15,0x24b3bc5bb3d8,~
code-source-info,0x24b37643513e,40,2357,2781,C0O2357C3O2376C6O2376C9O2484C16O2505C22O2492C30O2490C36O2524C42O2560C47O2563C50O2560C54O2588C81O2612C86O2619C89O2627C90O2642C96O2659C100O2649C104O2664C105O2679C111O2696C117O2705C121O2686C126O2710C127O2726C131O2733C138O2746C143O2742C149O2733C154O2771,,
code-creation,LazyCompile,10,110499,0x24b37643530e,41,init node:internal/util/debuglog:72:16,0x24b3bc5bb388,~
code-source-info,0x24b37643530e,40,2259,2342,C0O2268C10O2274C14O2272C16O2311C26O2321C33O2319C40O2341,,
code-creation,LazyCompile,10,110558,0x24b3764353fe,2,testEnabled node:internal/util/debuglog:32:19,0x24b326953490,~
code-source-info,0x24b3764353fe,40,973,984,C0O979C1O984,,
code-creation,LazyCompile,10,110624,0x24b376435596,116,debuglogImpl node:internal/util/debuglog:49:22,0x24b3bc5bb1c0,~
code-source-info,0x24b376435596,40,1451,1995,C0O1451C9O1470C18O1484C23O1511C34O1544C39O1552C43O1544C45O1563C55O1563C59O1595C71O1606C75O1611C83O1934C97O1952C99O1950C103O1970C112O1987C115O1993,,
code-creation,LazyCompile,10,110670,0x24b37643574e,10, node:internal/modules/cjs/loader:272:66,0x24b326961bb8,~
code-source-info,0x24b37643574e,100,7709,7734,C0O7721C2O7727C9O7733,,
code-creation,LazyCompile,10,110701,0x24b3764357fe,2,noop node:internal/util/debuglog:47:14,0x24b3bc5bb170,~
code-source-info,0x24b3764357fe,40,1419,1427,C1O1426,,
code-creation,LazyCompile,10,110745,0x24b37643593e,76,trySelfParentPath node:internal/modules/cjs/loader:427:27,0x24b326961568,~
code-source-info,0x24b37643593e,100,12270,12533,C0O12283C4O12296C5O12309C6O12324C12O12354C16O12363C17O12384C24O12387C29O12410C36O12413C44O12455C47O12470C52O12470C59O12478C62O12483C66O12476C69O12487C72O12508C73O12521C75O12532,,
tick,0x10c78196b,110872,0,0x0,2,0x10c825337,0x24b376434606,0x24b376433cf8,0x24b3764328df,0x24b357dbd331
code-creation,LazyCompile,10,110900,0x24b376435b7e,232,trySelf node:internal/modules/cjs/loader:441:17,0x24b3269615b8,~
code-source-info,0x24b376435b7e,100,12551,13375,C0O12577C4O12594C5O12607C6O12648C9O12648C17O12625C22O12636C27O12686C31O12702C37O12725C38O12738C39O12756C47O12775C48O12788C49O12796C51O12829C55O12821C60O12841C65O12867C70O12913C82O12871C89O12929C94O12947C97O12981C102O12986C107O12947C112O12945C118O13010C119O13023C123O13041C128O13070C133O13099C138O13121C142O13099C149O13163C152O13163C159O13190C168O13070C180O13048C185O13227C197O13248C200O13254C207O13259C212O13293C219O13337C223O13299C228O13293C229O13361C231O13361,,
code-creation,RegExp,3,111098,0x1143051c0,1524,(?:^|\\/)\\.?\\.$
code-creation,LazyCompile,10,111401,0x24b376435fde,326, node:internal/process/execution:142:10,0x24b3cf289bd0,~
script-source,76,node:internal/process/execution,'use strict';\n\nconst {\n  globalThis\x2C\n} = primordials;\n\nconst path = require('path');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET\x2C\n    ERR_EVAL_ESM_CANNOT_PRINT\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  executionAsyncId\x2C\n  clearDefaultTriggerAsyncId\x2C\n  clearAsyncIdStack\x2C\n  hasAsyncIdStack\x2C\n  afterHooksExist\x2C\n  emitAfter\n} = require('internal/async_hooks');\n\n// shouldAbortOnUncaughtToggle is a typed array for faster\n// communication with JS.\nconst { shouldAbortOnUncaughtToggle } = internalBinding('util');\n\nfunction tryGetCwd() {\n  try {\n    return process.cwd();\n  } catch {\n    // getcwd(3) can fail if the current working directory has been deleted.\n    // Fall back to the directory name of the (absolute) executable path.\n    // It's not really correct but what are the alternatives?\n    return path.dirname(process.execPath);\n  }\n}\n\nfunction evalModule(source\x2C print) {\n  if (print) {\n    throw new ERR_EVAL_ESM_CANNOT_PRINT();\n  }\n  const { log } = require('internal/console/global');\n  const { loadESM } = require('internal/process/esm_loader');\n  const { handleMainPromise } = require('internal/modules/run_main');\n  return handleMainPromise(loadESM(async (loader) => {\n    const { result } = await loader.eval(source);\n    if (print) {\n      log(result);\n    }\n  }));\n}\n\nfunction evalScript(name\x2C body\x2C breakFirstLine\x2C print) {\n  const CJSModule = require('internal/modules/cjs/loader').Module;\n  const { kVmBreakFirstLineSymbol } = require('internal/util');\n  const { pathToFileURL } = require('url');\n\n  const cwd = tryGetCwd();\n  const origModule = globalThis.module;  // Set e.g. when called from the REPL.\n\n  const module = new CJSModule(name);\n  module.filename = path.join(cwd\x2C name);\n  module.paths = CJSModule._nodeModulePaths(cwd);\n\n  const asyncESM = require('internal/process/esm_loader');\n  const baseUrl = pathToFileURL(module.filename).href;\n\n  // Create wrapper for cache entry\n  const script = `\n    globalThis.module = module;\n    globalThis.exports = exports;\n    globalThis.__dirname = __dirname;\n    globalThis.require = require;\n    return (main) => main();\n  `;\n  globalThis.__filename = name;\n  const result = module._compile(script\x2C `${name}-wrapper`)(() =>\n    require('vm').runInThisContext(body\x2C {\n      filename: name\x2C\n      displayErrors: true\x2C\n      [kVmBreakFirstLineSymbol]: !!breakFirstLine\x2C\n      async importModuleDynamically(specifier) {\n        const loader = await asyncESM.esmLoader;\n        return loader.import(specifier\x2C baseUrl);\n      }\n    }));\n  if (print) {\n    const { log } = require('internal/console/global');\n    log(result);\n  }\n\n  if (origModule !== undefined)\n    globalThis.module = origModule;\n}\n\nconst exceptionHandlerState = {\n  captureFn: null\x2C\n  reportFlag: false\n};\n\nfunction setUncaughtExceptionCaptureCallback(fn) {\n  if (fn === null) {\n    exceptionHandlerState.captureFn = fn;\n    shouldAbortOnUncaughtToggle[0] = 1;\n    process.report.reportOnUncaughtException = exceptionHandlerState.reportFlag;\n    return;\n  }\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn'\x2C ['Function'\x2C 'null']\x2C fn);\n  }\n  if (exceptionHandlerState.captureFn !== null) {\n    throw new ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET();\n  }\n  exceptionHandlerState.captureFn = fn;\n  shouldAbortOnUncaughtToggle[0] = 0;\n  exceptionHandlerState.reportFlag =\n    process.report.reportOnUncaughtException === true;\n  process.report.reportOnUncaughtException = false;\n}\n\nfunction hasUncaughtExceptionCaptureCallback() {\n  return exceptionHandlerState.captureFn !== null;\n}\n\nfunction noop() {}\n\n// XXX(joyeecheung): for some reason this cannot be defined at the top-level\n// and exported to be written to process._fatalException\x2C it has to be\n// returned as an *anonymous function* wrapped inside a factory function\x2C\n// otherwise it breaks the test-timers.setInterval async hooks test -\n// this may indicate that node::errors::TriggerUncaughtException() should\n// fix up the callback scope before calling into process._fatalException\x2C\n// or this function should take extra care of the async hooks before it\n// schedules a setImmediate.\nfunction createOnGlobalUncaughtException() {\n  // The C++ land node::errors::TriggerUncaughtException() will\n  // exit the process if it returns false\x2C and continue execution if it\n  // returns true (which indicates that the exception is handled by the user).\n  return (er\x2C fromPromise) => {\n    // It's possible that defaultTriggerAsyncId was set for a constructor\n    // call that threw and was never cleared. So clear it now.\n    clearDefaultTriggerAsyncId();\n\n    // If diagnostic reporting is enabled\x2C call into its handler to see\n    // whether it is interested in handling the situation.\n    // Ignore if the error is scoped inside a domain.\n    // use == in the checks as we want to allow for null and undefined\n    if (er == null || er.domain == null) {\n      try {\n        const report = internalBinding('report');\n        if (report != null && report.shouldReportOnUncaughtException()) {\n          report.writeReport(\n            typeof er?.message === 'string' ?\n              er.message :\n              'Exception'\x2C\n            'Exception'\x2C\n            null\x2C\n            er ? er : {});\n        }\n      } catch {}  // Ignore the exception. Diagnostic reporting is unavailable.\n    }\n\n    const type = fromPromise ? 'unhandledRejection' : 'uncaughtException';\n    process.emit('uncaughtExceptionMonitor'\x2C er\x2C type);\n    if (exceptionHandlerState.captureFn !== null) {\n      exceptionHandlerState.captureFn(er);\n    } else if (!process.emit('uncaughtException'\x2C er\x2C type)) {\n      // If someone handled it\x2C then great. Otherwise\x2C die in C++ land\n      // since that means that we'll exit the process\x2C emit the 'exit' event.\n      try {\n        if (!process._exiting) {\n          process._exiting = true;\n          process.exitCode = 1;\n          process.emit('exit'\x2C 1);\n        }\n      } catch {\n        // Nothing to be done about it at this point.\n      }\n      return false;\n    }\n\n    // If we handled an error\x2C then make sure any ticks get processed\n    // by ensuring that the next Immediate cycle isn't empty.\n    require('timers').setImmediate(noop);\n\n    // Emit the after() hooks now that the exception has been handled.\n    if (afterHooksExist()) {\n      do {\n        emitAfter(executionAsyncId());\n      } while (hasAsyncIdStack());\n    }\n    // And completely empty the id stack\x2C including anything that may be\n    // cached on the native side.\n    clearAsyncIdStack();\n\n    return true;\n  };\n}\n\nfunction readStdin(callback) {\n  process.stdin.setEncoding('utf8');\n\n  let code = '';\n  process.stdin.on('data'\x2C (d) => {\n    code += d;\n  });\n\n  process.stdin.on('end'\x2C () => {\n    callback(code);\n  });\n}\n\nmodule.exports = {\n  readStdin\x2C\n  tryGetCwd\x2C\n  evalModule\x2C\n  evalScript\x2C\n  onGlobalUncaughtException: createOnGlobalUncaughtException()\x2C\n  setUncaughtExceptionCaptureCallback\x2C\n  hasUncaughtExceptionCaptureCallback\n};\n
code-source-info,0x24b376435fde,76,4428,6574,C0O4592C5O4592C8O4883C13O4904C23O4957C29O4957C34O4992C37O5021C42O5021C48O5075C63O5109C74O5151C90O5243C96O5248C98O5075C109O5372C120O5434C123O5442C137O5442C142O5490C147O5516C153O5544C158O5566C163O5566C170O5592C173O5605C187O5605C197O5813C200O5826C206O5848C210O5865C214O5883C219O5900C223O5915C226O5923C237O5923C249O6034C250O6047C251O6191C257O6191C262O6208C270O6209C275O6305C280O6309C285O6349C292O6359C295O6359C299O6349C303O6395C308O6395C313O6336C316O6532C321O6532C324O6558C325O6570,,
tick,0x10c791907,112171,0,0x0,3,0x10c825337,0x24b376435fe3
code-creation,LazyCompile,10,112199,0x24b3764369b6,18,clearDefaultTriggerAsyncId node:internal/async_hooks:440:36,0x24b3c05ba068,~
script-source,24,node:internal/async_hooks,'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  ErrorCaptureStackTrace\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectDefineProperty\x2C\n  Symbol\x2C\n} = primordials;\n\nconst async_wrap = internalBinding('async_wrap');\nconst { setCallbackTrampoline } = async_wrap;\n/* async_hook_fields is a Uint32Array wrapping the uint32_t array of\n * Environment::AsyncHooks::fields_[]. Each index tracks the number of active\n * hooks for each type.\n *\n * async_id_fields is a Float64Array wrapping the double array of\n * Environment::AsyncHooks::async_id_fields_[]. Each index contains the ids for\n * the various asynchronous states of the application. These are:\n *  kExecutionAsyncId: The async_id assigned to the resource responsible for the\n *    current execution stack.\n *  kTriggerAsyncId: The async_id of the resource that caused (or 'triggered')\n *    the resource corresponding to the current execution stack.\n *  kAsyncIdCounter: Incremental counter tracking the next assigned async_id.\n *  kDefaultTriggerAsyncId: Written immediately before a resource's constructor\n *    that sets the value of the init()'s triggerAsyncId. The precedence order\n *    of retrieving the triggerAsyncId value is:\n *    1. the value passed directly to the constructor\n *    2. value set in kDefaultTriggerAsyncId\n *    3. executionAsyncId of the current resource.\n *\n * async_ids_stack is a Float64Array that contains part of the async ID\n * stack. Each pushAsyncContext() call adds two doubles to it\x2C and each\n * popAsyncContext() call removes two doubles from it.\n * It has a fixed size\x2C so if that is exceeded\x2C calls to the native\n * side are used instead in pushAsyncContext() and popAsyncContext().\n */\nconst {\n  async_hook_fields\x2C\n  async_id_fields\x2C\n  execution_async_resources\n} = async_wrap;\n// Store the pair executionAsyncId and triggerAsyncId in a AliasedFloat64Array\n// in Environment::AsyncHooks::async_ids_stack_ which tracks the resource\n// responsible for the current execution stack. This is unwound as each resource\n// exits. In the case of a fatal exception this stack is emptied after calling\n// each hook's after() callback.\nconst {\n  pushAsyncContext: pushAsyncContext_\x2C\n  popAsyncContext: popAsyncContext_\x2C\n  executionAsyncResource: executionAsyncResource_\x2C\n  clearAsyncIdStack\x2C\n} = async_wrap;\n// For performance reasons\x2C only track Promises when a hook is enabled.\nconst { setPromiseHooks } = async_wrap;\n// Properties in active_hooks are used to keep track of the set of hooks being\n// executed in case another hook is enabled/disabled. The new set of hooks is\n// then restored once the active set of hooks is finished executing.\nconst active_hooks = {\n  // Array of all AsyncHooks that will be iterated whenever an async event\n  // fires. Using var instead of (preferably const) in order to assign\n  // active_hooks.tmp_array if a hook is enabled/disabled during hook\n  // execution.\n  array: []\x2C\n  // Use a counter to track nested calls of async hook callbacks and make sure\n  // the active_hooks.array isn't altered mid execution.\n  call_depth: 0\x2C\n  // Use to temporarily store and updated active_hooks.array if the user\n  // enables or disables a hook while hooks are being processed. If a hook is\n  // enabled() or disabled() during hook execution then the current set of\n  // active hooks is duplicated and set equal to active_hooks.tmp_array. Any\n  // subsequent changes are on the duplicated array. When all hooks have\n  // completed executing active_hooks.tmp_array is assigned to\n  // active_hooks.array.\n  tmp_array: null\x2C\n  // Keep track of the field counts held in active_hooks.tmp_array. Because the\n  // async_hook_fields can't be reassigned\x2C store each uint32 in an array that\n  // is written back to async_hook_fields when active_hooks.array is restored.\n  tmp_fields: null\n};\n\nconst { registerDestroyHook } = async_wrap;\nconst { enqueueMicrotask } = internalBinding('task_queue');\nconst { owner_symbol } = internalBinding('symbols');\n\n// Each constant tracks how many callbacks there are for any given step of\n// async execution. These are tracked so if the user didn't include callbacks\n// for a given step\x2C that step can bail out early.\nconst {\n  kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\x2C\n  kCheck\x2C kExecutionAsyncId\x2C kAsyncIdCounter\x2C kTriggerAsyncId\x2C\n  kDefaultTriggerAsyncId\x2C kStackLength\x2C kUsesExecutionAsyncResource\x2C\n} = async_wrap.constants;\n\nconst { async_id_symbol\x2C\n        trigger_async_id_symbol } = internalBinding('symbols');\n\n// Lazy load of internal/util/inspect;\nlet inspect;\n\n// Used in AsyncHook and AsyncResource.\nconst init_symbol = Symbol('init');\nconst before_symbol = Symbol('before');\nconst after_symbol = Symbol('after');\nconst destroy_symbol = Symbol('destroy');\nconst promise_resolve_symbol = Symbol('promiseResolve');\nconst emitBeforeNative = emitHookFactory(before_symbol\x2C 'emitBeforeNative');\nconst emitAfterNative = emitHookFactory(after_symbol\x2C 'emitAfterNative');\nconst emitDestroyNative = emitHookFactory(destroy_symbol\x2C 'emitDestroyNative');\nconst emitPromiseResolveNative =\n    emitHookFactory(promise_resolve_symbol\x2C 'emitPromiseResolveNative');\n\nlet domain_cb;\nfunction useDomainTrampoline(fn) {\n  domain_cb = fn;\n}\n\nfunction callbackTrampoline(asyncId\x2C resource\x2C cb\x2C ...args) {\n  const index = async_hook_fields[kStackLength] - 1;\n  execution_async_resources[index] = resource;\n\n  if (asyncId !== 0 && hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n\n  let result;\n  if (asyncId === 0 && typeof domain_cb === 'function') {\n    args.unshift(cb);\n    result = domain_cb.apply(this\x2C args);\n  } else {\n    result = cb.apply(this\x2C args);\n  }\n\n  if (asyncId !== 0 && hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  execution_async_resources.pop();\n  return result;\n}\n\nsetCallbackTrampoline(callbackTrampoline);\n\nconst topLevelResource = {};\n\nfunction executionAsyncResource() {\n  // Indicate to the native layer that this function is likely to be used\x2C\n  // in which case it will inform JS about the current async resource via\n  // the trampoline above.\n  async_hook_fields[kUsesExecutionAsyncResource] = 1;\n\n  const index = async_hook_fields[kStackLength] - 1;\n  if (index === -1) return topLevelResource;\n  const resource = execution_async_resources[index] ||\n    executionAsyncResource_(index);\n  return lookupPublicResource(resource);\n}\n\nfunction inspectExceptionValue(e) {\n  inspect ??= require('internal/util/inspect').inspect;\n  return { message: inspect(e) };\n}\n\n// Used to fatally abort the process if a callback throws.\nfunction fatalError(e) {\n  if (typeof e?.stack === 'string') {\n    process._rawDebug(e.stack);\n  } else {\n    const o = inspectExceptionValue(e);\n    ErrorCaptureStackTrace(o\x2C fatalError);\n    process._rawDebug(o.stack);\n  }\n\n  const { getOptionValue } = require('internal/options');\n  if (getOptionValue('--abort-on-uncaught-exception')) {\n    process.abort();\n  }\n  process.exit(1);\n}\n\nfunction lookupPublicResource(resource) {\n  if (typeof resource !== 'object' || resource === null) return resource;\n\n  const publicResource = resource[owner_symbol];\n\n  if (publicResource != null) {\n    return publicResource;\n  }\n\n  return resource;\n}\n\n// Emit From Native //\n\n// Used by C++ to call all init() callbacks. Because some state can be setup\n// from C++ there's no need to perform all the same operations as in\n// emitInitScript.\nfunction emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n  active_hooks.call_depth += 1;\n  resource = lookupPublicResource(resource);\n  // Use a single try/catch for all hooks to avoid setting up one per iteration.\n  try {\n    // Using var here instead of let because "for (var ...)" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][init_symbol] === 'function') {\n        active_hooks.array[i][init_symbol](\n          asyncId\x2C type\x2C triggerAsyncId\x2C\n          resource\n        );\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution\x2C in which case active_hooks.tmp_array\n  // will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\n// Called from native. The asyncId stack handling is taken care of there\n// before this is called.\nfunction emitHook(symbol\x2C asyncId) {\n  active_hooks.call_depth += 1;\n  // Use a single try/catch for all hook to avoid setting up one per\n  // iteration.\n  try {\n    // Using var here instead of let because "for (var ...)" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][symbol] === 'function') {\n        active_hooks.array[i][symbol](asyncId);\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution\x2C in which case\n  // active_hooks.tmp_array will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\nfunction emitHookFactory(symbol\x2C name) {\n  const fn = emitHook.bind(undefined\x2C symbol);\n\n  // Set the name property of the function as it looks good in the stack trace.\n  ObjectDefineProperty(fn\x2C 'name'\x2C {\n    value: name\n  });\n  return fn;\n}\n\n// Manage Active Hooks //\n\nfunction getHookArrays() {\n  if (active_hooks.call_depth === 0)\n    return [active_hooks.array\x2C async_hook_fields];\n  // If this hook is being enabled while in the middle of processing the array\n  // of currently active hooks then duplicate the current set of active hooks\n  // and store this there. This shouldn't fire until the next time hooks are\n  // processed.\n  if (active_hooks.tmp_array === null)\n    storeActiveHooks();\n  return [active_hooks.tmp_array\x2C active_hooks.tmp_fields];\n}\n\n\nfunction storeActiveHooks() {\n  active_hooks.tmp_array = ArrayPrototypeSlice(active_hooks.array);\n  // Don't want to make the assumption that kInit to kDestroy are indexes 0 to\n  // 4. So do this the long way.\n  active_hooks.tmp_fields = [];\n  copyHooks(active_hooks.tmp_fields\x2C async_hook_fields);\n}\n\nfunction copyHooks(destination\x2C source) {\n  destination[kInit] = source[kInit];\n  destination[kBefore] = source[kBefore];\n  destination[kAfter] = source[kAfter];\n  destination[kDestroy] = source[kDestroy];\n  destination[kPromiseResolve] = source[kPromiseResolve];\n}\n\n\n// Then restore the correct hooks array in case any hooks were added/removed\n// during hook callback execution.\nfunction restoreActiveHooks() {\n  active_hooks.array = active_hooks.tmp_array;\n  copyHooks(async_hook_fields\x2C active_hooks.tmp_fields);\n\n  active_hooks.tmp_array = null;\n  active_hooks.tmp_fields = null;\n}\n\nfunction trackPromise(promise\x2C parent) {\n  if (promise[async_id_symbol]) {\n    return;\n  }\n\n  // Get trigger id from parent async id before making the async id of the\n  // child so if a new one must be made it will be lower than the child.\n  const triggerAsyncId = parent ? getOrSetAsyncId(parent) :\n    getDefaultTriggerAsyncId();\n\n  promise[async_id_symbol] = newAsyncId();\n  promise[trigger_async_id_symbol] = triggerAsyncId;\n}\n\nfunction promiseInitHook(promise\x2C parent) {\n  trackPromise(promise\x2C parent);\n  const asyncId = promise[async_id_symbol];\n  const triggerAsyncId = promise[trigger_async_id_symbol];\n  emitInitScript(asyncId\x2C 'PROMISE'\x2C triggerAsyncId\x2C promise);\n}\n\nfunction promiseInitHookWithDestroyTracking(promise\x2C parent) {\n  promiseInitHook(promise\x2C parent);\n  destroyTracking(promise\x2C parent);\n}\n\nconst destroyedSymbol = Symbol('destroyed');\n\nfunction destroyTracking(promise\x2C parent) {\n  trackPromise(promise\x2C parent);\n  const asyncId = promise[async_id_symbol];\n  const destroyed = { destroyed: false };\n  promise[destroyedSymbol] = destroyed;\n  registerDestroyHook(promise\x2C asyncId\x2C destroyed);\n}\n\nfunction promiseBeforeHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  const triggerId = promise[trigger_async_id_symbol];\n  emitBeforeScript(asyncId\x2C triggerId\x2C promise);\n}\n\nfunction promiseAfterHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  if (hasHooks(kAfter)) {\n    emitAfterNative(asyncId);\n  }\n  if (asyncId === executionAsyncId()) {\n    // This condition might not be true if async_hooks was enabled during\n    // the promise callback execution.\n    // Popping it off the stack can be skipped in that case\x2C because it is\n    // known that it would correspond to exactly one call with\n    // PromiseHookType::kBefore that was not witnessed by the PromiseHook.\n    popAsyncContext(asyncId);\n  }\n}\n\nfunction promiseResolveHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  emitPromiseResolveNative(asyncId);\n}\n\nlet wantPromiseHook = false;\nfunction enableHooks() {\n  async_hook_fields[kCheck] += 1;\n}\n\nfunction updatePromiseHookMode() {\n  wantPromiseHook = true;\n  let initHook;\n  if (initHooksExist()) {\n    initHook = destroyHooksExist() ? promiseInitHookWithDestroyTracking :\n      promiseInitHook;\n  } else if (destroyHooksExist()) {\n    initHook = destroyTracking;\n  }\n  setPromiseHooks(\n    initHook\x2C\n    promiseBeforeHook\x2C\n    promiseAfterHook\x2C\n    promiseResolveHooksExist() ? promiseResolveHook : undefined\x2C\n  );\n}\n\nfunction disableHooks() {\n  async_hook_fields[kCheck] -= 1;\n\n  wantPromiseHook = false;\n\n  // Delay the call to `disablePromiseHook()` because we might currently be\n  // between the `before` and `after` calls of a Promise.\n  enqueueMicrotask(disablePromiseHookIfNecessary);\n}\n\nfunction disablePromiseHookIfNecessary() {\n  if (!wantPromiseHook) {\n    setPromiseHooks(undefined\x2C undefined\x2C undefined\x2C undefined);\n  }\n}\n\n// Internal Embedder API //\n\n// Increment the internal id counter and return the value. Important that the\n// counter increment first. Since it's done the same way in\n// Environment::new_async_uid()\nfunction newAsyncId() {\n  return ++async_id_fields[kAsyncIdCounter];\n}\n\nfunction getOrSetAsyncId(object) {\n  if (ObjectPrototypeHasOwnProperty(object\x2C async_id_symbol)) {\n    return object[async_id_symbol];\n  }\n\n  return object[async_id_symbol] = newAsyncId();\n}\n\n\n// Return the triggerAsyncId meant for the constructor calling it. It's up to\n// the user to safeguard this call and make sure it's zero'd out when the\n// constructor is complete.\nfunction getDefaultTriggerAsyncId() {\n  const defaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  // If defaultTriggerAsyncId isn't set\x2C use the executionAsyncId\n  if (defaultTriggerAsyncId < 0)\n    return async_id_fields[kExecutionAsyncId];\n  return defaultTriggerAsyncId;\n}\n\n\nfunction clearDefaultTriggerAsyncId() {\n  async_id_fields[kDefaultTriggerAsyncId] = -1;\n}\n\n\nfunction defaultTriggerAsyncIdScope(triggerAsyncId\x2C block\x2C ...args) {\n  if (triggerAsyncId === undefined)\n    return block.apply(null\x2C args);\n  // CHECK(NumberIsSafeInteger(triggerAsyncId))\n  // CHECK(triggerAsyncId > 0)\n  const oldDefaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  async_id_fields[kDefaultTriggerAsyncId] = triggerAsyncId;\n\n  try {\n    return block.apply(null\x2C args);\n  } finally {\n    async_id_fields[kDefaultTriggerAsyncId] = oldDefaultTriggerAsyncId;\n  }\n}\n\nfunction hasHooks(key) {\n  return async_hook_fields[key] > 0;\n}\n\nfunction enabledHooksExist() {\n  return hasHooks(kCheck);\n}\n\nfunction initHooksExist() {\n  return hasHooks(kInit);\n}\n\nfunction afterHooksExist() {\n  return hasHooks(kAfter);\n}\n\nfunction destroyHooksExist() {\n  return hasHooks(kDestroy);\n}\n\nfunction promiseResolveHooksExist() {\n  return hasHooks(kPromiseResolve);\n}\n\n\nfunction emitInitScript(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n  // Short circuit all checks for the common case. Which is that no hooks have\n  // been set. Do this to remove performance impact for embedders (and core).\n  if (!hasHooks(kInit))\n    return;\n\n  if (triggerAsyncId === null) {\n    triggerAsyncId = getDefaultTriggerAsyncId();\n  }\n\n  emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource);\n}\n\n\nfunction emitBeforeScript(asyncId\x2C triggerAsyncId\x2C resource) {\n  pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource);\n\n  if (hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n}\n\n\nfunction emitAfterScript(asyncId) {\n  if (hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  popAsyncContext(asyncId);\n}\n\n\nfunction emitDestroyScript(asyncId) {\n  // Return early if there are no destroy callbacks\x2C or invalid asyncId.\n  if (!hasHooks(kDestroy) || asyncId <= 0)\n    return;\n  async_wrap.queueDestroyAsyncId(asyncId);\n}\n\n\nfunction hasAsyncIdStack() {\n  return hasHooks(kStackLength);\n}\n\n\n// This is the equivalent of the native push_async_ids() call.\nfunction pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource) {\n  const offset = async_hook_fields[kStackLength];\n  execution_async_resources[offset] = resource;\n  if (offset * 2 >= async_wrap.async_ids_stack.length)\n    return pushAsyncContext_(asyncId\x2C triggerAsyncId);\n  async_wrap.async_ids_stack[offset * 2] = async_id_fields[kExecutionAsyncId];\n  async_wrap.async_ids_stack[offset * 2 + 1] = async_id_fields[kTriggerAsyncId];\n  async_hook_fields[kStackLength]++;\n  async_id_fields[kExecutionAsyncId] = asyncId;\n  async_id_fields[kTriggerAsyncId] = triggerAsyncId;\n}\n\n\n// This is the equivalent of the native pop_async_ids() call.\nfunction popAsyncContext(asyncId) {\n  const stackLength = async_hook_fields[kStackLength];\n  if (stackLength === 0) return false;\n\n  if (enabledHooksExist() && async_id_fields[kExecutionAsyncId] !== asyncId) {\n    // Do the same thing as the native code (i.e. crash hard).\n    return popAsyncContext_(asyncId);\n  }\n\n  const offset = stackLength - 1;\n  async_id_fields[kExecutionAsyncId] = async_wrap.async_ids_stack[2 * offset];\n  async_id_fields[kTriggerAsyncId] = async_wrap.async_ids_stack[2 * offset + 1];\n  execution_async_resources.pop();\n  async_hook_fields[kStackLength] = offset;\n  return offset > 0;\n}\n\n\nfunction executionAsyncId() {\n  return async_id_fields[kExecutionAsyncId];\n}\n\nfunction triggerAsyncId() {\n  return async_id_fields[kTriggerAsyncId];\n}\n\n\nmodule.exports = {\n  executionAsyncId\x2C\n  triggerAsyncId\x2C\n  // Private API\n  getHookArrays\x2C\n  symbols: {\n    async_id_symbol\x2C trigger_async_id_symbol\x2C\n    init_symbol\x2C before_symbol\x2C after_symbol\x2C destroy_symbol\x2C\n    promise_resolve_symbol\x2C owner_symbol\n  }\x2C\n  constants: {\n    kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\n  }\x2C\n  enableHooks\x2C\n  disableHooks\x2C\n  updatePromiseHookMode\x2C\n  clearDefaultTriggerAsyncId\x2C\n  clearAsyncIdStack\x2C\n  hasAsyncIdStack\x2C\n  executionAsyncResource\x2C\n  // Internal Embedder API\n  newAsyncId\x2C\n  getOrSetAsyncId\x2C\n  getDefaultTriggerAsyncId\x2C\n  defaultTriggerAsyncIdScope\x2C\n  enabledHooksExist\x2C\n  initHooksExist\x2C\n  afterHooksExist\x2C\n  destroyHooksExist\x2C\n  emitInit: emitInitScript\x2C\n  emitBefore: emitBeforeScript\x2C\n  emitAfter: emitAfterScript\x2C\n  emitDestroy: emitDestroyScript\x2C\n  pushAsyncContext\x2C\n  popAsyncContext\x2C\n  registerDestroyHook\x2C\n  useDomainTrampoline\x2C\n  nativeHooks: {\n    init: emitInitNative\x2C\n    before: emitBeforeNative\x2C\n    after: emitAfterNative\x2C\n    destroy: emitDestroyNative\x2C\n    promise_resolve: emitPromiseResolveNative\n  }\n};\n
code-source-info,0x24b3764369b6,24,15080,15134,C0O15087C7O15103C12O15127C17O15133,,
tick,0x7fff20385158,113557,0,0x0,3,0x10c825337,0x24b376435fe3
code-creation,LazyCompile,10,113755,0x24b376437e0e,46,beforeInspector node:internal/errors:738:18,0x24b3c05a4ea0,~
script-source,11,node:internal/errors,/* eslint node-core/documented-errors: "error" */\n/* eslint node-core/alphabetize-errors: "error" */\n/* eslint node-core/prefer-util-format-errors: "error" */\n\n'use strict';\n\n// The whole point behind this internal module is to allow Node.js to no\n// longer be forced to treat every error message change as a semver-major\n// change. The NodeError classes here all expose a `code` property whose\n// value statically and permanently identifies the error. While the error\n// message may change\x2C the code should not.\n\nconst {\n  AggregateError\x2C\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePop\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  Error\x2C\n  ErrorCaptureStackTrace\x2C\n  ErrorPrototypeToString\x2C\n  JSONStringify\x2C\n  MapPrototypeGet\x2C\n  MathAbs\x2C\n  MathMax\x2C\n  Number\x2C\n  NumberIsInteger\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectIsExtensible\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RangeError\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  String\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SyntaxError\x2C\n  TypeError\x2C\n  URIError\x2C\n} = primordials;\n\nconst kIsNodeError = Symbol('kIsNodeError');\n\nconst isWindows = process.platform === 'win32';\n\nconst messages = new SafeMap();\nconst codes = {};\n\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/;\n// Sorted by a rough estimate on most frequently used entries.\nconst kTypes = [\n  'string'\x2C\n  'function'\x2C\n  'number'\x2C\n  'object'\x2C\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\n  'Function'\x2C\n  'Object'\x2C\n  'boolean'\x2C\n  'bigint'\x2C\n  'symbol'\x2C\n];\n\nconst MainContextError = Error;\nconst overrideStackTrace = new SafeWeakMap();\nconst kNoOverride = Symbol('kNoOverride');\nlet userStackTraceLimit;\nconst nodeInternalPrefix = '__node_internal_';\nconst prepareStackTrace = (globalThis\x2C error\x2C trace) => {\n  // API for node internals to override error stack formatting\n  // without interfering with userland code.\n  if (overrideStackTrace.has(error)) {\n    const f = overrideStackTrace.get(error);\n    overrideStackTrace.delete(error);\n    return f(error\x2C trace);\n  }\n\n  const firstFrame = trace[0]?.getFunctionName();\n  if (firstFrame && StringPrototypeStartsWith(firstFrame\x2C nodeInternalPrefix)) {\n    for (let l = trace.length - 1; l >= 0; l--) {\n      const fn = trace[l]?.getFunctionName();\n      if (fn && StringPrototypeStartsWith(fn\x2C nodeInternalPrefix)) {\n        ArrayPrototypeSplice(trace\x2C 0\x2C l + 1);\n        break;\n      }\n    }\n    // `userStackTraceLimit` is the user value for `Error.stackTraceLimit`\x2C\n    // it is updated at every new exception in `captureLargerStackTrace`.\n    if (trace.length > userStackTraceLimit)\n      ArrayPrototypeSplice(trace\x2C userStackTraceLimit);\n  }\n\n  const globalOverride =\n    maybeOverridePrepareStackTrace(globalThis\x2C error\x2C trace);\n  if (globalOverride !== kNoOverride) return globalOverride;\n\n  // Normal error formatting:\n  //\n  // Error: Message\n  //     at function (file)\n  //     at file\n  let errorString;\n  if (kIsNodeError in error) {\n    errorString = `${error.name} [${error.code}]: ${error.message}`;\n  } else {\n    errorString = ErrorPrototypeToString(error);\n  }\n  if (trace.length === 0) {\n    return errorString;\n  }\n  return `${errorString}\\n    at ${ArrayPrototypeJoin(trace\x2C '\\n    at ')}`;\n};\n\nconst maybeOverridePrepareStackTrace = (globalThis\x2C error\x2C trace) => {\n  // Polyfill of V8's Error.prepareStackTrace API.\n  // https://crbug.com/v8/7848\n  // `globalThis` is the global that contains the constructor which\n  // created `error`.\n  if (typeof globalThis.Error?.prepareStackTrace === 'function') {\n    return globalThis.Error.prepareStackTrace(error\x2C trace);\n  }\n  // We still have legacy usage that depends on the main context's `Error`\n  // being used\x2C even when the error is from a different context.\n  // TODO(devsnek): evaluate if this can be eventually deprecated/removed.\n  if (typeof MainContextError.prepareStackTrace === 'function') {\n    return MainContextError.prepareStackTrace(error\x2C trace);\n  }\n\n  return kNoOverride;\n};\n\nconst aggregateTwoErrors = hideStackFrames((innerError\x2C outerError) => {\n  if (innerError && outerError && innerError !== outerError) {\n    if (ArrayIsArray(outerError.errors)) {\n      // If `outerError` is already an `AggregateError`.\n      ArrayPrototypePush(outerError.errors\x2C innerError);\n      return outerError;\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new AggregateError(new SafeArrayIterator([\n      outerError\x2C\n      innerError\x2C\n    ])\x2C outerError.message);\n    err.code = outerError.code;\n    return err;\n  }\n  return innerError || outerError;\n});\n\n// Lazily loaded\nlet util;\nlet assert;\n\nlet internalUtil = null;\nfunction lazyInternalUtil() {\n  if (!internalUtil) {\n    internalUtil = require('internal/util');\n  }\n  return internalUtil;\n}\n\nlet internalUtilInspect = null;\nfunction lazyInternalUtilInspect() {\n  if (!internalUtilInspect) {\n    internalUtilInspect = require('internal/util/inspect');\n  }\n  return internalUtilInspect;\n}\n\nlet buffer;\nfunction lazyBuffer() {\n  if (buffer === undefined)\n    buffer = require('buffer').Buffer;\n  return buffer;\n}\n\nfunction isErrorStackTraceLimitWritable() {\n  const desc = ObjectGetOwnPropertyDescriptor(Error\x2C 'stackTraceLimit');\n  if (desc === undefined) {\n    return ObjectIsExtensible(Error);\n  }\n\n  return ObjectPrototypeHasOwnProperty(desc\x2C 'writable') ?\n    desc.writable :\n    desc.set !== undefined;\n}\n\n// A specialized Error that includes an additional info property with\n// additional information about the error condition.\n// It has the properties present in a UVException but with a custom error\n// message followed by the uv error code and uv error message.\n// It also has its own error code with the original uv error context put into\n// `err.info`.\n// The context passed into this error must have .code\x2C .syscall and .message\x2C\n// and may have .path and .dest.\nclass SystemError extends Error {\n  constructor(key\x2C context) {\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    super();\n    // Reset the limit and setting the name property.\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n    const prefix = getMessage(key\x2C []\x2C this);\n    let message = `${prefix}: ${context.syscall} returned ` +\n                  `${context.code} (${context.message})`;\n\n    if (context.path !== undefined)\n      message += ` ${context.path}`;\n    if (context.dest !== undefined)\n      message += ` => ${context.dest}`;\n\n    captureLargerStackTrace(this);\n\n    this.code = key;\n\n    ObjectDefineProperties(this\x2C {\n      [kIsNodeError]: {\n        value: true\x2C\n        enumerable: false\x2C\n        writable: false\x2C\n        configurable: true\x2C\n      }\x2C\n      name: {\n        value: 'SystemError'\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      message: {\n        value: message\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      info: {\n        value: context\x2C\n        enumerable: true\x2C\n        configurable: true\x2C\n        writable: false\x2C\n      }\x2C\n      errno: {\n        get() {\n          return context.errno;\n        }\x2C\n        set: (value) => {\n          context.errno = value;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      syscall: {\n        get() {\n          return context.syscall;\n        }\x2C\n        set: (value) => {\n          context.syscall = value;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\x2C\n      }\x2C\n    });\n\n    if (context.path !== undefined) {\n      // TODO(BridgeAR): Investigate why and when the `.toString()` was\n      // introduced. The `path` and `dest` properties in the context seem to\n      // always be of type string. We should probably just remove the\n      // `.toString()` and `Buffer.from()` operations and set the value on the\n      // context as the user did.\n      ObjectDefineProperty(this\x2C 'path'\x2C {\n        get() {\n          return context.path != null ?\n            context.path.toString() : context.path;\n        }\x2C\n        set: (value) => {\n          context.path = value ?\n            lazyBuffer().from(value.toString()) : undefined;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\n      });\n    }\n\n    if (context.dest !== undefined) {\n      ObjectDefineProperty(this\x2C 'dest'\x2C {\n        get() {\n          return context.dest != null ?\n            context.dest.toString() : context.dest;\n        }\x2C\n        set: (value) => {\n          context.dest = value ?\n            lazyBuffer().from(value.toString()) : undefined;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\n      });\n    }\n  }\n\n  toString() {\n    return `${this.name} [${this.code}]: ${this.message}`;\n  }\n\n  [SymbolFor('nodejs.util.inspect.custom')](recurseTimes\x2C ctx) {\n    return lazyInternalUtilInspect().inspect(this\x2C {\n      ...ctx\x2C\n      getters: true\x2C\n      customInspect: false\n    });\n  }\n}\n\nfunction makeSystemErrorWithCode(key) {\n  return class NodeError extends SystemError {\n    constructor(ctx) {\n      super(key\x2C ctx);\n    }\n  };\n}\n\nfunction makeNodeErrorWithCode(Base\x2C key) {\n  return function NodeError(...args) {\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    const error = new Base();\n    // Reset the limit and setting the name property.\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n    const message = getMessage(key\x2C args\x2C error);\n    ObjectDefineProperties(error\x2C {\n      [kIsNodeError]: {\n        value: true\x2C\n        enumerable: false\x2C\n        writable: false\x2C\n        configurable: true\x2C\n      }\x2C\n      message: {\n        value: message\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      toString: {\n        value() {\n          return `${this.name} [${key}]: ${this.message}`;\n        }\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n    });\n    captureLargerStackTrace(error);\n    error.code = key;\n    return error;\n  };\n}\n\n/**\n * This function removes unnecessary frames from Node.js core errors.\n * @template {(...args: any[]) => any} T\n * @type {(fn: T) => T}\n */\nfunction hideStackFrames(fn) {\n  // We rename the functions that will be hidden to cut off the stacktrace\n  // at the outermost one\n  const hidden = nodeInternalPrefix + fn.name;\n  ObjectDefineProperty(fn\x2C 'name'\x2C { value: hidden });\n  return fn;\n}\n\n// Utility function for registering the error codes. Only used here. Exported\n// *only* to allow for testing.\nfunction E(sym\x2C val\x2C def\x2C ...otherClasses) {\n  // Special case for SystemError that formats the error message differently\n  // The SystemErrors only have SystemError as their base classes.\n  messages.set(sym\x2C val);\n  if (def === SystemError) {\n    def = makeSystemErrorWithCode(sym);\n  } else {\n    def = makeNodeErrorWithCode(def\x2C sym);\n  }\n\n  if (otherClasses.length !== 0) {\n    otherClasses.forEach((clazz) => {\n      def[clazz.name] = makeNodeErrorWithCode(clazz\x2C sym);\n    });\n  }\n  codes[sym] = def;\n}\n\nfunction getMessage(key\x2C args\x2C self) {\n  const msg = messages.get(key);\n\n  if (assert === undefined) assert = require('internal/assert');\n\n  if (typeof msg === 'function') {\n    assert(\n      msg.length <= args.length\x2C // Default options do not count.\n      `Code: ${key}; The provided arguments length (${args.length}) does not ` +\n        `match the required ones (${msg.length}).`\n    );\n    return ReflectApply(msg\x2C self\x2C args);\n  }\n\n  const expectedLength =\n    (StringPrototypeMatch(msg\x2C /%[dfijoOs]/g) || []).length;\n  assert(\n    expectedLength === args.length\x2C\n    `Code: ${key}; The provided arguments length (${args.length}) does not ` +\n      `match the required ones (${expectedLength}).`\n  );\n  if (args.length === 0)\n    return msg;\n\n  ArrayPrototypeUnshift(args\x2C msg);\n  return ReflectApply(lazyInternalUtilInspect().format\x2C null\x2C args);\n}\n\nlet uvBinding;\n\nfunction lazyUv() {\n  if (!uvBinding) {\n    uvBinding = internalBinding('uv');\n  }\n  return uvBinding;\n}\n\nconst uvUnmappedError = ['UNKNOWN'\x2C 'unknown error'];\n\nfunction uvErrmapGet(name) {\n  uvBinding = lazyUv();\n  if (!uvBinding.errmap) {\n    uvBinding.errmap = uvBinding.getErrorMap();\n  }\n  return MapPrototypeGet(uvBinding.errmap\x2C name);\n}\n\nconst captureLargerStackTrace = hideStackFrames(\n  function captureLargerStackTrace(err) {\n    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();\n    if (stackTraceLimitIsWritable) {\n      userStackTraceLimit = Error.stackTraceLimit;\n      Error.stackTraceLimit = Infinity;\n    }\n    ErrorCaptureStackTrace(err);\n    // Reset the limit\n    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;\n\n    return err;\n  });\n\n/**\n * This creates an error compatible with errors produced in the C++\n * function UVException using a context object with data assembled in C++.\n * The goal is to migrate them to ERR_* errors later when compatibility is\n * not a concern.\n *\n * @param {Object} ctx\n * @returns {Error}\n */\nconst uvException = hideStackFrames(function uvException(ctx) {\n  const { 0: code\x2C 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;\n  let message = `${code}: ${ctx.message || uvmsg}\x2C ${ctx.syscall}`;\n\n  let path;\n  let dest;\n  if (ctx.path) {\n    path = ctx.path.toString();\n    message += ` '${path}'`;\n  }\n  if (ctx.dest) {\n    dest = ctx.dest.toString();\n    message += ` -> '${dest}'`;\n  }\n\n  // Reducing the limit improves the performance significantly. We do not lose\n  // the stack frames due to the `captureStackTrace()` function that is called\n  // later.\n  const tmpLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n  // Pass the message to the constructor instead of setting it on the object\n  // to make sure it is the same as the one created in C++\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n\n  for (const prop of ObjectKeys(ctx)) {\n    if (prop === 'message' || prop === 'path' || prop === 'dest') {\n      continue;\n    }\n    err[prop] = ctx[prop];\n  }\n\n  err.code = code;\n  if (path) {\n    err.path = path;\n  }\n  if (dest) {\n    err.dest = dest;\n  }\n\n  return captureLargerStackTrace(err);\n});\n\n/**\n * This creates an error compatible with errors produced in the C++\n * This function should replace the deprecated\n * `exceptionWithHostPort()` function.\n *\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} address\n * @param {number} [port]\n * @returns {Error}\n */\nconst uvExceptionWithHostPort = hideStackFrames(\n  function uvExceptionWithHostPort(err\x2C syscall\x2C address\x2C port) {\n    const { 0: code\x2C 1: uvmsg } = uvErrmapGet(err) || uvUnmappedError;\n    const message = `${syscall} ${code}: ${uvmsg}`;\n    let details = '';\n\n    if (port && port > 0) {\n      details = ` ${address}:${port}`;\n    } else if (address) {\n      details = ` ${address}`;\n    }\n\n    // Reducing the limit improves the performance significantly. We do not\n    // lose the stack frames due to the `captureStackTrace()` function that\n    // is called later.\n    const tmpLimit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    const ex = new Error(`${message}${details}`);\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n    ex.code = code;\n    ex.errno = err;\n    ex.syscall = syscall;\n    ex.address = address;\n    if (port) {\n      ex.port = port;\n    }\n\n    return captureLargerStackTrace(ex);\n  });\n\n/**\n * This used to be util._errnoException().\n *\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} [original]\n * @returns {Error}\n */\nconst errnoException = hideStackFrames(\n  function errnoException(err\x2C syscall\x2C original) {\n    // TODO(joyeecheung): We have to use the type-checked\n    // getSystemErrorName(err) to guard against invalid arguments from users.\n    // This can be replaced with [ code ] = errmap.get(err) when this method\n    // is no longer exposed to user land.\n    if (util === undefined) util = require('util');\n    const code = util.getSystemErrorName(err);\n    const message = original ?\n      `${syscall} ${code} ${original}` : `${syscall} ${code}`;\n\n    const tmpLimit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    const ex = new Error(message);\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n    ex.errno = err;\n    ex.code = code;\n    ex.syscall = syscall;\n\n    return captureLargerStackTrace(ex);\n  });\n\n/**\n * Deprecated\x2C new function is `uvExceptionWithHostPort()`\n * New function added the error description directly\n * from C++. this method for backwards compatibility\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} address\n * @param {number} [port]\n * @param {string} [additional]\n * @returns {Error}\n */\nconst exceptionWithHostPort = hideStackFrames(\n  function exceptionWithHostPort(err\x2C syscall\x2C address\x2C port\x2C additional) {\n    // TODO(joyeecheung): We have to use the type-checked\n    // getSystemErrorName(err) to guard against invalid arguments from users.\n    // This can be replaced with [ code ] = errmap.get(err) when this method\n    // is no longer exposed to user land.\n    if (util === undefined) util = require('util');\n    const code = util.getSystemErrorName(err);\n    let details = '';\n    if (port && port > 0) {\n      details = ` ${address}:${port}`;\n    } else if (address) {\n      details = ` ${address}`;\n    }\n    if (additional) {\n      details += ` - Local (${additional})`;\n    }\n\n    // Reducing the limit improves the performance significantly. We do not\n    // lose the stack frames due to the `captureStackTrace()` function that\n    // is called later.\n    const tmpLimit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    const ex = new Error(`${syscall} ${code}${details}`);\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n    ex.errno = err;\n    ex.code = code;\n    ex.syscall = syscall;\n    ex.address = address;\n    if (port) {\n      ex.port = port;\n    }\n\n    return captureLargerStackTrace(ex);\n  });\n\n/**\n * @param {number|string} code - A libuv error number or a c-ares error code\n * @param {string} syscall\n * @param {string} [hostname]\n * @returns {Error}\n */\nconst dnsException = hideStackFrames(function(code\x2C syscall\x2C hostname) {\n  let errno;\n  // If `code` is of type number\x2C it is a libuv error number\x2C else it is a\n  // c-ares error code.\n  // TODO(joyeecheung): translate c-ares error codes into numeric ones and\n  // make them available in a property that's not error.errno (since they\n  // can be in conflict with libuv error codes). Also make sure\n  // util.getSystemErrorName() can understand them when an being informed that\n  // the number is a c-ares error code.\n  if (typeof code === 'number') {\n    errno = code;\n    // ENOTFOUND is not a proper POSIX error\x2C but this error has been in place\n    // long enough that it's not practical to remove it.\n    if (code === lazyUv().UV_EAI_NODATA || code === lazyUv().UV_EAI_NONAME) {\n      code = 'ENOTFOUND'; // Fabricated error name.\n    } else {\n      code = lazyInternalUtil().getSystemErrorName(code);\n    }\n  }\n  const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ''}`;\n  // Reducing the limit improves the performance significantly. We do not lose\n  // the stack frames due to the `captureStackTrace()` function that is called\n  // later.\n  const tmpLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n  // eslint-disable-next-line no-restricted-syntax\n  const ex = new Error(message);\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n  ex.errno = errno;\n  ex.code = code;\n  ex.syscall = syscall;\n  if (hostname) {\n    ex.hostname = hostname;\n  }\n\n  return captureLargerStackTrace(ex);\n});\n\nfunction connResetException(msg) {\n  // eslint-disable-next-line no-restricted-syntax\n  const ex = new Error(msg);\n  ex.code = 'ECONNRESET';\n  return ex;\n}\n\nlet maxStack_ErrorName;\nlet maxStack_ErrorMessage;\n/**\n * Returns true if `err.name` and `err.message` are equal to engine-specific\n * values indicating max call stack size has been exceeded.\n * "Maximum call stack size exceeded" in V8.\n *\n * @param {Error} err\n * @returns {boolean}\n */\nfunction isStackOverflowError(err) {\n  if (maxStack_ErrorMessage === undefined) {\n    try {\n      function overflowStack() { overflowStack(); }\n      overflowStack();\n    } catch (err) {\n      maxStack_ErrorMessage = err.message;\n      maxStack_ErrorName = err.name;\n    }\n  }\n\n  return err && err.name === maxStack_ErrorName &&\n         err.message === maxStack_ErrorMessage;\n}\n\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n  let res = '';\n  let i = val.length;\n  const start = val[0] === '-' ? 1 : 0;\n  for (; i >= start + 4; i -= 3) {\n    res = `_${StringPrototypeSlice(val\x2C i - 3\x2C i)}${res}`;\n  }\n  return `${StringPrototypeSlice(val\x2C 0\x2C i)}${res}`;\n}\n\n// Used to enhance the stack that will be picked up by the inspector\nconst kEnhanceStackBeforeInspector = Symbol('kEnhanceStackBeforeInspector');\n\n// These are supposed to be called only on fatal exceptions before\n// the process exits.\nconst fatalExceptionStackEnhancers = {\n  beforeInspector(error) {\n    if (typeof error[kEnhanceStackBeforeInspector] !== 'function') {\n      return error.stack;\n    }\n\n    try {\n      // Set the error.stack here so it gets picked up by the\n      // inspector.\n      error.stack = error[kEnhanceStackBeforeInspector]();\n    } catch {\n      // We are just enhancing the error. If it fails\x2C ignore it.\n    }\n    return error.stack;\n  }\x2C\n  afterInspector(error) {\n    const originalStack = error.stack;\n    let useColors = true;\n    // Some consoles do not convert ANSI escape sequences to colors\x2C\n    // rather display them directly to the stdout. On those consoles\x2C\n    // libuv emulates colors by intercepting stdout stream and calling\n    // corresponding Windows API functions for setting console colors.\n    // However\x2C fatal error are handled differently and we cannot easily\n    // highlight them. On Windows\x2C detecting whether a console supports\n    // ANSI escape sequences is not reliable.\n    if (process.platform === 'win32') {\n      const info = internalBinding('os').getOSInformation();\n      const ver = ArrayPrototypeMap(StringPrototypeSplit(info[2]\x2C '.')\x2C\n                                    Number);\n      if (ver[0] !== 10 || ver[2] < 14393) {\n        useColors = false;\n      }\n    }\n    const {\n      inspect\x2C\n      inspectDefaultOptions: {\n        colors: defaultColors\n      }\n    } = lazyInternalUtilInspect();\n    const colors = useColors &&\n                   ((internalBinding('util').guessHandleType(2) === 'TTY' &&\n                   require('internal/tty').hasColors()) ||\n                   defaultColors);\n    try {\n      return inspect(error\x2C {\n        colors\x2C\n        customInspect: false\x2C\n        depth: MathMax(inspect.defaultOptions.depth\x2C 5)\n      });\n    } catch {\n      return originalStack;\n    }\n  }\n};\n\n// Ensures the printed error line is from user code.\nlet _kArrowMessagePrivateSymbol\x2C _setHiddenValue;\nfunction setArrowMessage(err\x2C arrowMessage) {\n  if (!_kArrowMessagePrivateSymbol) {\n    ({\n      arrow_message_private_symbol: _kArrowMessagePrivateSymbol\x2C\n      setHiddenValue: _setHiddenValue\x2C\n    } = internalBinding('util'));\n  }\n  _setHiddenValue(err\x2C _kArrowMessagePrivateSymbol\x2C arrowMessage);\n}\n\n// Hide stack lines before the first user code line.\nfunction hideInternalStackFrames(error) {\n  overrideStackTrace.set(error\x2C (error\x2C stackFrames) => {\n    let frames = stackFrames;\n    if (typeof stackFrames === 'object') {\n      frames = ArrayPrototypeFilter(\n        stackFrames\x2C\n        (frm) => !StringPrototypeStartsWith(frm.getFileName() || ''\x2C\n                                            'node:internal')\n      );\n    }\n    ArrayPrototypeUnshift(frames\x2C error);\n    return ArrayPrototypeJoin(frames\x2C '\\n    at ');\n  });\n}\n\n// Node uses an AbortError that isn't exactly the same as the DOMException\n// to make usage of the error in userland and readable-stream easier.\n// It is a regular error with `.code` and `.name`.\nclass AbortError extends Error {\n  constructor() {\n    super('The operation was aborted');\n    this.code = 'ABORT_ERR';\n    this.name = 'AbortError';\n  }\n}\nmodule.exports = {\n  aggregateTwoErrors\x2C\n  codes\x2C\n  dnsException\x2C\n  errnoException\x2C\n  exceptionWithHostPort\x2C\n  getMessage\x2C\n  hideStackFrames\x2C\n  hideInternalStackFrames\x2C\n  isErrorStackTraceLimitWritable\x2C\n  isStackOverflowError\x2C\n  setArrowMessage\x2C\n  connResetException\x2C\n  uvErrmapGet\x2C\n  uvException\x2C\n  uvExceptionWithHostPort\x2C\n  SystemError\x2C\n  AbortError\x2C\n  // This is exported only to facilitate testing.\n  E\x2C\n  kNoOverride\x2C\n  prepareStackTrace\x2C\n  maybeOverridePrepareStackTrace\x2C\n  overrideStackTrace\x2C\n  kEnhanceStackBeforeInspector\x2C\n  fatalExceptionStackEnhancers\x2C\n  kIsNodeError\x2C\n  captureLargerStackTrace\x2C\n};\n\n// To declare an error message\x2C use the E(sym\x2C val\x2C def) function above. The sym\n// must be an upper case string. The val can be either a function or a string.\n// The def must be an error class.\n// The return value of the function must be a string.\n// Examples:\n// E('EXAMPLE_KEY1'\x2C 'This is the error value'\x2C Error);\n// E('EXAMPLE_KEY2'\x2C (a\x2C b) => return `${a} ${b}`\x2C RangeError);\n//\n// Once an error code has been assigned\x2C the code itself MUST NOT change and\n// any given error code must never be reused to identify a different error.\n//\n// Any error code added here should also be added to the documentation\n//\n// Note: Please try to keep these in alphabetical order\n//\n// Note: Node.js specific errors must begin with the prefix ERR_\n\nE('ERR_AMBIGUOUS_ARGUMENT'\x2C 'The "%s" argument is ambiguous. %s'\x2C TypeError);\nE('ERR_ARG_NOT_ITERABLE'\x2C '%s must be iterable'\x2C TypeError);\nE('ERR_ASSERTION'\x2C '%s'\x2C Error);\nE('ERR_ASYNC_CALLBACK'\x2C '%s must be a function'\x2C TypeError);\nE('ERR_ASYNC_TYPE'\x2C 'Invalid name for async "type": %s'\x2C TypeError);\nE('ERR_BROTLI_INVALID_PARAM'\x2C '%s is not a valid Brotli parameter'\x2C RangeError);\nE('ERR_BUFFER_OUT_OF_BOUNDS'\x2C\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (name = undefined) => {\n    if (name) {\n      return `"${name}" is outside of buffer bounds`;\n    }\n    return 'Attempt to access memory outside buffer bounds';\n  }\x2C RangeError);\nE('ERR_BUFFER_TOO_LARGE'\x2C\n  'Cannot create a Buffer larger than %s bytes'\x2C\n  RangeError);\nE('ERR_CANNOT_WATCH_SIGINT'\x2C 'Cannot watch for SIGINT signals'\x2C Error);\nE('ERR_CHILD_CLOSED_BEFORE_REPLY'\x2C\n  'Child closed before reply received'\x2C Error);\nE('ERR_CHILD_PROCESS_IPC_REQUIRED'\x2C\n  "Forked processes must have an IPC channel\x2C missing value 'ipc' in %s"\x2C\n  Error);\nE('ERR_CHILD_PROCESS_STDIO_MAXBUFFER'\x2C '%s maxBuffer length exceeded'\x2C\n  RangeError);\nE('ERR_CONSOLE_WRITABLE_STREAM'\x2C\n  'Console expects a writable stream instance for %s'\x2C TypeError);\nE('ERR_CONTEXT_NOT_INITIALIZED'\x2C 'context used is not initialized'\x2C Error);\nE('ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED'\x2C\n  'Custom engines not supported by this OpenSSL'\x2C Error);\nE('ERR_CRYPTO_ECDH_INVALID_FORMAT'\x2C 'Invalid ECDH format: %s'\x2C TypeError);\nE('ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY'\x2C\n  'Public key is not valid for specified curve'\x2C Error);\nE('ERR_CRYPTO_ENGINE_UNKNOWN'\x2C 'Engine "%s" was not found'\x2C Error);\nE('ERR_CRYPTO_FIPS_FORCED'\x2C\n  'Cannot set FIPS mode\x2C it was forced with --force-fips at startup.'\x2C Error);\nE('ERR_CRYPTO_FIPS_UNAVAILABLE'\x2C 'Cannot set FIPS mode in a non-FIPS build.'\x2C\n  Error);\nE('ERR_CRYPTO_HASH_FINALIZED'\x2C 'Digest already called'\x2C Error);\nE('ERR_CRYPTO_HASH_UPDATE_FAILED'\x2C 'Hash update failed'\x2C Error);\nE('ERR_CRYPTO_INCOMPATIBLE_KEY'\x2C 'Incompatible %s: %s'\x2C Error);\nE('ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS'\x2C 'The selected key encoding %s %s.'\x2C\n  Error);\nE('ERR_CRYPTO_INVALID_DIGEST'\x2C 'Invalid digest: %s'\x2C TypeError);\nE('ERR_CRYPTO_INVALID_JWK'\x2C 'Invalid JWK data'\x2C TypeError);\nE('ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE'\x2C\n  'Invalid key object type %s\x2C expected %s.'\x2C TypeError);\nE('ERR_CRYPTO_INVALID_STATE'\x2C 'Invalid state for operation %s'\x2C Error);\nE('ERR_CRYPTO_PBKDF2_ERROR'\x2C 'PBKDF2 error'\x2C Error);\nE('ERR_CRYPTO_SCRYPT_INVALID_PARAMETER'\x2C 'Invalid scrypt parameter'\x2C Error);\nE('ERR_CRYPTO_SCRYPT_NOT_SUPPORTED'\x2C 'Scrypt algorithm not supported'\x2C Error);\n// Switch to TypeError. The current implementation does not seem right.\nE('ERR_CRYPTO_SIGN_KEY_REQUIRED'\x2C 'No key provided to sign'\x2C Error);\nE('ERR_DEBUGGER_ERROR'\x2C '%s'\x2C Error);\nE('ERR_DEBUGGER_STARTUP_ERROR'\x2C '%s'\x2C Error);\nE('ERR_DIR_CLOSED'\x2C 'Directory handle was closed'\x2C Error);\nE('ERR_DIR_CONCURRENT_OPERATION'\x2C\n  'Cannot do synchronous work on directory handle with concurrent ' +\n  'asynchronous operations'\x2C Error);\nE('ERR_DNS_SET_SERVERS_FAILED'\x2C 'c-ares failed to set servers: "%s" [%s]'\x2C\n  Error);\nE('ERR_DOMAIN_CALLBACK_NOT_AVAILABLE'\x2C\n  'A callback was registered through ' +\n     'process.setUncaughtExceptionCaptureCallback()\x2C which is mutually ' +\n     'exclusive with using the `domain` module'\x2C\n  Error);\nE('ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE'\x2C\n  'The `domain` module is in use\x2C which is mutually exclusive with calling ' +\n     'process.setUncaughtExceptionCaptureCallback()'\x2C\n  Error);\nE('ERR_ENCODING_INVALID_ENCODED_DATA'\x2C function(encoding\x2C ret) {\n  this.errno = ret;\n  return `The encoded data was not valid for encoding ${encoding}`;\n}\x2C TypeError);\nE('ERR_ENCODING_NOT_SUPPORTED'\x2C 'The "%s" encoding is not supported'\x2C\n  RangeError);\nE('ERR_EVAL_ESM_CANNOT_PRINT'\x2C '--print cannot be used with ESM input'\x2C Error);\nE('ERR_EVENT_RECURSION'\x2C 'The event "%s" is already being dispatched'\x2C Error);\nE('ERR_FALSY_VALUE_REJECTION'\x2C function(reason) {\n  this.reason = reason;\n  return 'Promise was rejected with falsy value';\n}\x2C Error);\nE('ERR_FEATURE_UNAVAILABLE_ON_PLATFORM'\x2C\n  'The feature %s is unavailable on the current platform' +\n  '\x2C which is being used to run Node.js'\x2C\n  TypeError);\nE('ERR_FS_CP_DIR_TO_NON_DIR'\x2C\n  'Cannot overwrite directory with non-directory'\x2C SystemError);\nE('ERR_FS_CP_EEXIST'\x2C 'Target already exists'\x2C SystemError);\nE('ERR_FS_CP_EINVAL'\x2C 'Invalid src or dest'\x2C SystemError);\nE('ERR_FS_CP_FIFO_PIPE'\x2C 'Cannot copy a FIFO pipe'\x2C SystemError);\nE('ERR_FS_CP_NON_DIR_TO_DIR'\x2C\n  'Cannot overwrite non-directory with directory'\x2C SystemError);\nE('ERR_FS_CP_SOCKET'\x2C 'Cannot copy a socket file'\x2C SystemError);\nE('ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY'\x2C\n  'Cannot overwrite symlink in subdirectory of self'\x2C SystemError);\nE('ERR_FS_CP_UNKNOWN'\x2C 'Cannot copy an unknown file type'\x2C SystemError);\nE('ERR_FS_EISDIR'\x2C 'Path is a directory'\x2C SystemError);\nE('ERR_FS_FILE_TOO_LARGE'\x2C 'File size (%s) is greater than 2 GB'\x2C RangeError);\nE('ERR_FS_INVALID_SYMLINK_TYPE'\x2C\n  'Symlink type must be one of "dir"\x2C "file"\x2C or "junction". Received "%s"'\x2C\n  Error); // Switch to TypeError. The current implementation does not seem right\nE('ERR_HTTP2_ALTSVC_INVALID_ORIGIN'\x2C\n  'HTTP/2 ALTSVC frames require a valid origin'\x2C TypeError);\nE('ERR_HTTP2_ALTSVC_LENGTH'\x2C\n  'HTTP/2 ALTSVC frames are limited to 16382 bytes'\x2C TypeError);\nE('ERR_HTTP2_CONNECT_AUTHORITY'\x2C\n  ':authority header is required for CONNECT requests'\x2C Error);\nE('ERR_HTTP2_CONNECT_PATH'\x2C\n  'The :path header is forbidden for CONNECT requests'\x2C Error);\nE('ERR_HTTP2_CONNECT_SCHEME'\x2C\n  'The :scheme header is forbidden for CONNECT requests'\x2C Error);\nE('ERR_HTTP2_GOAWAY_SESSION'\x2C\n  'New streams cannot be created after receiving a GOAWAY'\x2C Error);\nE('ERR_HTTP2_HEADERS_AFTER_RESPOND'\x2C\n  'Cannot specify additional headers after response initiated'\x2C Error);\nE('ERR_HTTP2_HEADERS_SENT'\x2C 'Response has already been initiated.'\x2C Error);\nE('ERR_HTTP2_HEADER_SINGLE_VALUE'\x2C\n  'Header field "%s" must only have a single value'\x2C TypeError);\nE('ERR_HTTP2_INFO_STATUS_NOT_ALLOWED'\x2C\n  'Informational status codes cannot be used'\x2C RangeError);\nE('ERR_HTTP2_INVALID_CONNECTION_HEADERS'\x2C\n  'HTTP/1 Connection specific headers are forbidden: "%s"'\x2C TypeError);\nE('ERR_HTTP2_INVALID_HEADER_VALUE'\x2C\n  'Invalid value "%s" for header "%s"'\x2C TypeError);\nE('ERR_HTTP2_INVALID_INFO_STATUS'\x2C\n  'Invalid informational status code: %s'\x2C RangeError);\nE('ERR_HTTP2_INVALID_ORIGIN'\x2C\n  'HTTP/2 ORIGIN frames require a valid origin'\x2C TypeError);\nE('ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH'\x2C\n  'Packed settings length must be a multiple of six'\x2C RangeError);\nE('ERR_HTTP2_INVALID_PSEUDOHEADER'\x2C\n  '"%s" is an invalid pseudoheader or is used incorrectly'\x2C TypeError);\nE('ERR_HTTP2_INVALID_SESSION'\x2C 'The session has been destroyed'\x2C Error);\nE('ERR_HTTP2_INVALID_SETTING_VALUE'\x2C\n  // Using default arguments here is important so the arguments are not counted\n  // towards `Function#length`.\n  function(name\x2C actual\x2C min = undefined\x2C max = undefined) {\n    this.actual = actual;\n    if (min !== undefined) {\n      this.min = min;\n      this.max = max;\n    }\n    return `Invalid value for setting "${name}": ${actual}`;\n  }\x2C TypeError\x2C RangeError);\nE('ERR_HTTP2_INVALID_STREAM'\x2C 'The stream has been destroyed'\x2C Error);\nE('ERR_HTTP2_MAX_PENDING_SETTINGS_ACK'\x2C\n  'Maximum number of pending settings acknowledgements'\x2C Error);\nE('ERR_HTTP2_NESTED_PUSH'\x2C\n  'A push stream cannot initiate another push stream.'\x2C Error);\nE('ERR_HTTP2_NO_MEM'\x2C 'Out of memory'\x2C Error);\nE('ERR_HTTP2_NO_SOCKET_MANIPULATION'\x2C\n  'HTTP/2 sockets should not be directly manipulated (e.g. read and written)'\x2C\n  Error);\nE('ERR_HTTP2_ORIGIN_LENGTH'\x2C\n  'HTTP/2 ORIGIN frames are limited to 16382 bytes'\x2C TypeError);\nE('ERR_HTTP2_OUT_OF_STREAMS'\x2C\n  'No stream ID is available because maximum stream ID has been reached'\x2C\n  Error);\nE('ERR_HTTP2_PAYLOAD_FORBIDDEN'\x2C\n  'Responses with %s status must not have a payload'\x2C Error);\nE('ERR_HTTP2_PING_CANCEL'\x2C 'HTTP2 ping cancelled'\x2C Error);\nE('ERR_HTTP2_PING_LENGTH'\x2C 'HTTP2 ping payload must be 8 bytes'\x2C RangeError);\nE('ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED'\x2C\n  'Cannot set HTTP/2 pseudo-headers'\x2C TypeError);\nE('ERR_HTTP2_PUSH_DISABLED'\x2C 'HTTP/2 client has disabled push streams'\x2C Error);\nE('ERR_HTTP2_SEND_FILE'\x2C 'Directories cannot be sent'\x2C Error);\nE('ERR_HTTP2_SEND_FILE_NOSEEK'\x2C\n  'Offset or length can only be specified for regular files'\x2C Error);\nE('ERR_HTTP2_SESSION_ERROR'\x2C 'Session closed with error code %s'\x2C Error);\nE('ERR_HTTP2_SETTINGS_CANCEL'\x2C 'HTTP2 session settings canceled'\x2C Error);\nE('ERR_HTTP2_SOCKET_BOUND'\x2C\n  'The socket is already bound to an Http2Session'\x2C Error);\nE('ERR_HTTP2_SOCKET_UNBOUND'\x2C\n  'The socket has been disconnected from the Http2Session'\x2C Error);\nE('ERR_HTTP2_STATUS_101'\x2C\n  'HTTP status code 101 (Switching Protocols) is forbidden in HTTP/2'\x2C Error);\nE('ERR_HTTP2_STATUS_INVALID'\x2C 'Invalid status code: %s'\x2C RangeError);\nE('ERR_HTTP2_STREAM_CANCEL'\x2C function(error) {\n  let msg = 'The pending stream has been canceled';\n  if (error) {\n    this.cause = error;\n    if (typeof error.message === 'string')\n      msg += ` (caused by: ${error.message})`;\n  }\n  return msg;\n}\x2C Error);\nE('ERR_HTTP2_STREAM_ERROR'\x2C 'Stream closed with error code %s'\x2C Error);\nE('ERR_HTTP2_STREAM_SELF_DEPENDENCY'\x2C\n  'A stream cannot depend on itself'\x2C Error);\nE('ERR_HTTP2_TOO_MANY_INVALID_FRAMES'\x2C 'Too many invalid HTTP/2 frames'\x2C Error);\nE('ERR_HTTP2_TRAILERS_ALREADY_SENT'\x2C\n  'Trailing headers have already been sent'\x2C Error);\nE('ERR_HTTP2_TRAILERS_NOT_READY'\x2C\n  'Trailing headers cannot be sent until after the wantTrailers event is ' +\n  'emitted'\x2C Error);\nE('ERR_HTTP2_UNSUPPORTED_PROTOCOL'\x2C 'protocol "%s" is unsupported.'\x2C Error);\nE('ERR_HTTP_HEADERS_SENT'\x2C\n  'Cannot %s headers after they are sent to the client'\x2C Error);\nE('ERR_HTTP_INVALID_HEADER_VALUE'\x2C\n  'Invalid value "%s" for header "%s"'\x2C TypeError);\nE('ERR_HTTP_INVALID_STATUS_CODE'\x2C 'Invalid status code: %s'\x2C RangeError);\nE('ERR_HTTP_REQUEST_TIMEOUT'\x2C 'Request timeout'\x2C Error);\nE('ERR_HTTP_SOCKET_ENCODING'\x2C\n  'Changing the socket encoding is not allowed per RFC7230 Section 3.'\x2C Error);\nE('ERR_HTTP_TRAILER_INVALID'\x2C\n  'Trailers are invalid with this transfer encoding'\x2C Error);\nE('ERR_ILLEGAL_CONSTRUCTOR'\x2C 'Illegal constructor'\x2C TypeError);\nE('ERR_INCOMPATIBLE_OPTION_PAIR'\x2C\n  'Option "%s" cannot be used in combination with option "%s"'\x2C TypeError);\nE('ERR_INPUT_TYPE_NOT_ALLOWED'\x2C '--input-type can only be used with string ' +\n  'input via --eval\x2C --print\x2C or STDIN'\x2C Error);\nE('ERR_INSPECTOR_ALREADY_ACTIVATED'\x2C\n  'Inspector is already activated. Close it with inspector.close() ' +\n  'before activating it again.'\x2C\n  Error);\nE('ERR_INSPECTOR_ALREADY_CONNECTED'\x2C '%s is already connected'\x2C Error);\nE('ERR_INSPECTOR_CLOSED'\x2C 'Session was closed'\x2C Error);\nE('ERR_INSPECTOR_COMMAND'\x2C 'Inspector error %d: %s'\x2C Error);\nE('ERR_INSPECTOR_NOT_ACTIVE'\x2C 'Inspector is not active'\x2C Error);\nE('ERR_INSPECTOR_NOT_AVAILABLE'\x2C 'Inspector is not available'\x2C Error);\nE('ERR_INSPECTOR_NOT_CONNECTED'\x2C 'Session is not connected'\x2C Error);\nE('ERR_INSPECTOR_NOT_WORKER'\x2C 'Current thread is not a worker'\x2C Error);\nE('ERR_INTERNAL_ASSERTION'\x2C (message) => {\n  const suffix = 'This is caused by either a bug in Node.js ' +\n    'or incorrect usage of Node.js internals.\\n' +\n    'Please open an issue with this stack trace at ' +\n    'https://github.com/nodejs/node/issues\\n';\n  return message === undefined ? suffix : `${message}\\n${suffix}`;\n}\x2C Error);\nE('ERR_INVALID_ADDRESS_FAMILY'\x2C function(addressType\x2C host\x2C port) {\n  this.host = host;\n  this.port = port;\n  return `Invalid address family: ${addressType} ${host}:${port}`;\n}\x2C RangeError);\nE('ERR_INVALID_ARG_TYPE'\x2C\n  (name\x2C expected\x2C actual) => {\n    assert(typeof name === 'string'\x2C "'name' must be a string");\n    if (!ArrayIsArray(expected)) {\n      expected = [expected];\n    }\n\n    let msg = 'The ';\n    if (StringPrototypeEndsWith(name\x2C ' argument')) {\n      // For cases like 'first argument'\n      msg += `${name} `;\n    } else {\n      const type = StringPrototypeIncludes(name\x2C '.') ? 'property' : 'argument';\n      msg += `"${name}" ${type} `;\n    }\n    msg += 'must be ';\n\n    const types = [];\n    const instances = [];\n    const other = [];\n\n    for (const value of expected) {\n      assert(typeof value === 'string'\x2C\n             'All expected entries have to be of type string');\n      if (ArrayPrototypeIncludes(kTypes\x2C value)) {\n        ArrayPrototypePush(types\x2C StringPrototypeToLowerCase(value));\n      } else if (RegExpPrototypeTest(classRegExp\x2C value)) {\n        ArrayPrototypePush(instances\x2C value);\n      } else {\n        assert(value !== 'object'\x2C\n               'The value "object" should be written as "Object"');\n        ArrayPrototypePush(other\x2C value);\n      }\n    }\n\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n      const pos = ArrayPrototypeIndexOf(types\x2C 'object');\n      if (pos !== -1) {\n        ArrayPrototypeSplice(types\x2C pos\x2C 1);\n        ArrayPrototypePush(instances\x2C 'Object');\n      }\n    }\n\n    if (types.length > 0) {\n      if (types.length > 2) {\n        const last = ArrayPrototypePop(types);\n        msg += `one of type ${ArrayPrototypeJoin(types\x2C '\x2C ')}\x2C or ${last}`;\n      } else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}`;\n      } else {\n        msg += `of type ${types[0]}`;\n      }\n      if (instances.length > 0 || other.length > 0)\n        msg += ' or ';\n    }\n\n    if (instances.length > 0) {\n      if (instances.length > 2) {\n        const last = ArrayPrototypePop(instances);\n        msg +=\n          `an instance of ${ArrayPrototypeJoin(instances\x2C '\x2C ')}\x2C or ${last}`;\n      } else {\n        msg += `an instance of ${instances[0]}`;\n        if (instances.length === 2) {\n          msg += ` or ${instances[1]}`;\n        }\n      }\n      if (other.length > 0)\n        msg += ' or ';\n    }\n\n    if (other.length > 0) {\n      if (other.length > 2) {\n        const last = ArrayPrototypePop(other);\n        msg += `one of ${ArrayPrototypeJoin(other\x2C '\x2C ')}\x2C or ${last}`;\n      } else if (other.length === 2) {\n        msg += `one of ${other[0]} or ${other[1]}`;\n      } else {\n        if (StringPrototypeToLowerCase(other[0]) !== other[0])\n          msg += 'an ';\n        msg += `${other[0]}`;\n      }\n    }\n\n    if (actual == null) {\n      msg += `. Received ${actual}`;\n    } else if (typeof actual === 'function' && actual.name) {\n      msg += `. Received function ${actual.name}`;\n    } else if (typeof actual === 'object') {\n      if (actual.constructor && actual.constructor.name) {\n        msg += `. Received an instance of ${actual.constructor.name}`;\n      } else {\n        const inspected = lazyInternalUtilInspect()\n          .inspect(actual\x2C { depth: -1 });\n        msg += `. Received ${inspected}`;\n      }\n    } else {\n      let inspected = lazyInternalUtilInspect()\n        .inspect(actual\x2C { colors: false });\n      if (inspected.length > 25)\n        inspected = `${StringPrototypeSlice(inspected\x2C 0\x2C 25)}...`;\n      msg += `. Received type ${typeof actual} (${inspected})`;\n    }\n    return msg;\n  }\x2C TypeError);\nE('ERR_INVALID_ARG_VALUE'\x2C (name\x2C value\x2C reason = 'is invalid') => {\n  let inspected = lazyInternalUtilInspect().inspect(value);\n  if (inspected.length > 128) {\n    inspected = `${StringPrototypeSlice(inspected\x2C 0\x2C 128)}...`;\n  }\n  const type = StringPrototypeIncludes(name\x2C '.') ? 'property' : 'argument';\n  return `The ${type} '${name}' ${reason}. Received ${inspected}`;\n}\x2C TypeError\x2C RangeError);\nE('ERR_INVALID_ASYNC_ID'\x2C 'Invalid %s value: %s'\x2C RangeError);\nE('ERR_INVALID_BUFFER_SIZE'\x2C\n  'Buffer size must be a multiple of %s'\x2C RangeError);\nE('ERR_INVALID_CALLBACK'\x2C\n  'Callback must be a function. Received %O'\x2C TypeError);\nE('ERR_INVALID_CHAR'\x2C\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (name\x2C field = undefined) => {\n    let msg = `Invalid character in ${name}`;\n    if (field !== undefined) {\n      msg += ` ["${field}"]`;\n    }\n    return msg;\n  }\x2C TypeError);\nE('ERR_INVALID_CURSOR_POS'\x2C\n  'Cannot set cursor row without setting its column'\x2C TypeError);\nE('ERR_INVALID_FD'\x2C\n  '"fd" must be a positive integer: %s'\x2C RangeError);\nE('ERR_INVALID_FD_TYPE'\x2C 'Unsupported fd type: %s'\x2C TypeError);\nE('ERR_INVALID_FILE_URL_HOST'\x2C\n  'File URL host must be "localhost" or empty on %s'\x2C TypeError);\nE('ERR_INVALID_FILE_URL_PATH'\x2C 'File URL path %s'\x2C TypeError);\nE('ERR_INVALID_HANDLE_TYPE'\x2C 'This handle type cannot be sent'\x2C TypeError);\nE('ERR_INVALID_HTTP_TOKEN'\x2C '%s must be a valid HTTP token ["%s"]'\x2C TypeError);\nE('ERR_INVALID_IP_ADDRESS'\x2C 'Invalid IP address: %s'\x2C TypeError);\nE('ERR_INVALID_MODULE_SPECIFIER'\x2C (request\x2C reason\x2C base = undefined) => {\n  return `Invalid module "${request}" ${reason}${base ?\n    ` imported from ${base}` : ''}`;\n}\x2C TypeError);\nE('ERR_INVALID_PACKAGE_CONFIG'\x2C (path\x2C base\x2C message) => {\n  return `Invalid package config ${path}${base ? ` while importing ${base}` :\n    ''}${message ? `. ${message}` : ''}`;\n}\x2C Error);\nE('ERR_INVALID_PACKAGE_TARGET'\x2C\n  (pkgPath\x2C key\x2C target\x2C isImport = false\x2C base = undefined) => {\n    const relError = typeof target === 'string' && !isImport &&\n      target.length && !StringPrototypeStartsWith(target\x2C './');\n    if (key === '.') {\n      assert(isImport === false);\n      return `Invalid "exports" main target ${JSONStringify(target)} defined ` +\n        `in the package config ${pkgPath}package.json${base ?\n          ` imported from ${base}` : ''}${relError ?\n          '; targets must start with "./"' : ''}`;\n    }\n    return `Invalid "${isImport ? 'imports' : 'exports'}" target ${\n      JSONStringify(target)} defined for '${key}' in the package config ${\n      pkgPath}package.json${base ? ` imported from ${base}` : ''}${relError ?\n      '; targets must start with "./"' : ''}`;\n  }\x2C Error);\nE('ERR_INVALID_PROTOCOL'\x2C\n  'Protocol "%s" not supported. Expected "%s"'\x2C\n  TypeError);\nE('ERR_INVALID_REPL_EVAL_CONFIG'\x2C\n  'Cannot specify both "breakEvalOnSigint" and "eval" for REPL'\x2C TypeError);\nE('ERR_INVALID_REPL_INPUT'\x2C '%s'\x2C TypeError);\nE('ERR_INVALID_RETURN_PROPERTY'\x2C (input\x2C name\x2C prop\x2C value) => {\n  return `Expected a valid ${input} to be returned for the "${prop}" from the` +\n         ` "${name}" function but got ${value}.`;\n}\x2C TypeError);\nE('ERR_INVALID_RETURN_PROPERTY_VALUE'\x2C (input\x2C name\x2C prop\x2C value) => {\n  let type;\n  if (value && value.constructor && value.constructor.name) {\n    type = `instance of ${value.constructor.name}`;\n  } else {\n    type = `type ${typeof value}`;\n  }\n  return `Expected ${input} to be returned for the "${prop}" from the` +\n         ` "${name}" function but got ${type}.`;\n}\x2C TypeError);\nE('ERR_INVALID_RETURN_VALUE'\x2C (input\x2C name\x2C value) => {\n  let type;\n  if (value && value.constructor && value.constructor.name) {\n    type = `instance of ${value.constructor.name}`;\n  } else {\n    type = `type ${typeof value}`;\n  }\n  return `Expected ${input} to be returned from the "${name}"` +\n         ` function but got ${type}.`;\n}\x2C TypeError\x2C RangeError);\nE('ERR_INVALID_STATE'\x2C 'Invalid state: %s'\x2C Error\x2C TypeError\x2C RangeError);\nE('ERR_INVALID_SYNC_FORK_INPUT'\x2C\n  'Asynchronous forks do not support ' +\n    'Buffer\x2C TypedArray\x2C DataView or string input: %s'\x2C\n  TypeError);\nE('ERR_INVALID_THIS'\x2C 'Value of "this" must be of type %s'\x2C TypeError);\nE('ERR_INVALID_TUPLE'\x2C '%s must be an iterable %s tuple'\x2C TypeError);\nE('ERR_INVALID_URI'\x2C 'URI malformed'\x2C URIError);\nE('ERR_INVALID_URL'\x2C function(input) {\n  this.input = input;\n  // Don't include URL in message.\n  // (See https://github.com/nodejs/node/pull/38614)\n  return 'Invalid URL';\n}\x2C TypeError);\nE('ERR_INVALID_URL_SCHEME'\x2C\n  (expected) => {\n    if (typeof expected === 'string')\n      expected = [expected];\n    assert(expected.length <= 2);\n    const res = expected.length === 2 ?\n      `one of scheme ${expected[0]} or ${expected[1]}` :\n      `of scheme ${expected[0]}`;\n    return `The URL must be ${res}`;\n  }\x2C TypeError);\nE('ERR_IPC_CHANNEL_CLOSED'\x2C 'Channel closed'\x2C Error);\nE('ERR_IPC_DISCONNECTED'\x2C 'IPC channel is already disconnected'\x2C Error);\nE('ERR_IPC_ONE_PIPE'\x2C 'Child process can have only one IPC pipe'\x2C Error);\nE('ERR_IPC_SYNC_FORK'\x2C 'IPC cannot be used with synchronous forks'\x2C Error);\nE('ERR_MANIFEST_ASSERT_INTEGRITY'\x2C\n  (moduleURL\x2C realIntegrities) => {\n    let msg = `The content of "${\n      moduleURL\n    }" does not match the expected integrity.`;\n    if (realIntegrities.size) {\n      const sri = ArrayPrototypeJoin(\n        ArrayFrom(realIntegrities.entries()\x2C\n                  ({ 0: alg\x2C 1: dgs }) => `${alg}-${dgs}`)\x2C\n        ' '\n      );\n      msg += ` Integrities found are: ${sri}`;\n    } else {\n      msg += ' The resource was not found in the policy.';\n    }\n    return msg;\n  }\x2C Error);\nE('ERR_MANIFEST_DEPENDENCY_MISSING'\x2C\n  'Manifest resource %s does not list %s as a dependency specifier for ' +\n  'conditions: %s'\x2C\n  Error);\nE('ERR_MANIFEST_INTEGRITY_MISMATCH'\x2C\n  'Manifest resource %s has multiple entries but integrity lists do not match'\x2C\n  SyntaxError);\nE('ERR_MANIFEST_INVALID_RESOURCE_FIELD'\x2C\n  'Manifest resource %s has invalid property value for %s'\x2C\n  TypeError);\nE('ERR_MANIFEST_INVALID_SPECIFIER'\x2C\n  'Manifest resource %s has invalid dependency mapping %s'\x2C\n  TypeError);\nE('ERR_MANIFEST_TDZ'\x2C 'Manifest initialization has not yet run'\x2C Error);\nE('ERR_MANIFEST_UNKNOWN_ONERROR'\x2C\n  'Manifest specified unknown error behavior "%s".'\x2C\n  SyntaxError);\nE('ERR_METHOD_NOT_IMPLEMENTED'\x2C 'The %s method is not implemented'\x2C Error);\nE('ERR_MISSING_ARGS'\x2C\n  (...args) => {\n    assert(args.length > 0\x2C 'At least one arg needs to be specified');\n    let msg = 'The ';\n    const len = args.length;\n    const wrap = (a) => `"${a}"`;\n    args = ArrayPrototypeMap(\n      args\x2C\n      (a) => (ArrayIsArray(a) ?\n        ArrayPrototypeJoin(ArrayPrototypeMap(a\x2C wrap)\x2C ' or ') :\n        wrap(a))\n    );\n    switch (len) {\n      case 1:\n        msg += `${args[0]} argument`;\n        break;\n      case 2:\n        msg += `${args[0]} and ${args[1]} arguments`;\n        break;\n      default:\n        msg += ArrayPrototypeJoin(ArrayPrototypeSlice(args\x2C 0\x2C len - 1)\x2C '\x2C ');\n        msg += `\x2C and ${args[len - 1]} arguments`;\n        break;\n    }\n    return `${msg} must be specified`;\n  }\x2C TypeError);\nE('ERR_MISSING_OPTION'\x2C '%s is required'\x2C TypeError);\nE('ERR_MODULE_NOT_FOUND'\x2C (path\x2C base\x2C type = 'package') => {\n  return `Cannot find ${type} '${path}' imported from ${base}`;\n}\x2C Error);\nE('ERR_MULTIPLE_CALLBACK'\x2C 'Callback called multiple times'\x2C Error);\nE('ERR_NAPI_CONS_FUNCTION'\x2C 'Constructor must be a function'\x2C TypeError);\nE('ERR_NAPI_INVALID_DATAVIEW_ARGS'\x2C\n  'byte_offset + byte_length should be less than or equal to the size in ' +\n    'bytes of the array passed in'\x2C\n  RangeError);\nE('ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT'\x2C\n  'start offset of %s should be a multiple of %s'\x2C RangeError);\nE('ERR_NAPI_INVALID_TYPEDARRAY_LENGTH'\x2C\n  'Invalid typed array length'\x2C RangeError);\nE('ERR_NO_CRYPTO'\x2C\n  'Node.js is not compiled with OpenSSL crypto support'\x2C Error);\nE('ERR_NO_ICU'\x2C\n  '%s is not supported on Node.js compiled without ICU'\x2C TypeError);\nE('ERR_OPERATION_FAILED'\x2C 'Operation failed: %s'\x2C Error\x2C TypeError);\nE('ERR_OUT_OF_RANGE'\x2C\n  (str\x2C range\x2C input\x2C replaceDefaultBoolean = false) => {\n    assert(range\x2C 'Missing "range" argument');\n    let msg = replaceDefaultBoolean ? str :\n      `The value of "${str}" is out of range.`;\n    let received;\n    if (NumberIsInteger(input) && MathAbs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input));\n    } else if (typeof input === 'bigint') {\n      received = String(input);\n      if (input > 2n ** 32n || input < -(2n ** 32n)) {\n        received = addNumericalSeparator(received);\n      }\n      received += 'n';\n    } else {\n      received = lazyInternalUtilInspect().inspect(input);\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg;\n  }\x2C RangeError);\nE('ERR_PACKAGE_IMPORT_NOT_DEFINED'\x2C (specifier\x2C packagePath\x2C base) => {\n  return `Package import specifier "${specifier}" is not defined${packagePath ?\n    ` in package ${packagePath}package.json` : ''} imported from ${base}`;\n}\x2C TypeError);\nE('ERR_PACKAGE_PATH_NOT_EXPORTED'\x2C (pkgPath\x2C subpath\x2C base = undefined) => {\n  if (subpath === '.')\n    return `No "exports" main defined in ${pkgPath}package.json${base ?\n      ` imported from ${base}` : ''}`;\n  return `Package subpath '${subpath}' is not defined by "exports" in ${\n    pkgPath}package.json${base ? ` imported from ${base}` : ''}`;\n}\x2C Error);\nE('ERR_PERFORMANCE_INVALID_TIMESTAMP'\x2C\n  '%d is not a valid timestamp'\x2C TypeError);\nE('ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS'\x2C '%s'\x2C TypeError);\nE('ERR_REQUIRE_ESM'\x2C\n  function(filename\x2C hasEsmSyntax\x2C parentPath = null\x2C packageJsonPath = null) {\n    hideInternalStackFrames(this);\n    let msg = `require() of ES Module ${filename}${parentPath ? ` from ${\n      parentPath}` : ''} not supported.`;\n    if (!packageJsonPath) {\n      if (StringPrototypeEndsWith(filename\x2C '.mjs'))\n        msg += `\\nInstead change the require of ${filename} to a dynamic ` +\n            'import() which is available in all CommonJS modules.';\n      return msg;\n    }\n    const path = require('path');\n    const basename = parentPath && path.basename(filename) ===\n      path.basename(parentPath) ? filename : path.basename(filename);\n    if (hasEsmSyntax) {\n      msg += `\\nInstead change the require of ${basename} in ${parentPath} to` +\n        ' a dynamic import() which is available in all CommonJS modules.';\n      return msg;\n    }\n    msg += `\\n${basename} is treated as an ES module file as it is a .js ` +\n      'file whose nearest parent package.json contains "type": "module" ' +\n      'which declares all .js files in that package scope as ES modules.' +\n      `\\nInstead rename ${basename} to end in .cjs\x2C change the requiring ` +\n      'code to use dynamic import() which is available in all CommonJS ' +\n      'modules\x2C or change "type": "module" to "type": "commonjs" in ' +\n      `${packageJsonPath} to treat all .js files as CommonJS (using .mjs for ` +\n      'all ES modules instead).\\n';\n    return msg;\n  }\x2C Error);\nE('ERR_SCRIPT_EXECUTION_INTERRUPTED'\x2C\n  'Script execution was interrupted by `SIGINT`'\x2C Error);\nE('ERR_SERVER_ALREADY_LISTEN'\x2C\n  'Listen method has been called more than once without closing.'\x2C Error);\nE('ERR_SERVER_NOT_RUNNING'\x2C 'Server is not running.'\x2C Error);\nE('ERR_SOCKET_ALREADY_BOUND'\x2C 'Socket is already bound'\x2C Error);\nE('ERR_SOCKET_BAD_BUFFER_SIZE'\x2C\n  'Buffer size must be a positive integer'\x2C TypeError);\nE('ERR_SOCKET_BAD_PORT'\x2C (name\x2C port\x2C allowZero = true) => {\n  assert(typeof allowZero === 'boolean'\x2C\n         "The 'allowZero' argument must be of type boolean.");\n  const operator = allowZero ? '>=' : '>';\n  return `${name} should be ${operator} 0 and < 65536. Received ${port}.`;\n}\x2C RangeError);\nE('ERR_SOCKET_BAD_TYPE'\x2C\n  'Bad socket type specified. Valid types are: udp4\x2C udp6'\x2C TypeError);\nE('ERR_SOCKET_BUFFER_SIZE'\x2C\n  'Could not get or set buffer size'\x2C\n  SystemError);\nE('ERR_SOCKET_CLOSED'\x2C 'Socket is closed'\x2C Error);\nE('ERR_SOCKET_DGRAM_IS_CONNECTED'\x2C 'Already connected'\x2C Error);\nE('ERR_SOCKET_DGRAM_NOT_CONNECTED'\x2C 'Not connected'\x2C Error);\nE('ERR_SOCKET_DGRAM_NOT_RUNNING'\x2C 'Not running'\x2C Error);\nE('ERR_SRI_PARSE'\x2C\n  'Subresource Integrity string %j had an unexpected %j at position %d'\x2C\n  SyntaxError);\nE('ERR_STREAM_ALREADY_FINISHED'\x2C\n  'Cannot call %s after a stream was finished'\x2C\n  Error);\nE('ERR_STREAM_CANNOT_PIPE'\x2C 'Cannot pipe\x2C not readable'\x2C Error);\nE('ERR_STREAM_DESTROYED'\x2C 'Cannot call %s after a stream was destroyed'\x2C Error);\nE('ERR_STREAM_NULL_VALUES'\x2C 'May not write null values to stream'\x2C TypeError);\nE('ERR_STREAM_PREMATURE_CLOSE'\x2C 'Premature close'\x2C Error);\nE('ERR_STREAM_PUSH_AFTER_EOF'\x2C 'stream.push() after EOF'\x2C Error);\nE('ERR_STREAM_UNSHIFT_AFTER_END_EVENT'\x2C\n  'stream.unshift() after end event'\x2C Error);\nE('ERR_STREAM_WRAP'\x2C 'Stream has StringDecoder set or is in objectMode'\x2C Error);\nE('ERR_STREAM_WRITE_AFTER_END'\x2C 'write after end'\x2C Error);\nE('ERR_SYNTHETIC'\x2C 'JavaScript Callstack'\x2C Error);\nE('ERR_SYSTEM_ERROR'\x2C 'A system error occurred'\x2C SystemError);\nE('ERR_TLS_CERT_ALTNAME_INVALID'\x2C function(reason\x2C host\x2C cert) {\n  this.reason = reason;\n  this.host = host;\n  this.cert = cert;\n  return `Hostname/IP does not match certificate's altnames: ${reason}`;\n}\x2C Error);\nE('ERR_TLS_DH_PARAM_SIZE'\x2C 'DH parameter size %s is less than 2048'\x2C Error);\nE('ERR_TLS_HANDSHAKE_TIMEOUT'\x2C 'TLS handshake timeout'\x2C Error);\nE('ERR_TLS_INVALID_CONTEXT'\x2C '%s must be a SecureContext'\x2C TypeError);\nE('ERR_TLS_INVALID_PROTOCOL_VERSION'\x2C\n  '%j is not a valid %s TLS protocol version'\x2C TypeError);\nE('ERR_TLS_INVALID_STATE'\x2C 'TLS socket connection must be securely established'\x2C\n  Error);\nE('ERR_TLS_PROTOCOL_VERSION_CONFLICT'\x2C\n  'TLS protocol version %j conflicts with secureProtocol %j'\x2C TypeError);\nE('ERR_TLS_RENEGOTIATION_DISABLED'\x2C\n  'TLS session renegotiation disabled for this socket'\x2C Error);\n\n// This should probably be a `TypeError`.\nE('ERR_TLS_REQUIRED_SERVER_NAME'\x2C\n  '"servername" is required parameter for Server.addContext'\x2C Error);\nE('ERR_TLS_SESSION_ATTACK'\x2C 'TLS session renegotiation attack detected'\x2C Error);\nE('ERR_TLS_SNI_FROM_SERVER'\x2C\n  'Cannot issue SNI from a TLS server-side socket'\x2C Error);\nE('ERR_TRACE_EVENTS_CATEGORY_REQUIRED'\x2C\n  'At least one category is required'\x2C TypeError);\nE('ERR_TRACE_EVENTS_UNAVAILABLE'\x2C 'Trace events are unavailable'\x2C Error);\n\n// This should probably be a `RangeError`.\nE('ERR_TTY_INIT_FAILED'\x2C 'TTY initialization failed'\x2C SystemError);\nE('ERR_UNAVAILABLE_DURING_EXIT'\x2C 'Cannot call function in process exit ' +\n  'handler'\x2C Error);\nE('ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET'\x2C\n  '`process.setupUncaughtExceptionCapture()` was called while a capture ' +\n    'callback was already active'\x2C\n  Error);\nE('ERR_UNESCAPED_CHARACTERS'\x2C '%s contains unescaped characters'\x2C TypeError);\nE('ERR_UNHANDLED_ERROR'\x2C\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (err = undefined) => {\n    const msg = 'Unhandled error.';\n    if (err === undefined) return msg;\n    return `${msg} (${err})`;\n  }\x2C Error);\nE('ERR_UNKNOWN_BUILTIN_MODULE'\x2C 'No such built-in module: %s'\x2C Error);\nE('ERR_UNKNOWN_CREDENTIAL'\x2C '%s identifier does not exist: %s'\x2C Error);\nE('ERR_UNKNOWN_ENCODING'\x2C 'Unknown encoding: %s'\x2C TypeError);\nE('ERR_UNKNOWN_FILE_EXTENSION'\x2C\n  'Unknown file extension "%s" for %s'\x2C\n  TypeError);\nE('ERR_UNKNOWN_MODULE_FORMAT'\x2C 'Unknown module format: %s'\x2C RangeError);\nE('ERR_UNKNOWN_SIGNAL'\x2C 'Unknown signal: %s'\x2C TypeError);\nE('ERR_UNSUPPORTED_DIR_IMPORT'\x2C "Directory import '%s' is not supported " +\n'resolving ES modules imported from %s'\x2C Error);\nE('ERR_UNSUPPORTED_ESM_URL_SCHEME'\x2C (url) => {\n  let msg = 'Only file and data URLs are supported by the default ESM loader';\n  if (isWindows && url.protocol.length === 2) {\n    msg +=\n      '. On Windows\x2C absolute paths must be valid file:// URLs';\n  }\n  msg += `. Received protocol '${url.protocol}'`;\n  return msg;\n}\x2C Error);\n\n// This should probably be a `TypeError`.\nE('ERR_VALID_PERFORMANCE_ENTRY_TYPE'\x2C\n  'At least one valid performance entry type is required'\x2C Error);\nE('ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING'\x2C\n  'A dynamic import callback was not specified.'\x2C TypeError);\nE('ERR_VM_MODULE_ALREADY_LINKED'\x2C 'Module has already been linked'\x2C Error);\nE('ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA'\x2C\n  'Cached data cannot be created for a module which has been evaluated'\x2C Error);\nE('ERR_VM_MODULE_DIFFERENT_CONTEXT'\x2C\n  'Linked modules must use the same context'\x2C Error);\nE('ERR_VM_MODULE_LINKING_ERRORED'\x2C\n  'Linking has already failed for the provided module'\x2C Error);\nE('ERR_VM_MODULE_NOT_MODULE'\x2C\n  'Provided module is not an instance of Module'\x2C Error);\nE('ERR_VM_MODULE_STATUS'\x2C 'Module status %s'\x2C Error);\nE('ERR_WASI_ALREADY_STARTED'\x2C 'WASI instance has already started'\x2C Error);\nE('ERR_WORKER_INIT_FAILED'\x2C 'Worker initialization failure: %s'\x2C Error);\nE('ERR_WORKER_INVALID_EXEC_ARGV'\x2C (errors\x2C msg = 'invalid execArgv flags') =>\n  `Initiated Worker with ${msg}: ${ArrayPrototypeJoin(errors\x2C '\x2C ')}`\x2C\n  Error);\nE('ERR_WORKER_NOT_RUNNING'\x2C 'Worker instance not running'\x2C Error);\nE('ERR_WORKER_OUT_OF_MEMORY'\x2C\n  'Worker terminated due to reaching memory limit: %s'\x2C Error);\nE('ERR_WORKER_PATH'\x2C (filename) =>\n  'The worker script or module filename must be an absolute path or a ' +\n  'relative path starting with \\'./\\' or \\'../\\'.' +\n  (StringPrototypeStartsWith(filename\x2C 'file://') ?\n    ' Wrap file:// URLs with `new URL`.' : ''\n  ) +\n  (StringPrototypeStartsWith(filename\x2C 'data:text/javascript') ?\n    ' Wrap data: URLs with `new URL`.' : ''\n  ) +\n  ` Received "${filename}"`\x2C\n  TypeError);\nE('ERR_WORKER_UNSERIALIZABLE_ERROR'\x2C\n  'Serializing an uncaught exception failed'\x2C Error);\nE('ERR_WORKER_UNSUPPORTED_OPERATION'\x2C\n  '%s is not supported in workers'\x2C TypeError);\nE('ERR_ZLIB_INITIALIZATION_FAILED'\x2C 'Initialization failed'\x2C Error);\n
code-source-info,0x24b376437e0e,11,22136,22512,C0O22150C2O22167C4O22166C11O22234C15O22240C19O22346C21O22366C23O22365C27O22395C31O22358C41O22502C45O22508,,
tick,0x7fff20385158,118422,0,0x0,3
tick,0x7fff20299f64,118447,0,0x0,3
tick,0x10c265599,118454,0,0x0,3
tick,0x10c7a9ad7,118538,0,0x0,2,0x10c825337,0x10c4a54f4,0x24b376437e19
code-creation,LazyCompile,10,118570,0x24b37643b36e,343,prepareStackTrace node:internal/errors:90:27,0x24b3c05a33e8,~
code-source-info,0x24b37643b36e,11,2163,3651,C0O2305C5O2328C10O2328C17O2356C22O2375C27O2375C33O2391C38O2410C43O2416C48O2436C53O2452C54O2479C55O2484C61O2487C66O2489C74O2510C78O2528C83O2566C86O2528C93O2612C97O2619C101O2626C102O2626C107O2656C109O2661C115O2664C120O2666C128O2691C132O2701C137O2731C140O2701C147O2762C156O2795C163O2762C168O2809C170O2633C175O2593C178O2994C185O3003C187O3001C192O3030C199O3058C202O3030C207O3114C221O3114C227O3174C229O3197C231O3193C236O3210C238O3232C239O3340C241O3355C248O3372C253O3411C265O3426C280O3442C291O3468C296O3482C301O3529C307O3536C312O3549C314O3568C315O3575C327O3608C333O3608C342O3649,,
code-creation,LazyCompile,10,118777,0x24b37643b666,70,maybeOverridePrepareStackTrace node:internal/errors:135:40,0x24b3c05a4268,~
code-source-info,0x24b37643b666,11,3693,4400,C0O3921C7O3926C18O3986C23O3992C28O3992C34O4024C35O4247C40O4275C48O4315C53O4339C58O4339C64O4371C65O4379C69O4398,,
code-creation,LazyCompile,10,118971,0x24b37643ba36,243,afterInspector node:internal/errors:752:17,0x24b3c05a4f10,~
code-source-info,0x24b37643ba36,11,22530,23918,C0O22572C5O22599C7O23081C10O23093C17O23102C22O23136C28O23136C33O23157C38O23158C43O23196C50O23214C55O23239C62O23214C70O23286C73O23196C79O23301C80O23308C86O23312C93O23325C101O23329C106O23348C108O23485C111O23485C115O23399C125O23455C130O23531C140O23565C145O23588C153O23589C161O23608C172O23640C177O23663C182O23664C194O23746C201O23763C207O23816C210O23832C215O23847C223O23816C232O23738C237O23866C240O23887C242O23908,,
code-creation,LazyCompile,10,119040,0x24b37643bcb6,30,lazyInternalUtilInspect node:internal/errors:184:33,0x24b3c05a4358,~
code-source-info,0x24b37643bcb6,11,5253,5383,C0O5260C6O5292C12O5314C19O5312C25O5354C29O5381,,
code-creation,Eval,10,119313,0x24b37643c426,5, node:internal/tty:1:1,0x24b37643c1d0,~
script-source,121,node:internal/tty,// MIT License\n\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a copy\n// of this software and associated documentation files (the "Software")\x2C to deal\n// in the Software without restriction\x2C including without limitation the rights\n// to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C distribute\x2C sublicense\x2C and/or sell\n// copies of the Software\x2C and to permit persons to whom the Software is\n// furnished to do so\x2C subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS OR\n// IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\x2C\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C DAMAGES OR OTHER\n// LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR OTHERWISE\x2C ARISING FROM\x2C\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeSome\x2C\n  RegExpPrototypeTest\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst { validateInteger } = require('internal/validators');\n\nlet OSRelease;\n\nconst COLORS_2 = 1;\nconst COLORS_16 = 4;\nconst COLORS_256 = 8;\nconst COLORS_16m = 24;\n\n// Some entries were taken from `dircolors`\n// (https://linux.die.net/man/1/dircolors). The corresponding terminals might\n// support more than 16 colors\x2C but this was not tested for.\n//\n// Copyright (C) 1996-2016 Free Software Foundation\x2C Inc. Copying and\n// distribution of this file\x2C with or without modification\x2C are permitted\n// provided the copyright notice and this notice are preserved.\nconst TERM_ENVS = {\n  'eterm': COLORS_16\x2C\n  'cons25': COLORS_16\x2C\n  'console': COLORS_16\x2C\n  'cygwin': COLORS_16\x2C\n  'dtterm': COLORS_16\x2C\n  'gnome': COLORS_16\x2C\n  'hurd': COLORS_16\x2C\n  'jfbterm': COLORS_16\x2C\n  'konsole': COLORS_16\x2C\n  'kterm': COLORS_16\x2C\n  'mlterm': COLORS_16\x2C\n  'mosh': COLORS_16m\x2C\n  'putty': COLORS_16\x2C\n  'st': COLORS_16\x2C\n  // https://github.com/da-x/rxvt-unicode/tree/v9.22-with-24bit-color\n  'rxvt-unicode-24bit': COLORS_16m\x2C\n  // https://gist.github.com/XVilka/8346728#gistcomment-2823421\n  'terminator': COLORS_16m\n};\n\nconst TERM_ENVS_REG_EXP = [\n  /ansi/\x2C\n  /color/\x2C\n  /linux/\x2C\n  /^con[0-9]*x[0-9]/\x2C\n  /^rxvt/\x2C\n  /^screen/\x2C\n  /^xterm/\x2C\n  /^vt100/\x2C\n];\n\nlet warned = false;\nfunction warnOnDeactivatedColors(env) {\n  if (warned)\n    return;\n  let name = '';\n  if (env.NODE_DISABLE_COLORS !== undefined)\n    name = 'NODE_DISABLE_COLORS';\n  if (env.NO_COLOR !== undefined) {\n    if (name !== '') {\n      name += "' and '";\n    }\n    name += 'NO_COLOR';\n  }\n\n  if (name !== '') {\n    process.emitWarning(\n      `The '${name}' env is ignored due to the 'FORCE_COLOR' env being set.`\x2C\n      'Warning'\n    );\n    warned = true;\n  }\n}\n\n// The `getColorDepth` API got inspired by multiple sources such as\n// https://github.com/chalk/supports-color\x2C\n// https://github.com/isaacs/color-support.\nfunction getColorDepth(env = process.env) {\n  // Use level 0-3 to support the same levels as `chalk` does. This is done for\n  // consistency throughout the ecosystem.\n  if (env.FORCE_COLOR !== undefined) {\n    switch (env.FORCE_COLOR) {\n      case '':\n      case '1':\n      case 'true':\n        warnOnDeactivatedColors(env);\n        return COLORS_16;\n      case '2':\n        warnOnDeactivatedColors(env);\n        return COLORS_256;\n      case '3':\n        warnOnDeactivatedColors(env);\n        return COLORS_16m;\n      default:\n        return COLORS_2;\n    }\n  }\n\n  if (env.NODE_DISABLE_COLORS !== undefined ||\n      // See https://no-color.org/\n      env.NO_COLOR !== undefined ||\n      // The "dumb" special terminal\x2C as defined by terminfo\x2C doesn't support\n      // ANSI color control codes.\n      // See https://invisible-island.net/ncurses/terminfo.ti.html#toc-_Specials\n      env.TERM === 'dumb') {\n    return COLORS_2;\n  }\n\n  if (process.platform === 'win32') {\n    // Lazy load for startup performance.\n    if (OSRelease === undefined) {\n      const { release } = require('os');\n      OSRelease = StringPrototypeSplit(release()\x2C '.');\n    }\n    // Windows 10 build 10586 is the first Windows release that supports 256\n    // colors. Windows 10 build 14931 is the first release that supports\n    // 16m/TrueColor.\n    if (+OSRelease[0] >= 10) {\n      const build = +OSRelease[2];\n      if (build >= 14931)\n        return COLORS_16m;\n      if (build >= 10586)\n        return COLORS_256;\n    }\n\n    return COLORS_16;\n  }\n\n  if (env.TMUX) {\n    return COLORS_256;\n  }\n\n  if (env.CI) {\n    if ('TRAVIS' in env || 'CIRCLECI' in env || 'APPVEYOR' in env ||\n      'GITLAB_CI' in env || env.CI_NAME === 'codeship') {\n      return COLORS_256;\n    }\n    return COLORS_2;\n  }\n\n  if ('TEAMCITY_VERSION' in env) {\n    return RegExpPrototypeTest(/^(9\\.(0*[1-9]\\d*)\\.|\\d{2\x2C}\\.)/\x2C env.TEAMCITY_VERSION) ?\n      COLORS_16 : COLORS_2;\n  }\n\n  switch (env.TERM_PROGRAM) {\n    case 'iTerm.app':\n      if (!env.TERM_PROGRAM_VERSION ||\n        RegExpPrototypeTest(/^[0-2]\\./\x2C env.TERM_PROGRAM_VERSION)\n      ) {\n        return COLORS_256;\n      }\n      return COLORS_16m;\n    case 'HyperTerm':\n    case 'MacTerm':\n      return COLORS_16m;\n    case 'Apple_Terminal':\n      return COLORS_256;\n  }\n\n  if (env.COLORTERM === 'truecolor' || env.COLORTERM === '24bit') {\n    return COLORS_16m;\n  }\n\n  if (env.TERM) {\n    if (RegExpPrototypeTest(/^xterm-256/\x2C env.TERM)) {\n      return COLORS_256;\n    }\n\n    const termEnv = StringPrototypeToLowerCase(env.TERM);\n\n    if (TERM_ENVS[termEnv]) {\n      return TERM_ENVS[termEnv];\n    }\n    if (ArrayPrototypeSome(TERM_ENVS_REG_EXP\x2C\n                           (term) => RegExpPrototypeTest(term\x2C termEnv))) {\n      return COLORS_16;\n    }\n  }\n  // Move 16 color COLORTERM below 16m and 256\n  if (env.COLORTERM) {\n    return COLORS_16;\n  }\n  return COLORS_2;\n}\n\nfunction hasColors(count\x2C env) {\n  if (env === undefined &&\n      (count === undefined || (typeof count === 'object' && count !== null))) {\n    env = count;\n    count = 16;\n  } else {\n    validateInteger(count\x2C 'count'\x2C 2);\n  }\n\n  return count <= 2 ** getColorDepth(env);\n}\n\nmodule.exports = {\n  getColorDepth\x2C\n  hasColors\n};\n
code-source-info,0x24b37643c426,121,0,6367,C0O0C4O6367,,
code-creation,Function,10,119975,0x24b37643c886,358, node:internal/tty:1:1,0x24b37643c3a0,~
code-source-info,0x24b37643c886,121,0,6367,C0O0C69O1186C75O1208C81O1231C87O1255C93O1329C99O1329C104O1309C110O1366C111O1366C113O1395C115O1395C117O1416C119O1416C121O1438C123O1438C125O1460C127O1460C129O1877C136O1890C142O1913C148O1937C154O1960C160O1983C166O2005C172O2026C178O2050C184O2074C190O2096C196O2119C202O2140C208O2163C214O2182C220O2287C226O2379C232O1877C234O2420C328O2420C330O2541C331O2541C333O6316C340O6337C346O6354C352O6331C357O6366,,
tick,0x7fff2038537c,120188,1,0x10c345dc2,3,0x10c4a5769,0x11430480a,0x114304517,0x24b37643bae2
code-creation,LazyCompile,10,120388,0x24b37643d326,63,hasColors node:internal/tty:215:19,0x24b37643c4f8,~
code-source-info,0x24b37643d326,121,6059,6314,C0O6076C18O6185C21O6202C27O6229C41O6229C46O6272C52O6293C56O6290C59O6285C62O6312,,
code-creation,LazyCompile,10,120551,0x24b37643e066,636,getColorDepth node:internal/tty:106:23,0x24b37643c4a8,~
code-source-info,0x24b37643e066,121,3180,6039,C7O3195C16O3335C22O3380C64O3453C67O3453C71O3491C75O3508C76O3533C79O3533C83O3571C87O3589C88O3614C91O3614C95O3652C99O3670C100O3694C104O3710C105O3732C111O3814C117O4044C124O4049C129O4067C133O4083C134O4091C137O4103C144O4112C149O4173C155O4230C161O4230C166O4218C171O4251C176O4284C183O4263C191O4261C197O4483C203O4497C206O4487C211O4501C216O4530C223O4540C226O4530C229O4551C233O4561C238O4579C242O4597C243O4604C247O4614C252O4632C256O4650C257O4662C261O4679C262O4695C268O4707C272O4725C273O4741C279O4751C284O4764C294O4785C304O4806C314O4834C319O4848C326O4856C331O4880C335O4898C336O4909C340O4925C341O4933C346O4956C351O4970C361O5034C366O4977C375O5060C381O5072C383O5081C384O5101C419O5154C427O5186C435O5222C440O5186C447O5262C451O5280C452O5295C456O5313C457O5362C461O5380C462O5414C466O5432C467O5448C474O5458C479O5481C486O5491C491O5510C495O5528C496O5544C509O5556C521O5598C526O5560C533O5613C539O5631C540O5659C547O5690C552O5659C556O5659C558O5702C567O5715C572O5734C581O5750C584O5760C585O5771C596O5794C604O5775C611O5895C617O5912C620O5980C626O5997C630O6014C631O6021C635O6037,,
new,MemoryChunk,0x24b334c40000,262144
code-creation,LazyCompile,10,120917,0x24b37643e51e,5,get node:internal/util/inspect:345:6,0x24b360894ef0,~
script-source,14,node:internal/util/inspect,'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypePop\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypePushApply\x2C\n  ArrayPrototypeSort\x2C\n  ArrayPrototypeUnshift\x2C\n  BigIntPrototypeValueOf\x2C\n  BooleanPrototypeValueOf\x2C\n  DatePrototypeGetTime\x2C\n  DatePrototypeToISOString\x2C\n  DatePrototypeToString\x2C\n  ErrorPrototypeToString\x2C\n  FunctionPrototypeCall\x2C\n  FunctionPrototypeToString\x2C\n  JSONStringify\x2C\n  MapPrototypeGetSize\x2C\n  MapPrototypeEntries\x2C\n  MathFloor\x2C\n  MathMax\x2C\n  MathMin\x2C\n  MathRound\x2C\n  MathSqrt\x2C\n  Number\x2C\n  NumberIsNaN\x2C\n  NumberParseFloat\x2C\n  NumberParseInt\x2C\n  NumberPrototypeValueOf\x2C\n  Object\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectGetOwnPropertySymbols\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectIs\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectPrototypePropertyIsEnumerable\x2C\n  ObjectSeal\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectOwnKeys\x2C\n  RegExp\x2C\n  RegExpPrototypeTest\x2C\n  RegExpPrototypeToString\x2C\n  SafeStringIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  SetPrototypeGetSize\x2C\n  SetPrototypeValues\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeCodePointAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeNormalize\x2C\n  StringPrototypePadEnd\x2C\n  StringPrototypePadStart\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  StringPrototypeValueOf\x2C\n  SymbolPrototypeToString\x2C\n  SymbolPrototypeValueOf\x2C\n  SymbolIterator\x2C\n  SymbolToStringTag\x2C\n  TypedArrayPrototypeGetLength\x2C\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\n  Uint8Array\x2C\n  globalThis\x2C\n  uncurryThis\x2C\n} = primordials;\n\nconst {\n  getOwnNonIndexProperties\x2C\n  getPromiseDetails\x2C\n  getProxyDetails\x2C\n  kPending\x2C\n  kRejected\x2C\n  previewEntries\x2C\n  getConstructorName: internalGetConstructorName\x2C\n  getExternalValue\x2C\n  propertyFilter: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\n  }\n} = internalBinding('util');\n\nconst {\n  customInspectSymbol\x2C\n  isError\x2C\n  join\x2C\n  removeColors\n} = require('internal/util');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\n  }\x2C\n  isStackOverflowError\n} = require('internal/errors');\n\nconst {\n  isAsyncFunction\x2C\n  isGeneratorFunction\x2C\n  isAnyArrayBuffer\x2C\n  isArrayBuffer\x2C\n  isArgumentsObject\x2C\n  isBoxedPrimitive\x2C\n  isDataView\x2C\n  isExternal\x2C\n  isMap\x2C\n  isMapIterator\x2C\n  isModuleNamespaceObject\x2C\n  isNativeError\x2C\n  isPromise\x2C\n  isSet\x2C\n  isSetIterator\x2C\n  isWeakMap\x2C\n  isWeakSet\x2C\n  isRegExp\x2C\n  isDate\x2C\n  isTypedArray\x2C\n  isStringObject\x2C\n  isNumberObject\x2C\n  isBooleanObject\x2C\n  isBigIntObject\x2C\n} = require('internal/util/types');\n\nconst assert = require('internal/assert');\n\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nlet hexSlice;\n\nconst builtInObjects = new SafeSet(\n  ArrayPrototypeFilter(\n    ObjectGetOwnPropertyNames(globalThis)\x2C\n    (e) => RegExpPrototypeTest(/^[A-Z][a-zA-Z0-9]+$/\x2C e)\n  )\n);\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nconst isUndetectableObject = (v) => typeof v === 'undefined' && v !== undefined;\n\n// These options must stay in sync with `getUserOptions`. So if any option will\n// be added or removed\x2C `getUserOptions` must also be updated accordingly.\nconst inspectDefaultOptions = ObjectSeal({\n  showHidden: false\x2C\n  depth: 2\x2C\n  colors: false\x2C\n  customInspect: true\x2C\n  showProxy: false\x2C\n  maxArrayLength: 100\x2C\n  maxStringLength: 10000\x2C\n  breakLength: 80\x2C\n  compact: 3\x2C\n  sorted: false\x2C\n  getters: false\n});\n\nconst kObjectType = 0;\nconst kArrayType = 1;\nconst kArrayExtrasType = 2;\n\n/* eslint-disable no-control-regex */\nconst strEscapeSequencesRegExp = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]/;\nconst strEscapeSequencesReplacer = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]/g;\nconst strEscapeSequencesRegExpSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]/;\nconst strEscapeSequencesReplacerSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]/g;\n/* eslint-enable no-control-regex */\n\nconst keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\nconst numberRegExp = /^(0|[1-9][0-9]*)$/;\n\nconst coreModuleRegExp = /^    at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$/;\nconst nodeModulesRegExp = /[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])/g;\n\nconst classRegExp = /^(\\s+[^(]*?)\\s*{/;\n// eslint-disable-next-line node-core/no-unescaped-regexp-dot\nconst stripCommentsRegExp = /(\\/\\/.*?\\n)|(\\/\\*(.|\\n)*?\\*\\/)/g;\n\nconst kMinLineLength = 16;\n\n// Constants to map the iterator state.\nconst kWeak = 0;\nconst kIterator = 1;\nconst kMapEntries = 2;\n\n// Escaped control characters (plus the single quote and the backslash). Use\n// empty strings to fill up unused entries.\nconst meta = [\n  '\\\\x00'\x2C '\\\\x01'\x2C '\\\\x02'\x2C '\\\\x03'\x2C '\\\\x04'\x2C '\\\\x05'\x2C '\\\\x06'\x2C '\\\\x07'\x2C // x07\n  '\\\\b'\x2C '\\\\t'\x2C '\\\\n'\x2C '\\\\x0B'\x2C '\\\\f'\x2C '\\\\r'\x2C '\\\\x0E'\x2C '\\\\x0F'\x2C           // x0F\n  '\\\\x10'\x2C '\\\\x11'\x2C '\\\\x12'\x2C '\\\\x13'\x2C '\\\\x14'\x2C '\\\\x15'\x2C '\\\\x16'\x2C '\\\\x17'\x2C // x17\n  '\\\\x18'\x2C '\\\\x19'\x2C '\\\\x1A'\x2C '\\\\x1B'\x2C '\\\\x1C'\x2C '\\\\x1D'\x2C '\\\\x1E'\x2C '\\\\x1F'\x2C // x1F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C "\\\\'"\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C      // x2F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x3F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x4F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C '\\\\\\\\'\x2C ''\x2C ''\x2C ''\x2C     // x5F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x6F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C '\\\\x7F'\x2C    // x7F\n  '\\\\x80'\x2C '\\\\x81'\x2C '\\\\x82'\x2C '\\\\x83'\x2C '\\\\x84'\x2C '\\\\x85'\x2C '\\\\x86'\x2C '\\\\x87'\x2C // x87\n  '\\\\x88'\x2C '\\\\x89'\x2C '\\\\x8A'\x2C '\\\\x8B'\x2C '\\\\x8C'\x2C '\\\\x8D'\x2C '\\\\x8E'\x2C '\\\\x8F'\x2C // x8F\n  '\\\\x90'\x2C '\\\\x91'\x2C '\\\\x92'\x2C '\\\\x93'\x2C '\\\\x94'\x2C '\\\\x95'\x2C '\\\\x96'\x2C '\\\\x97'\x2C // x97\n  '\\\\x98'\x2C '\\\\x99'\x2C '\\\\x9A'\x2C '\\\\x9B'\x2C '\\\\x9C'\x2C '\\\\x9D'\x2C '\\\\x9E'\x2C '\\\\x9F'\x2C // x9F\n];\n\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\n// License: MIT\x2C authors: @sindresorhus\x2C Qix-\x2C arjunmehta and LitoMore\n// Matches all ansi escape code sequences in a string\nconst ansiPattern = '[\\\\u001B\\\\u009B][[\\\\]()#;?]*' +\n  '(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*' +\n  '|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)' +\n  '|(?:(?:\\\\d{1\x2C4}(?:;\\\\d{0\x2C4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))';\nconst ansi = new RegExp(ansiPattern\x2C 'g');\n\nlet getStringWidth;\n\nfunction getUserOptions(ctx\x2C isCrossContext) {\n  const ret = {\n    stylize: ctx.stylize\x2C\n    showHidden: ctx.showHidden\x2C\n    depth: ctx.depth\x2C\n    colors: ctx.colors\x2C\n    customInspect: ctx.customInspect\x2C\n    showProxy: ctx.showProxy\x2C\n    maxArrayLength: ctx.maxArrayLength\x2C\n    maxStringLength: ctx.maxStringLength\x2C\n    breakLength: ctx.breakLength\x2C\n    compact: ctx.compact\x2C\n    sorted: ctx.sorted\x2C\n    getters: ctx.getters\x2C\n    ...ctx.userOptions\n  };\n\n  // Typically\x2C the target value will be an instance of `Object`. If that is\n  // *not* the case\x2C the object may come from another vm.Context\x2C and we want\n  // to avoid passing it objects from this Context in that case\x2C so we remove\n  // the prototype from the returned object itself + the `stylize()` function\x2C\n  // and remove all other non-primitives\x2C including non-primitive user options.\n  if (isCrossContext) {\n    ObjectSetPrototypeOf(ret\x2C null);\n    for (const key of ObjectKeys(ret)) {\n      if ((typeof ret[key] === 'object' || typeof ret[key] === 'function') &&\n          ret[key] !== null) {\n        delete ret[key];\n      }\n    }\n    ret.stylize = ObjectSetPrototypeOf((value\x2C flavour) => {\n      let stylized;\n      try {\n        stylized = `${ctx.stylize(value\x2C flavour)}`;\n      } catch {}\n\n      if (typeof stylized !== 'string') return value;\n      // `stylized` is a string as it should be\x2C which is safe to pass along.\n      return stylized;\n    }\x2C null);\n  }\n\n  return ret;\n}\n\n/**\n * Echos the value of any input. Tries to print the value out\n * in the best way possible given the different types.\n *\n * @param {any} value The value to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* Legacy: value\x2C showHidden\x2C depth\x2C colors */\nfunction inspect(value\x2C opts) {\n  // Default options\n  const ctx = {\n    budget: {}\x2C\n    indentationLvl: 0\x2C\n    seen: []\x2C\n    currentDepth: 0\x2C\n    stylize: stylizeNoColor\x2C\n    showHidden: inspectDefaultOptions.showHidden\x2C\n    depth: inspectDefaultOptions.depth\x2C\n    colors: inspectDefaultOptions.colors\x2C\n    customInspect: inspectDefaultOptions.customInspect\x2C\n    showProxy: inspectDefaultOptions.showProxy\x2C\n    maxArrayLength: inspectDefaultOptions.maxArrayLength\x2C\n    maxStringLength: inspectDefaultOptions.maxStringLength\x2C\n    breakLength: inspectDefaultOptions.breakLength\x2C\n    compact: inspectDefaultOptions.compact\x2C\n    sorted: inspectDefaultOptions.sorted\x2C\n    getters: inspectDefaultOptions.getters\n  };\n  if (arguments.length > 1) {\n    // Legacy...\n    if (arguments.length > 2) {\n      if (arguments[2] !== undefined) {\n        ctx.depth = arguments[2];\n      }\n      if (arguments.length > 3 && arguments[3] !== undefined) {\n        ctx.colors = arguments[3];\n      }\n    }\n    // Set user-specified options\n    if (typeof opts === 'boolean') {\n      ctx.showHidden = opts;\n    } else if (opts) {\n      const optKeys = ObjectKeys(opts);\n      for (let i = 0; i < optKeys.length; ++i) {\n        const key = optKeys[i];\n        // TODO(BridgeAR): Find a solution what to do about stylize. Either make\n        // this function public or add a new API with a similar or better\n        // functionality.\n        if (\n          ObjectPrototypeHasOwnProperty(inspectDefaultOptions\x2C key) ||\n          key === 'stylize') {\n          ctx[key] = opts[key];\n        } else if (ctx.userOptions === undefined) {\n          // This is required to pass through the actual user input.\n          ctx.userOptions = opts;\n        }\n      }\n    }\n  }\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\n  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;\n  return formatValue(ctx\x2C value\x2C 0);\n}\ninspect.custom = customInspectSymbol;\n\nObjectDefineProperty(inspect\x2C 'defaultOptions'\x2C {\n  get() {\n    return inspectDefaultOptions;\n  }\x2C\n  set(options) {\n    validateObject(options\x2C 'options');\n    return ObjectAssign(inspectDefaultOptions\x2C options);\n  }\n});\n\n// Set Graphics Rendition https://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n// Each color consists of an array with the color code as first entry and the\n// reset code as second entry.\nconst defaultFG = 39;\nconst defaultBG = 49;\ninspect.colors = ObjectAssign(ObjectCreate(null)\x2C {\n  reset: [0\x2C 0]\x2C\n  bold: [1\x2C 22]\x2C\n  dim: [2\x2C 22]\x2C // Alias: faint\n  italic: [3\x2C 23]\x2C\n  underline: [4\x2C 24]\x2C\n  blink: [5\x2C 25]\x2C\n  // Swap foreground and background colors\n  inverse: [7\x2C 27]\x2C // Alias: swapcolors\x2C swapColors\n  hidden: [8\x2C 28]\x2C // Alias: conceal\n  strikethrough: [9\x2C 29]\x2C // Alias: strikeThrough\x2C crossedout\x2C crossedOut\n  doubleunderline: [21\x2C 24]\x2C // Alias: doubleUnderline\n  black: [30\x2C defaultFG]\x2C\n  red: [31\x2C defaultFG]\x2C\n  green: [32\x2C defaultFG]\x2C\n  yellow: [33\x2C defaultFG]\x2C\n  blue: [34\x2C defaultFG]\x2C\n  magenta: [35\x2C defaultFG]\x2C\n  cyan: [36\x2C defaultFG]\x2C\n  white: [37\x2C defaultFG]\x2C\n  bgBlack: [40\x2C defaultBG]\x2C\n  bgRed: [41\x2C defaultBG]\x2C\n  bgGreen: [42\x2C defaultBG]\x2C\n  bgYellow: [43\x2C defaultBG]\x2C\n  bgBlue: [44\x2C defaultBG]\x2C\n  bgMagenta: [45\x2C defaultBG]\x2C\n  bgCyan: [46\x2C defaultBG]\x2C\n  bgWhite: [47\x2C defaultBG]\x2C\n  framed: [51\x2C 54]\x2C\n  overlined: [53\x2C 55]\x2C\n  gray: [90\x2C defaultFG]\x2C // Alias: grey\x2C blackBright\n  redBright: [91\x2C defaultFG]\x2C\n  greenBright: [92\x2C defaultFG]\x2C\n  yellowBright: [93\x2C defaultFG]\x2C\n  blueBright: [94\x2C defaultFG]\x2C\n  magentaBright: [95\x2C defaultFG]\x2C\n  cyanBright: [96\x2C defaultFG]\x2C\n  whiteBright: [97\x2C defaultFG]\x2C\n  bgGray: [100\x2C defaultBG]\x2C // Alias: bgGrey\x2C bgBlackBright\n  bgRedBright: [101\x2C defaultBG]\x2C\n  bgGreenBright: [102\x2C defaultBG]\x2C\n  bgYellowBright: [103\x2C defaultBG]\x2C\n  bgBlueBright: [104\x2C defaultBG]\x2C\n  bgMagentaBright: [105\x2C defaultBG]\x2C\n  bgCyanBright: [106\x2C defaultBG]\x2C\n  bgWhiteBright: [107\x2C defaultBG]\x2C\n});\n\nfunction defineColorAlias(target\x2C alias) {\n  ObjectDefineProperty(inspect.colors\x2C alias\x2C {\n    get() {\n      return this[target];\n    }\x2C\n    set(value) {\n      this[target] = value;\n    }\x2C\n    configurable: true\x2C\n    enumerable: false\n  });\n}\n\ndefineColorAlias('gray'\x2C 'grey');\ndefineColorAlias('gray'\x2C 'blackBright');\ndefineColorAlias('bgGray'\x2C 'bgGrey');\ndefineColorAlias('bgGray'\x2C 'bgBlackBright');\ndefineColorAlias('dim'\x2C 'faint');\ndefineColorAlias('strikethrough'\x2C 'crossedout');\ndefineColorAlias('strikethrough'\x2C 'strikeThrough');\ndefineColorAlias('strikethrough'\x2C 'crossedOut');\ndefineColorAlias('hidden'\x2C 'conceal');\ndefineColorAlias('inverse'\x2C 'swapColors');\ndefineColorAlias('inverse'\x2C 'swapcolors');\ndefineColorAlias('doubleunderline'\x2C 'doubleUnderline');\n\n// TODO(BridgeAR): Add function style support for more complex styles.\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = ObjectAssign(ObjectCreate(null)\x2C {\n  special: 'cyan'\x2C\n  number: 'yellow'\x2C\n  bigint: 'yellow'\x2C\n  boolean: 'yellow'\x2C\n  undefined: 'grey'\x2C\n  null: 'bold'\x2C\n  string: 'green'\x2C\n  symbol: 'green'\x2C\n  date: 'magenta'\x2C\n  // "name": intentionally not styling\n  // TODO(BridgeAR): Highlight regular expressions properly.\n  regexp: 'red'\x2C\n  module: 'underline'\n});\n\nfunction addQuotes(str\x2C quotes) {\n  if (quotes === -1) {\n    return `"${str}"`;\n  }\n  if (quotes === -2) {\n    return `\\`${str}\\``;\n  }\n  return `'${str}'`;\n}\n\nconst escapeFn = (str) => meta[StringPrototypeCharCodeAt(str)];\n\n// Escape control characters\x2C single quotes and the backslash.\n// This is similar to JSON stringify escaping.\nfunction strEscape(str) {\n  let escapeTest = strEscapeSequencesRegExp;\n  let escapeReplace = strEscapeSequencesReplacer;\n  let singleQuote = 39;\n\n  // Check for double quotes. If not present\x2C do not escape single quotes and\n  // instead wrap the text in double quotes. If double quotes exist\x2C check for\n  // backticks. If they do not exist\x2C use those as fallback instead of the\n  // double quotes.\n  if (StringPrototypeIncludes(str\x2C "'")) {\n    // This invalidates the charCode and therefore can not be matched for\n    // anymore.\n    if (!StringPrototypeIncludes(str\x2C '"')) {\n      singleQuote = -1;\n    } else if (!StringPrototypeIncludes(str\x2C '`') &&\n               !StringPrototypeIncludes(str\x2C '${')) {\n      singleQuote = -2;\n    }\n    if (singleQuote !== 39) {\n      escapeTest = strEscapeSequencesRegExpSingle;\n      escapeReplace = strEscapeSequencesReplacerSingle;\n    }\n  }\n\n  // Some magic numbers that worked out fine while benchmarking with v8 6.0\n  if (str.length < 5000 && !RegExpPrototypeTest(escapeTest\x2C str))\n    return addQuotes(str\x2C singleQuote);\n  if (str.length > 100) {\n    str = StringPrototypeReplace(str\x2C escapeReplace\x2C escapeFn);\n    return addQuotes(str\x2C singleQuote);\n  }\n\n  let result = '';\n  let last = 0;\n  const lastIndex = str.length;\n  for (let i = 0; i < lastIndex; i++) {\n    const point = StringPrototypeCharCodeAt(str\x2C i);\n    if (point === singleQuote ||\n        point === 92 ||\n        point < 32 ||\n        (point > 126 && point < 160)) {\n      if (last === i) {\n        result += meta[point];\n      } else {\n        result += `${StringPrototypeSlice(str\x2C last\x2C i)}${meta[point]}`;\n      }\n      last = i + 1;\n    }\n  }\n\n  if (last !== lastIndex) {\n    result += StringPrototypeSlice(str\x2C last);\n  }\n  return addQuotes(result\x2C singleQuote);\n}\n\nfunction stylizeWithColor(str\x2C styleType) {\n  const style = inspect.styles[styleType];\n  if (style !== undefined) {\n    const color = inspect.colors[style];\n    if (color !== undefined)\n      return `\\u001b[${color[0]}m${str}\\u001b[${color[1]}m`;\n  }\n  return str;\n}\n\nfunction stylizeNoColor(str) {\n  return str;\n}\n\n// Return a new empty array to push in the results of the default formatter.\nfunction getEmptyFormatArray() {\n  return [];\n}\n\nfunction isInstanceof(object\x2C proto) {\n  try {\n    return object instanceof proto;\n  } catch {\n    return false;\n  }\n}\n\nfunction getConstructorName(obj\x2C ctx\x2C recurseTimes\x2C protoProps) {\n  let firstProto;\n  const tmp = obj;\n  while (obj || isUndetectableObject(obj)) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '' &&\n        isInstanceof(tmp\x2C descriptor.value)) {\n      if (protoProps !== undefined &&\n         (firstProto !== obj ||\n         !builtInObjects.has(descriptor.value.name))) {\n        addPrototypeProperties(\n          ctx\x2C tmp\x2C firstProto || tmp\x2C recurseTimes\x2C protoProps);\n      }\n      return descriptor.value.name;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n    if (firstProto === undefined) {\n      firstProto = obj;\n    }\n  }\n\n  if (firstProto === null) {\n    return null;\n  }\n\n  const res = internalGetConstructorName(tmp);\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return `${res} <Complex prototype>`;\n  }\n\n  const protoConstr = getConstructorName(\n    firstProto\x2C ctx\x2C recurseTimes + 1\x2C protoProps);\n\n  if (protoConstr === null) {\n    return `${res} <${inspect(firstProto\x2C {\n      ...ctx\x2C\n      customInspect: false\x2C\n      depth: -1\n    })}>`;\n  }\n\n  return `${res} <${protoConstr}>`;\n}\n\n// This function has the side effect of adding prototype properties to the\n// `output` argument (which is an array). This is intended to highlight user\n// defined prototype properties.\nfunction addPrototypeProperties(ctx\x2C main\x2C obj\x2C recurseTimes\x2C output) {\n  let depth = 0;\n  let keys;\n  let keySet;\n  do {\n    if (depth !== 0 || main === obj) {\n      obj = ObjectGetPrototypeOf(obj);\n      // Stop as soon as a null prototype is encountered.\n      if (obj === null) {\n        return;\n      }\n      // Stop as soon as a built-in object type is detected.\n      const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n      if (descriptor !== undefined &&\n          typeof descriptor.value === 'function' &&\n          builtInObjects.has(descriptor.value.name)) {\n        return;\n      }\n    }\n\n    if (depth === 0) {\n      keySet = new SafeSet();\n    } else {\n      ArrayPrototypeForEach(keys\x2C (key) => keySet.add(key));\n    }\n    // Get all own property names and symbols.\n    keys = ReflectOwnKeys(obj);\n    ArrayPrototypePush(ctx.seen\x2C main);\n    for (const key of keys) {\n      // Ignore the `constructor` property and keys that exist on layers above.\n      if (key === 'constructor' ||\n          ObjectPrototypeHasOwnProperty(main\x2C key) ||\n          (depth !== 0 && keySet.has(key))) {\n        continue;\n      }\n      const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\n      if (typeof desc.value === 'function') {\n        continue;\n      }\n      const value = formatProperty(\n        ctx\x2C obj\x2C recurseTimes\x2C key\x2C kObjectType\x2C desc\x2C main);\n      if (ctx.colors) {\n        // Faint!\n        ArrayPrototypePush(output\x2C `\\u001b[2m${value}\\u001b[22m`);\n      } else {\n        ArrayPrototypePush(output\x2C value);\n      }\n    }\n    ArrayPrototypePop(ctx.seen);\n  // Limit the inspection to up to three prototype layers. Using `recurseTimes`\n  // is not a good choice here\x2C because it's as if the properties are declared\n  // on the current object from the users perspective.\n  } while (++depth !== 3);\n}\n\nfunction getPrefix(constructor\x2C tag\x2C fallback\x2C size = '') {\n  if (constructor === null) {\n    if (tag !== '' && fallback !== tag) {\n      return `[${fallback}${size}: null prototype] [${tag}] `;\n    }\n    return `[${fallback}${size}: null prototype] `;\n  }\n\n  if (tag !== '' && constructor !== tag) {\n    return `${constructor}${size} [${tag}] `;\n  }\n  return `${constructor}${size} `;\n}\n\n// Look up the keys of the object.\nfunction getKeys(value\x2C showHidden) {\n  let keys;\n  const symbols = ObjectGetOwnPropertySymbols(value);\n  if (showHidden) {\n    keys = ObjectGetOwnPropertyNames(value);\n    if (symbols.length !== 0)\n      ArrayPrototypePushApply(keys\x2C symbols);\n  } else {\n    // This might throw if `value` is a Module Namespace Object from an\n    // unevaluated module\x2C but we don't want to perform the actual type\n    // check because it's expensive.\n    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\n    // and modify this logic as needed.\n    try {\n      keys = ObjectKeys(value);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError' &&\n             isModuleNamespaceObject(value));\n      keys = ObjectGetOwnPropertyNames(value);\n    }\n    if (symbols.length !== 0) {\n      const filter = (key) => ObjectPrototypePropertyIsEnumerable(value\x2C key);\n      ArrayPrototypePushApply(keys\x2C ArrayPrototypeFilter(symbols\x2C filter));\n    }\n  }\n  return keys;\n}\n\nfunction getCtxStyle(value\x2C constructor\x2C tag) {\n  let fallback = '';\n  if (constructor === null) {\n    fallback = internalGetConstructorName(value);\n    if (fallback === tag) {\n      fallback = 'Object';\n    }\n  }\n  return getPrefix(constructor\x2C tag\x2C fallback);\n}\n\nfunction formatProxy(ctx\x2C proxy\x2C recurseTimes) {\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return ctx.stylize('Proxy [Array]'\x2C 'special');\n  }\n  recurseTimes += 1;\n  ctx.indentationLvl += 2;\n  const res = [\n    formatValue(ctx\x2C proxy[0]\x2C recurseTimes)\x2C\n    formatValue(ctx\x2C proxy[1]\x2C recurseTimes)\x2C\n  ];\n  ctx.indentationLvl -= 2;\n  return reduceToSingleString(\n    ctx\x2C res\x2C ''\x2C ['Proxy ['\x2C ']']\x2C kArrayExtrasType\x2C recurseTimes);\n}\n\n// Note: using `formatValue` directly requires the indentation level to be\n// corrected by setting `ctx.indentationLvL += diff` and then to decrease the\n// value afterwards again.\nfunction formatValue(ctx\x2C value\x2C recurseTimes\x2C typedArray) {\n  // Primitive types cannot have properties.\n  if (typeof value !== 'object' &&\n      typeof value !== 'function' &&\n      !isUndetectableObject(value)) {\n    return formatPrimitive(ctx.stylize\x2C value\x2C ctx);\n  }\n  if (value === null) {\n    return ctx.stylize('null'\x2C 'null');\n  }\n\n  // Memorize the context for custom inspection on proxies.\n  const context = value;\n  // Always check for proxies to prevent side effects and to prevent triggering\n  // any proxy handlers.\n  const proxy = getProxyDetails(value\x2C !!ctx.showProxy);\n  if (proxy !== undefined) {\n    if (ctx.showProxy) {\n      return formatProxy(ctx\x2C proxy\x2C recurseTimes);\n    }\n    value = proxy;\n  }\n\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it.\n  if (ctx.customInspect) {\n    const maybeCustom = value[customInspectSymbol];\n    if (typeof maybeCustom === 'function' &&\n        // Filter out the util module\x2C its inspect function is special.\n        maybeCustom !== inspect &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      // This makes sure the recurseTimes are reported as before while using\n      // a counter internally.\n      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;\n      const isCrossContext =\n        proxy !== undefined || !(context instanceof Object);\n      const ret = FunctionPrototypeCall(\n        maybeCustom\x2C context\x2C depth\x2C getUserOptions(ctx\x2C isCrossContext));\n      // If the custom inspection method returned `this`\x2C don't go into\n      // infinite recursion.\n      if (ret !== context) {\n        if (typeof ret !== 'string') {\n          return formatValue(ctx\x2C ret\x2C recurseTimes);\n        }\n        return ret.replace(/\\n/g\x2C `\\n${' '.repeat(ctx.indentationLvl)}`);\n      }\n    }\n  }\n\n  // Using an array here is actually better for the average case than using\n  // a Set. `seen` will only check for the depth and will never grow too large.\n  if (ctx.seen.includes(value)) {\n    let index = 1;\n    if (ctx.circular === undefined) {\n      ctx.circular = new SafeMap();\n      ctx.circular.set(value\x2C index);\n    } else {\n      index = ctx.circular.get(value);\n      if (index === undefined) {\n        index = ctx.circular.size + 1;\n        ctx.circular.set(value\x2C index);\n      }\n    }\n    return ctx.stylize(`[Circular *${index}]`\x2C 'special');\n  }\n\n  return formatRaw(ctx\x2C value\x2C recurseTimes\x2C typedArray);\n}\n\nfunction formatRaw(ctx\x2C value\x2C recurseTimes\x2C typedArray) {\n  let keys;\n  let protoProps;\n  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {\n    protoProps = [];\n  }\n\n  const constructor = getConstructorName(value\x2C ctx\x2C recurseTimes\x2C protoProps);\n  // Reset the variable to check for this later on.\n  if (protoProps !== undefined && protoProps.length === 0) {\n    protoProps = undefined;\n  }\n\n  let tag = value[SymbolToStringTag];\n  // Only list the tag in case it's non-enumerable / not an own property.\n  // Otherwise we'd print this twice.\n  if (typeof tag !== 'string' ||\n      (tag !== '' &&\n      (ctx.showHidden ?\n        ObjectPrototypeHasOwnProperty :\n        ObjectPrototypePropertyIsEnumerable)(\n        value\x2C SymbolToStringTag\n      ))) {\n    tag = '';\n  }\n  let base = '';\n  let formatter = getEmptyFormatArray;\n  let braces;\n  let noIterator = true;\n  let i = 0;\n  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n\n  let extrasType = kObjectType;\n\n  // Iterators and the rest are split to reduce checks.\n  // We have to check all values in case the constructor is set to null.\n  // Otherwise it would not possible to identify all types properly.\n  if (value[SymbolIterator] || constructor === null) {\n    noIterator = false;\n    if (ArrayIsArray(value)) {\n      // Only set the constructor for non ordinary ("Array [...]") arrays.\n      const prefix = (constructor !== 'Array' || tag !== '') ?\n        getPrefix(constructor\x2C tag\x2C 'Array'\x2C `(${value.length})`) :\n        '';\n      keys = getOwnNonIndexProperties(value\x2C filter);\n      braces = [`${prefix}[`\x2C ']'];\n      if (value.length === 0 && keys.length === 0 && protoProps === undefined)\n        return `${braces[0]}]`;\n      extrasType = kArrayExtrasType;\n      formatter = formatArray;\n    } else if (isSet(value)) {\n      const size = SetPrototypeGetSize(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Set'\x2C `(${size})`);\n      keys = getKeys(value\x2C ctx.showHidden);\n      formatter = constructor !== null ?\n        formatSet.bind(null\x2C value) :\n        formatSet.bind(null\x2C SetPrototypeValues(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`\x2C '}'];\n    } else if (isMap(value)) {\n      const size = MapPrototypeGetSize(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Map'\x2C `(${size})`);\n      keys = getKeys(value\x2C ctx.showHidden);\n      formatter = constructor !== null ?\n        formatMap.bind(null\x2C value) :\n        formatMap.bind(null\x2C MapPrototypeEntries(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`\x2C '}'];\n    } else if (isTypedArray(value)) {\n      keys = getOwnNonIndexProperties(value\x2C filter);\n      let bound = value;\n      let fallback = '';\n      if (constructor === null) {\n        fallback = TypedArrayPrototypeGetSymbolToStringTag(value);\n        // Reconstruct the array information.\n        bound = new primordials[fallback](value);\n      }\n      const size = TypedArrayPrototypeGetLength(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C fallback\x2C `(${size})`);\n      braces = [`${prefix}[`\x2C ']'];\n      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\n        return `${braces[0]}]`;\n      // Special handle the value. The original value is required below. The\n      // bound function is required to reconstruct missing information.\n      formatter = formatTypedArray.bind(null\x2C bound\x2C size);\n      extrasType = kArrayExtrasType;\n    } else if (isMapIterator(value)) {\n      keys = getKeys(value\x2C ctx.showHidden);\n      braces = getIteratorBraces('Map'\x2C tag);\n      // Add braces to the formatter parameters.\n      formatter = formatIterator.bind(null\x2C braces);\n    } else if (isSetIterator(value)) {\n      keys = getKeys(value\x2C ctx.showHidden);\n      braces = getIteratorBraces('Set'\x2C tag);\n      // Add braces to the formatter parameters.\n      formatter = formatIterator.bind(null\x2C braces);\n    } else {\n      noIterator = true;\n    }\n  }\n  if (noIterator) {\n    keys = getKeys(value\x2C ctx.showHidden);\n    braces = ['{'\x2C '}'];\n    if (constructor === 'Object') {\n      if (isArgumentsObject(value)) {\n        braces[0] = '[Arguments] {';\n      } else if (tag !== '') {\n        braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Object')}{`;\n      }\n      if (keys.length === 0 && protoProps === undefined) {\n        return `${braces[0]}}`;\n      }\n    } else if (typeof value === 'function') {\n      base = getFunctionBase(value\x2C constructor\x2C tag);\n      if (keys.length === 0 && protoProps === undefined)\n        return ctx.stylize(base\x2C 'special');\n    } else if (isRegExp(value)) {\n      // Make RegExps say that they are RegExps\n      base = RegExpPrototypeToString(\n        constructor !== null ? value : new RegExp(value)\n      );\n      const prefix = getPrefix(constructor\x2C tag\x2C 'RegExp');\n      if (prefix !== 'RegExp ')\n        base = `${prefix}${base}`;\n      if ((keys.length === 0 && protoProps === undefined) ||\n          (recurseTimes > ctx.depth && ctx.depth !== null)) {\n        return ctx.stylize(base\x2C 'regexp');\n      }\n    } else if (isDate(value)) {\n      // Make dates with properties first say the date\n      base = NumberIsNaN(DatePrototypeGetTime(value)) ?\n        DatePrototypeToString(value) :\n        DatePrototypeToISOString(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Date');\n      if (prefix !== 'Date ')\n        base = `${prefix}${base}`;\n      if (keys.length === 0 && protoProps === undefined) {\n        return ctx.stylize(base\x2C 'date');\n      }\n    } else if (isError(value)) {\n      base = formatError(value\x2C constructor\x2C tag\x2C ctx\x2C keys);\n      if (keys.length === 0 && protoProps === undefined)\n        return base;\n    } else if (isAnyArrayBuffer(value)) {\n      // Fast path for ArrayBuffer and SharedArrayBuffer.\n      // Can't do the same for DataView because it has a non-primitive\n      // .buffer property that we need to recurse for.\n      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' :\n        'SharedArrayBuffer';\n      const prefix = getPrefix(constructor\x2C tag\x2C arrayType);\n      if (typedArray === undefined) {\n        formatter = formatArrayBuffer;\n      } else if (keys.length === 0 && protoProps === undefined) {\n        return prefix +\n              `{ byteLength: ${formatNumber(ctx.stylize\x2C value.byteLength)} }`;\n      }\n      braces[0] = `${prefix}{`;\n      ArrayPrototypeUnshift(keys\x2C 'byteLength');\n    } else if (isDataView(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'DataView')}{`;\n      // .buffer goes last\x2C it's not a primitive like the others.\n      ArrayPrototypeUnshift(keys\x2C 'byteLength'\x2C 'byteOffset'\x2C 'buffer');\n    } else if (isPromise(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Promise')}{`;\n      formatter = formatPromise;\n    } else if (isWeakSet(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'WeakSet')}{`;\n      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\n    } else if (isWeakMap(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'WeakMap')}{`;\n      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\n    } else if (isModuleNamespaceObject(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Module')}{`;\n      // Special handle keys for namespace objects.\n      formatter = formatNamespaceObject.bind(null\x2C keys);\n    } else if (isBoxedPrimitive(value)) {\n      base = getBoxedBase(value\x2C ctx\x2C keys\x2C constructor\x2C tag);\n      if (keys.length === 0 && protoProps === undefined) {\n        return base;\n      }\n    } else {\n      if (keys.length === 0 && protoProps === undefined) {\n        if (isExternal(value)) {\n          const address = getExternalValue(value).toString(16);\n          return ctx.stylize(`[External: ${address}]`\x2C 'special');\n        }\n        return `${getCtxStyle(value\x2C constructor\x2C tag)}{}`;\n      }\n      braces[0] = `${getCtxStyle(value\x2C constructor\x2C tag)}{`;\n    }\n  }\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    let constructorName = getCtxStyle(value\x2C constructor\x2C tag).slice(0\x2C -1);\n    if (constructor !== null)\n      constructorName = `[${constructorName}]`;\n    return ctx.stylize(constructorName\x2C 'special');\n  }\n  recurseTimes += 1;\n\n  ctx.seen.push(value);\n  ctx.currentDepth = recurseTimes;\n  let output;\n  const indentationLvl = ctx.indentationLvl;\n  try {\n    output = formatter(ctx\x2C value\x2C recurseTimes);\n    for (i = 0; i < keys.length; i++) {\n      output.push(\n        formatProperty(ctx\x2C value\x2C recurseTimes\x2C keys[i]\x2C extrasType));\n    }\n    if (protoProps !== undefined) {\n      output.push(...protoProps);\n    }\n  } catch (err) {\n    const constructorName = getCtxStyle(value\x2C constructor\x2C tag).slice(0\x2C -1);\n    return handleMaxCallStackSize(ctx\x2C err\x2C constructorName\x2C indentationLvl);\n  }\n  if (ctx.circular !== undefined) {\n    const index = ctx.circular.get(value);\n    if (index !== undefined) {\n      const reference = ctx.stylize(`<ref *${index}>`\x2C 'special');\n      // Add reference always to the very beginning of the output.\n      if (ctx.compact !== true) {\n        base = base === '' ? reference : `${reference} ${base}`;\n      } else {\n        braces[0] = `${reference} ${braces[0]}`;\n      }\n    }\n  }\n  ctx.seen.pop();\n\n  if (ctx.sorted) {\n    const comparator = ctx.sorted === true ? undefined : ctx.sorted;\n    if (extrasType === kObjectType) {\n      output = output.sort(comparator);\n    } else if (keys.length > 1) {\n      const sorted = output.slice(output.length - keys.length).sort(comparator);\n      output.splice(output.length - keys.length\x2C keys.length\x2C ...sorted);\n    }\n  }\n\n  const res = reduceToSingleString(\n    ctx\x2C output\x2C base\x2C braces\x2C extrasType\x2C recurseTimes\x2C value);\n  const budget = ctx.budget[ctx.indentationLvl] || 0;\n  const newLength = budget + res.length;\n  ctx.budget[ctx.indentationLvl] = newLength;\n  // If any indentationLvl exceeds this limit\x2C limit further inspecting to the\n  // minimum. Otherwise the recursive algorithm might continue inspecting the\n  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\n  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\n  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\n  // This limit also makes sure that huge objects don't block the event loop\n  // significantly.\n  if (newLength > 2 ** 27) {\n    ctx.depth = -1;\n  }\n  return res;\n}\n\nfunction getIteratorBraces(type\x2C tag) {\n  if (tag !== `${type} Iterator`) {\n    if (tag !== '')\n      tag += '] [';\n    tag += `${type} Iterator`;\n  }\n  return [`[${tag}] {`\x2C '}'];\n}\n\nfunction getBoxedBase(value\x2C ctx\x2C keys\x2C constructor\x2C tag) {\n  let fn;\n  let type;\n  if (isNumberObject(value)) {\n    fn = NumberPrototypeValueOf;\n    type = 'Number';\n  } else if (isStringObject(value)) {\n    fn = StringPrototypeValueOf;\n    type = 'String';\n    // For boxed Strings\x2C we have to remove the 0-n indexed entries\x2C\n    // since they just noisy up the output and are redundant\n    // Make boxed primitive Strings look like such\n    keys.splice(0\x2C value.length);\n  } else if (isBooleanObject(value)) {\n    fn = BooleanPrototypeValueOf;\n    type = 'Boolean';\n  } else if (isBigIntObject(value)) {\n    fn = BigIntPrototypeValueOf;\n    type = 'BigInt';\n  } else {\n    fn = SymbolPrototypeValueOf;\n    type = 'Symbol';\n  }\n  let base = `[${type}`;\n  if (type !== constructor) {\n    if (constructor === null) {\n      base += ' (null prototype)';\n    } else {\n      base += ` (${constructor})`;\n    }\n  }\n  base += `: ${formatPrimitive(stylizeNoColor\x2C fn(value)\x2C ctx)}]`;\n  if (tag !== '' && tag !== constructor) {\n    base += ` [${tag}]`;\n  }\n  if (keys.length !== 0 || ctx.stylize === stylizeNoColor)\n    return base;\n  return ctx.stylize(base\x2C StringPrototypeToLowerCase(type));\n}\n\nfunction getClassBase(value\x2C constructor\x2C tag) {\n  const hasName = ObjectPrototypeHasOwnProperty(value\x2C 'name');\n  const name = (hasName && value.name) || '(anonymous)';\n  let base = `class ${name}`;\n  if (constructor !== 'Function' && constructor !== null) {\n    base += ` [${constructor}]`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  if (constructor !== null) {\n    const superName = ObjectGetPrototypeOf(value).name;\n    if (superName) {\n      base += ` extends ${superName}`;\n    }\n  } else {\n    base += ' extends [null prototype]';\n  }\n  return `[${base}]`;\n}\n\nfunction getFunctionBase(value\x2C constructor\x2C tag) {\n  const stringified = FunctionPrototypeToString(value);\n  if (stringified.slice(0\x2C 5) === 'class' && stringified.endsWith('}')) {\n    const slice = stringified.slice(5\x2C -1);\n    const bracketIndex = slice.indexOf('{');\n    if (bracketIndex !== -1 &&\n        (!slice.slice(0\x2C bracketIndex).includes('(') ||\n          // Slow path to guarantee that it's indeed a class.\n          classRegExp.test(slice.replace(stripCommentsRegExp)))) {\n      return getClassBase(value\x2C constructor\x2C tag);\n    }\n  }\n  let type = 'Function';\n  if (isGeneratorFunction(value)) {\n    type = `Generator${type}`;\n  }\n  if (isAsyncFunction(value)) {\n    type = `Async${type}`;\n  }\n  let base = `[${type}`;\n  if (constructor === null) {\n    base += ' (null prototype)';\n  }\n  if (value.name === '') {\n    base += ' (anonymous)';\n  } else {\n    base += `: ${value.name}`;\n  }\n  base += ']';\n  if (constructor !== type && constructor !== null) {\n    base += ` ${constructor}`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  return base;\n}\n\nfunction formatError(err\x2C constructor\x2C tag\x2C ctx\x2C keys) {\n  const name = err.name != null ? String(err.name) : 'Error';\n  let len = name.length;\n  let stack = err.stack ? String(err.stack) : ErrorPrototypeToString(err);\n\n  // Do not "duplicate" error properties that are already included in the output\n  // otherwise.\n  if (!ctx.showHidden && keys.length !== 0) {\n    for (const name of ['name'\x2C 'message'\x2C 'stack']) {\n      const index = keys.indexOf(name);\n      // Only hide the property in case it's part of the original stack\n      if (index !== -1 && stack.includes(err[name])) {\n        keys.splice(index\x2C 1);\n      }\n    }\n  }\n\n  // A stack trace may contain arbitrary data. Only manipulate the output\n  // for "regular errors" (errors that "look normal") for now.\n  if (constructor === null ||\n      (name.endsWith('Error') &&\n      stack.startsWith(name) &&\n      (stack.length === len || stack[len] === ':' || stack[len] === '\\n'))) {\n    let fallback = 'Error';\n    if (constructor === null) {\n      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\\]()-]+)(?::|\\n {4}at)/) ||\n        stack.match(/^([a-z_A-Z0-9-]*Error)$/);\n      fallback = (start && start[1]) || '';\n      len = fallback.length;\n      fallback = fallback || 'Error';\n    }\n    const prefix = getPrefix(constructor\x2C tag\x2C fallback).slice(0\x2C -1);\n    if (name !== prefix) {\n      if (prefix.includes(name)) {\n        if (len === 0) {\n          stack = `${prefix}: ${stack}`;\n        } else {\n          stack = `${prefix}${stack.slice(len)}`;\n        }\n      } else {\n        stack = `${prefix} [${name}]${stack.slice(len)}`;\n      }\n    }\n  }\n  // Ignore the error message if it's contained in the stack.\n  let pos = (err.message && stack.indexOf(err.message)) || -1;\n  if (pos !== -1)\n    pos += err.message.length;\n  // Wrap the error in brackets in case it has no stack trace.\n  const stackStart = stack.indexOf('\\n    at'\x2C pos);\n  if (stackStart === -1) {\n    stack = `[${stack}]`;\n  } else if (ctx.colors) {\n    // Highlight userland code and node modules.\n    let newStack = stack.slice(0\x2C stackStart);\n    const lines = stack.slice(stackStart + 1).split('\\n');\n    for (const line of lines) {\n      const core = line.match(coreModuleRegExp);\n      if (core !== null && NativeModule.exists(core[1])) {\n        newStack += `\\n${ctx.stylize(line\x2C 'undefined')}`;\n      } else {\n        // This adds underscores to all node_modules to quickly identify them.\n        let nodeModule;\n        newStack += '\\n';\n        let pos = 0;\n        while (nodeModule = nodeModulesRegExp.exec(line)) {\n          // '/node_modules/'.length === 14\n          newStack += line.slice(pos\x2C nodeModule.index + 14);\n          newStack += ctx.stylize(nodeModule[1]\x2C 'module');\n          pos = nodeModule.index + nodeModule[0].length;\n        }\n        newStack += pos === 0 ? line : line.slice(pos);\n      }\n    }\n    stack = newStack;\n  }\n  // The message and the stack have to be indented as well!\n  if (ctx.indentationLvl !== 0) {\n    const indentation = ' '.repeat(ctx.indentationLvl);\n    stack = stack.replace(/\\n/g\x2C `\\n${indentation}`);\n  }\n  return stack;\n}\n\nfunction groupArrayElements(ctx\x2C output\x2C value) {\n  let totalLength = 0;\n  let maxLength = 0;\n  let i = 0;\n  let outputLength = output.length;\n  if (ctx.maxArrayLength < output.length) {\n    // This makes sure the "... n more items" part is not taken into account.\n    outputLength--;\n  }\n  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.\n  const dataLen = new Array(outputLength);\n  // Calculate the total length of all output entries and the individual max\n  // entries length of all output entries. We have to remove colors first\x2C\n  // otherwise the length would not be calculated properly.\n  for (; i < outputLength; i++) {\n    const len = getStringWidth(output[i]\x2C ctx.colors);\n    dataLen[i] = len;\n    totalLength += len + separatorSpace;\n    if (maxLength < len)\n      maxLength = len;\n  }\n  // Add two to `maxLength` as we add a single whitespace character plus a comma\n  // in-between two entries.\n  const actualMax = maxLength + separatorSpace;\n  // Check if at least three entries fit next to each other and prevent grouping\n  // of arrays that contains entries of very different length (i.e.\x2C if a single\n  // entry is longer than 1/5 of all other entries combined). Otherwise the\n  // space in-between small entries would be enormous.\n  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength &&\n      (totalLength / actualMax > 5 || maxLength <= 6)) {\n\n    const approxCharHeights = 2.5;\n    const averageBias = MathSqrt(actualMax - totalLength / output.length);\n    const biasedMax = MathMax(actualMax - 3 - averageBias\x2C 1);\n    // Dynamically check how many columns seem possible.\n    const columns = MathMin(\n      // Ideally a square should be drawn. We expect a character to be about 2.5\n      // times as high as wide. This is the area formula to calculate a square\n      // which contains n rectangles of size `actualMax * approxCharHeights`.\n      // Divide that by `actualMax` to receive the correct number of columns.\n      // The added bias increases the columns for short entries.\n      MathRound(\n        MathSqrt(\n          approxCharHeights * biasedMax * outputLength\n        ) / biasedMax\n      )\x2C\n      // Do not exceed the breakLength.\n      MathFloor((ctx.breakLength - ctx.indentationLvl) / actualMax)\x2C\n      // Limit array grouping for small `compact` modes as the user requested\n      // minimal grouping.\n      ctx.compact * 4\x2C\n      // Limit the columns to a maximum of fifteen.\n      15\n    );\n    // Return with the original output if no grouping should happen.\n    if (columns <= 1) {\n      return output;\n    }\n    const tmp = [];\n    const maxLineLength = [];\n    for (let i = 0; i < columns; i++) {\n      let lineMaxLength = 0;\n      for (let j = i; j < output.length; j += columns) {\n        if (dataLen[j] > lineMaxLength)\n          lineMaxLength = dataLen[j];\n      }\n      lineMaxLength += separatorSpace;\n      maxLineLength[i] = lineMaxLength;\n    }\n    let order = StringPrototypePadStart;\n    if (value !== undefined) {\n      for (let i = 0; i < output.length; i++) {\n        if (typeof value[i] !== 'number' && typeof value[i] !== 'bigint') {\n          order = StringPrototypePadEnd;\n          break;\n        }\n      }\n    }\n    // Each iteration creates a single line of grouped entries.\n    for (let i = 0; i < outputLength; i += columns) {\n      // The last lines may contain less entries than columns.\n      const max = MathMin(i + columns\x2C outputLength);\n      let str = '';\n      let j = i;\n      for (; j < max - 1; j++) {\n        // Calculate extra color padding in case it's active. This has to be\n        // done line by line as some lines might contain more colors than\n        // others.\n        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];\n        str += order(`${output[j]}\x2C `\x2C padding\x2C ' ');\n      }\n      if (order === StringPrototypePadStart) {\n        const padding = maxLineLength[j - i] +\n                        output[j].length -\n                        dataLen[j] -\n                        separatorSpace;\n        str += StringPrototypePadStart(output[j]\x2C padding\x2C ' ');\n      } else {\n        str += output[j];\n      }\n      ArrayPrototypePush(tmp\x2C str);\n    }\n    if (ctx.maxArrayLength < output.length) {\n      ArrayPrototypePush(tmp\x2C output[outputLength]);\n    }\n    output = tmp;\n  }\n  return output;\n}\n\nfunction handleMaxCallStackSize(ctx\x2C err\x2C constructorName\x2C indentationLvl) {\n  if (isStackOverflowError(err)) {\n    ctx.seen.pop();\n    ctx.indentationLvl = indentationLvl;\n    return ctx.stylize(\n      `[${constructorName}: Inspection interrupted ` +\n        'prematurely. Maximum call stack size exceeded.]'\x2C\n      'special'\n    );\n  }\n  /* c8 ignore next */\n  assert.fail(err.stack);\n}\n\nfunction formatNumber(fn\x2C value) {\n  // Format -0 as '-0'. Checking `value === -0` won't distinguish 0 from -0.\n  return fn(ObjectIs(value\x2C -0) ? '-0' : `${value}`\x2C 'number');\n}\n\nfunction formatBigInt(fn\x2C value) {\n  return fn(`${value}n`\x2C 'bigint');\n}\n\nfunction formatPrimitive(fn\x2C value\x2C ctx) {\n  if (typeof value === 'string') {\n    let trailer = '';\n    if (value.length > ctx.maxStringLength) {\n      const remaining = value.length - ctx.maxStringLength;\n      value = value.slice(0\x2C ctx.maxStringLength);\n      trailer = `... ${remaining} more character${remaining > 1 ? 's' : ''}`;\n    }\n    if (ctx.compact !== true &&\n        // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\n        // function.\n        value.length > kMinLineLength &&\n        value.length > ctx.breakLength - ctx.indentationLvl - 4) {\n      return value\n        .split(/(?<=\\n)/)\n        .map((line) => fn(strEscape(line)\x2C 'string'))\n        .join(` +\\n${' '.repeat(ctx.indentationLvl + 2)}`) + trailer;\n    }\n    return fn(strEscape(value)\x2C 'string') + trailer;\n  }\n  if (typeof value === 'number')\n    return formatNumber(fn\x2C value);\n  if (typeof value === 'bigint')\n    return formatBigInt(fn\x2C value);\n  if (typeof value === 'boolean')\n    return fn(`${value}`\x2C 'boolean');\n  if (typeof value === 'undefined')\n    return fn('undefined'\x2C 'undefined');\n  // es6 symbol primitive\n  return fn(SymbolPrototypeToString(value)\x2C 'symbol');\n}\n\nfunction formatNamespaceObject(keys\x2C ctx\x2C value\x2C recurseTimes) {\n  const output = new Array(keys.length);\n  for (let i = 0; i < keys.length; i++) {\n    try {\n      output[i] = formatProperty(ctx\x2C value\x2C recurseTimes\x2C keys[i]\x2C\n                                 kObjectType);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError');\n      // Use the existing functionality. This makes sure the indentation and\n      // line breaks are always correct. Otherwise it is very difficult to keep\n      // this aligned\x2C even though this is a hacky way of dealing with this.\n      const tmp = { [keys[i]]: '' };\n      output[i] = formatProperty(ctx\x2C tmp\x2C recurseTimes\x2C keys[i]\x2C kObjectType);\n      const pos = output[i].lastIndexOf(' ');\n      // We have to find the last whitespace and have to replace that value as\n      // it will be visualized as a regular string.\n      output[i] = output[i].slice(0\x2C pos + 1) +\n                  ctx.stylize('<uninitialized>'\x2C 'special');\n    }\n  }\n  // Reset the keys to an empty array. This prevents duplicated inspection.\n  keys.length = 0;\n  return output;\n}\n\n// The array is sparse and/or has extra keys\nfunction formatSpecialArray(ctx\x2C value\x2C recurseTimes\x2C maxLength\x2C output\x2C i) {\n  const keys = ObjectKeys(value);\n  let index = i;\n  for (; i < keys.length && output.length < maxLength; i++) {\n    const key = keys[i];\n    const tmp = +key;\n    // Arrays can only have up to 2^32 - 1 entries\n    if (tmp > 2 ** 32 - 2) {\n      break;\n    }\n    if (`${index}` !== key) {\n      if (!numberRegExp.test(key)) {\n        break;\n      }\n      const emptyItems = tmp - index;\n      const ending = emptyItems > 1 ? 's' : '';\n      const message = `<${emptyItems} empty item${ending}>`;\n      output.push(ctx.stylize(message\x2C 'undefined'));\n      index = tmp;\n      if (output.length === maxLength) {\n        break;\n      }\n    }\n    output.push(formatProperty(ctx\x2C value\x2C recurseTimes\x2C key\x2C kArrayType));\n    index++;\n  }\n  const remaining = value.length - index;\n  if (output.length !== maxLength) {\n    if (remaining > 0) {\n      const ending = remaining > 1 ? 's' : '';\n      const message = `<${remaining} empty item${ending}>`;\n      output.push(ctx.stylize(message\x2C 'undefined'));\n    }\n  } else if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatArrayBuffer(ctx\x2C value) {\n  let buffer;\n  try {\n    buffer = new Uint8Array(value);\n  } catch {\n    return [ctx.stylize('(detached)'\x2C 'special')];\n  }\n  if (hexSlice === undefined)\n    hexSlice = uncurryThis(require('buffer').Buffer.prototype.hexSlice);\n  let str = StringPrototypeTrim(StringPrototypeReplace(\n    hexSlice(buffer\x2C 0\x2C MathMin(ctx.maxArrayLength\x2C buffer.length))\x2C\n    /(.{2})/g\x2C '$1 '));\n  const remaining = buffer.length - ctx.maxArrayLength;\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  return [`${ctx.stylize('[Uint8Contents]'\x2C 'special')}: <${str}>`];\n}\n\nfunction formatArray(ctx\x2C value\x2C recurseTimes) {\n  const valLen = value.length;\n  const len = MathMin(MathMax(0\x2C ctx.maxArrayLength)\x2C valLen);\n\n  const remaining = valLen - len;\n  const output = [];\n  for (let i = 0; i < len; i++) {\n    // Special handle sparse arrays.\n    if (!ObjectPrototypeHasOwnProperty(value\x2C i)) {\n      return formatSpecialArray(ctx\x2C value\x2C recurseTimes\x2C len\x2C output\x2C i);\n    }\n    output.push(formatProperty(ctx\x2C value\x2C recurseTimes\x2C i\x2C kArrayType));\n  }\n  if (remaining > 0)\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  return output;\n}\n\nfunction formatTypedArray(value\x2C length\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const maxLength = MathMin(MathMax(0\x2C ctx.maxArrayLength)\x2C length);\n  const remaining = value.length - maxLength;\n  const output = new Array(maxLength);\n  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ?\n    formatNumber :\n    formatBigInt;\n  for (let i = 0; i < maxLength; ++i)\n    output[i] = elementFormatter(ctx.stylize\x2C value[i]);\n  if (remaining > 0) {\n    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\n  }\n  if (ctx.showHidden) {\n    // .buffer goes last\x2C it's not a primitive like the others.\n    // All besides `BYTES_PER_ELEMENT` are actually getters.\n    ctx.indentationLvl += 2;\n    for (const key of [\n      'BYTES_PER_ELEMENT'\x2C\n      'length'\x2C\n      'byteLength'\x2C\n      'byteOffset'\x2C\n      'buffer'\x2C\n    ]) {\n      const str = formatValue(ctx\x2C value[key]\x2C recurseTimes\x2C true);\n      ArrayPrototypePush(output\x2C `[${key}]: ${str}`);\n    }\n    ctx.indentationLvl -= 2;\n  }\n  return output;\n}\n\nfunction formatSet(value\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const v of value) {\n    ArrayPrototypePush(output\x2C formatValue(ctx\x2C v\x2C recurseTimes));\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatMap(value\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const { 0: k\x2C 1: v } of value) {\n    output.push(\n      `${formatValue(ctx\x2C k\x2C recurseTimes)} => ${formatValue(ctx\x2C v\x2C recurseTimes)}`\n    );\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength\x2C 0);\n  const maxLength = MathMin(maxArrayLength\x2C entries.length);\n  const output = new Array(maxLength);\n  ctx.indentationLvl += 2;\n  for (let i = 0; i < maxLength; i++) {\n    output[i] = formatValue(ctx\x2C entries[i]\x2C recurseTimes);\n  }\n  ctx.indentationLvl -= 2;\n  if (state === kWeak && !ctx.sorted) {\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist\x2C we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    ArrayPrototypeSort(output);\n  }\n  const remaining = entries.length - maxLength;\n  if (remaining > 0) {\n    ArrayPrototypePush(output\x2C\n                       `... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength\x2C 0);\n  // Entries exist as [key1\x2C val1\x2C key2\x2C val2\x2C ...]\n  const len = entries.length / 2;\n  const remaining = len - maxArrayLength;\n  const maxLength = MathMin(maxArrayLength\x2C len);\n  let output = new Array(maxLength);\n  let i = 0;\n  ctx.indentationLvl += 2;\n  if (state === kWeak) {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      output[i] =\n        `${formatValue(ctx\x2C entries[pos]\x2C recurseTimes)} => ${formatValue(ctx\x2C entries[pos + 1]\x2C recurseTimes)}`;\n    }\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist\x2C we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    if (!ctx.sorted)\n      output = output.sort();\n  } else {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      const res = [\n        formatValue(ctx\x2C entries[pos]\x2C recurseTimes)\x2C\n        formatValue(ctx\x2C entries[pos + 1]\x2C recurseTimes)\x2C\n      ];\n      output[i] = reduceToSingleString(\n        ctx\x2C res\x2C ''\x2C ['['\x2C ']']\x2C kArrayExtrasType\x2C recurseTimes);\n    }\n  }\n  ctx.indentationLvl -= 2;\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatWeakCollection(ctx) {\n  return [ctx.stylize('<items unknown>'\x2C 'special')];\n}\n\nfunction formatWeakSet(ctx\x2C value\x2C recurseTimes) {\n  const entries = previewEntries(value);\n  return formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C kWeak);\n}\n\nfunction formatWeakMap(ctx\x2C value\x2C recurseTimes) {\n  const entries = previewEntries(value);\n  return formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C kWeak);\n}\n\nfunction formatIterator(braces\x2C ctx\x2C value\x2C recurseTimes) {\n  const { 0: entries\x2C 1: isKeyValue } = previewEntries(value\x2C true);\n  if (isKeyValue) {\n    // Mark entry iterators as such.\n    braces[0] = braces[0].replace(/ Iterator] {$/\x2C ' Entries] {');\n    return formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C kMapEntries);\n  }\n\n  return formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C kIterator);\n}\n\nfunction formatPromise(ctx\x2C value\x2C recurseTimes) {\n  let output;\n  const { 0: state\x2C 1: result } = getPromiseDetails(value);\n  if (state === kPending) {\n    output = [ctx.stylize('<pending>'\x2C 'special')];\n  } else {\n    ctx.indentationLvl += 2;\n    const str = formatValue(ctx\x2C result\x2C recurseTimes);\n    ctx.indentationLvl -= 2;\n    output = [\n      state === kRejected ?\n        `${ctx.stylize('<rejected>'\x2C 'special')} ${str}` :\n        str\x2C\n    ];\n  }\n  return output;\n}\n\nfunction formatProperty(ctx\x2C value\x2C recurseTimes\x2C key\x2C type\x2C desc\x2C\n                        original = value) {\n  let name\x2C str;\n  let extra = ' ';\n  desc = desc || ObjectGetOwnPropertyDescriptor(value\x2C key) ||\n    { value: value[key]\x2C enumerable: true };\n  if (desc.value !== undefined) {\n    const diff = (ctx.compact !== true || type !== kObjectType) ? 2 : 3;\n    ctx.indentationLvl += diff;\n    str = formatValue(ctx\x2C desc.value\x2C recurseTimes);\n    if (diff === 3 && ctx.breakLength < getStringWidth(str\x2C ctx.colors)) {\n      extra = `\\n${' '.repeat(ctx.indentationLvl)}`;\n    }\n    ctx.indentationLvl -= diff;\n  } else if (desc.get !== undefined) {\n    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';\n    const s = ctx.stylize;\n    const sp = 'special';\n    if (ctx.getters && (ctx.getters === true ||\n          (ctx.getters === 'get' && desc.set === undefined) ||\n          (ctx.getters === 'set' && desc.set !== undefined))) {\n      try {\n        const tmp = FunctionPrototypeCall(desc.get\x2C original);\n        ctx.indentationLvl += 2;\n        if (tmp === null) {\n          str = `${s(`[${label}:`\x2C sp)} ${s('null'\x2C 'null')}${s(']'\x2C sp)}`;\n        } else if (typeof tmp === 'object') {\n          str = `${s(`[${label}]`\x2C sp)} ${formatValue(ctx\x2C tmp\x2C recurseTimes)}`;\n        } else {\n          const primitive = formatPrimitive(s\x2C tmp\x2C ctx);\n          str = `${s(`[${label}:`\x2C sp)} ${primitive}${s(']'\x2C sp)}`;\n        }\n        ctx.indentationLvl -= 2;\n      } catch (err) {\n        const message = `<Inspection threw (${err.message})>`;\n        str = `${s(`[${label}:`\x2C sp)} ${message}${s(']'\x2C sp)}`;\n      }\n    } else {\n      str = ctx.stylize(`[${label}]`\x2C sp);\n    }\n  } else if (desc.set !== undefined) {\n    str = ctx.stylize('[Setter]'\x2C 'special');\n  } else {\n    str = ctx.stylize('undefined'\x2C 'undefined');\n  }\n  if (type === kArrayType) {\n    return str;\n  }\n  if (typeof key === 'symbol') {\n    const tmp = StringPrototypeReplace(\n      SymbolPrototypeToString(key)\x2C\n      strEscapeSequencesReplacer\x2C escapeFn\n    );\n    name = `[${ctx.stylize(tmp\x2C 'symbol')}]`;\n  } else if (key === '__proto__') {\n    name = "['__proto__']";\n  } else if (desc.enumerable === false) {\n    const tmp = StringPrototypeReplace(key\x2C\n                                       strEscapeSequencesReplacer\x2C escapeFn);\n    name = `[${tmp}]`;\n  } else if (RegExpPrototypeTest(keyStrRegExp\x2C key)) {\n    name = ctx.stylize(key\x2C 'name');\n  } else {\n    name = ctx.stylize(strEscape(key)\x2C 'string');\n  }\n  return `${name}:${extra}${str}`;\n}\n\nfunction isBelowBreakLength(ctx\x2C output\x2C start\x2C base) {\n  // Each entry is separated by at least a comma. Thus\x2C we start with a total\n  // length of at least `output.length`. In addition\x2C some cases have a\n  // whitespace in-between each other that is added to the total as well.\n  // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\n  // function. Check the performance overhead and make it an opt-in in case it's\n  // significant.\n  let totalLength = output.length + start;\n  if (totalLength + output.length > ctx.breakLength)\n    return false;\n  for (let i = 0; i < output.length; i++) {\n    if (ctx.colors) {\n      totalLength += removeColors(output[i]).length;\n    } else {\n      totalLength += output[i].length;\n    }\n    if (totalLength > ctx.breakLength) {\n      return false;\n    }\n  }\n  // Do not line up properties on the same line if `base` contains line breaks.\n  return base === '' || !StringPrototypeIncludes(base\x2C '\\n');\n}\n\nfunction reduceToSingleString(\n  ctx\x2C output\x2C base\x2C braces\x2C extrasType\x2C recurseTimes\x2C value) {\n  if (ctx.compact !== true) {\n    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {\n      // Memorize the original output length. In case the output is grouped\x2C\n      // prevent lining up the entries on a single line.\n      const entries = output.length;\n      // Group array elements together if the array contains at least six\n      // separate entries.\n      if (extrasType === kArrayExtrasType && entries > 6) {\n        output = groupArrayElements(ctx\x2C output\x2C value);\n      }\n      // `ctx.currentDepth` is set to the most inner depth of the currently\n      // inspected object part while `recurseTimes` is the actual current depth\n      // that is inspected.\n      //\n      // Example:\n      //\n      // const a = { first: [ 1\x2C 2\x2C 3 ]\x2C second: { inner: [ 1\x2C 2\x2C 3 ] } }\n      //\n      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max\n      // depth of 1.\n      //\n      // Consolidate all entries of the local most inner depth up to\n      // `ctx.compact`\x2C as long as the properties are smaller than\n      // `ctx.breakLength`.\n      if (ctx.currentDepth - recurseTimes < ctx.compact &&\n          entries === output.length) {\n        // Line up all entries on a single line in case the entries do not\n        // exceed `breakLength`. Add 10 as constant to start next to all other\n        // factors that may reduce `breakLength`.\n        const start = output.length + ctx.indentationLvl +\n                      braces[0].length + base.length + 10;\n        if (isBelowBreakLength(ctx\x2C output\x2C start\x2C base)) {\n          return `${base ? `${base} ` : ''}${braces[0]} ${join(output\x2C '\x2C ')}` +\n            ` ${braces[1]}`;\n        }\n      }\n    }\n    // Line up each entry on an individual line.\n    const indentation = `\\n${StringPrototypeRepeat(' '\x2C ctx.indentationLvl)}`;\n    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` +\n      `${join(output\x2C `\x2C${indentation}  `)}${indentation}${braces[1]}`;\n  }\n  // Line up all entries on a single line in case the entries do not exceed\n  // `breakLength`.\n  if (isBelowBreakLength(ctx\x2C output\x2C 0\x2C base)) {\n    return `${braces[0]}${base ? ` ${base}` : ''} ${join(output\x2C '\x2C ')} ` +\n      braces[1];\n  }\n  const indentation = StringPrototypeRepeat(' '\x2C ctx.indentationLvl);\n  // If the opening "brace" is too large\x2C like in the case of "Set {"\x2C\n  // we need to force the first item to be on the next line or the\n  // items will not line up correctly.\n  const ln = base === '' && braces[0].length === 1 ?\n    ' ' : `${base ? ` ${base}` : ''}\\n${indentation}  `;\n  // Line up each entry on an individual line.\n  return `${braces[0]}${ln}${join(output\x2C `\x2C\\n${indentation}  `)} ${braces[1]}`;\n}\n\nfunction hasBuiltInToString(value) {\n  // Prevent triggering proxy traps.\n  const getFullProxy = false;\n  const proxyTarget = getProxyDetails(value\x2C getFullProxy);\n  if (proxyTarget !== undefined) {\n    value = proxyTarget;\n  }\n\n  // Count objects that have no `toString` function as built-in.\n  if (typeof value.toString !== 'function') {\n    return true;\n  }\n\n  // The object has a own `toString` property. Thus it's not not a built-in one.\n  if (ObjectPrototypeHasOwnProperty(value\x2C 'toString')) {\n    return false;\n  }\n\n  // Find the object that has the `toString` property as own property in the\n  // prototype chain.\n  let pointer = value;\n  do {\n    pointer = ObjectGetPrototypeOf(pointer);\n  } while (!ObjectPrototypeHasOwnProperty(pointer\x2C 'toString'));\n\n  // Check closer if the object is a built-in.\n  const descriptor = ObjectGetOwnPropertyDescriptor(pointer\x2C 'constructor');\n  return descriptor !== undefined &&\n    typeof descriptor.value === 'function' &&\n    builtInObjects.has(descriptor.value.name);\n}\n\nconst firstErrorLine = (error) =>\n  StringPrototypeSplit(error.message\x2C '\\n'\x2C 1)[0];\nlet CIRCULAR_ERROR_MESSAGE;\nfunction tryStringify(arg) {\n  try {\n    return JSONStringify(arg);\n  } catch (err) {\n    // Populate the circular error message lazily\n    if (!CIRCULAR_ERROR_MESSAGE) {\n      try {\n        const a = {}; a.a = a; JSONStringify(a);\n      } catch (err) {\n        CIRCULAR_ERROR_MESSAGE = firstErrorLine(err);\n      }\n    }\n    if (err.name === 'TypeError' &&\n        firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {\n      return '[Circular]';\n    }\n    throw err;\n  }\n}\n\nfunction format(...args) {\n  return formatWithOptionsInternal(undefined\x2C args);\n}\n\nfunction formatWithOptions(inspectOptions\x2C ...args) {\n  if (typeof inspectOptions !== 'object' || inspectOptions === null) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'inspectOptions'\x2C 'object'\x2C inspectOptions);\n  }\n  return formatWithOptionsInternal(inspectOptions\x2C args);\n}\n\nfunction formatWithOptionsInternal(inspectOptions\x2C args) {\n  const first = args[0];\n  let a = 0;\n  let str = '';\n  let join = '';\n\n  if (typeof first === 'string') {\n    if (args.length === 1) {\n      return first;\n    }\n    let tempStr;\n    let lastPos = 0;\n\n    for (let i = 0; i < first.length - 1; i++) {\n      if (StringPrototypeCharCodeAt(first\x2C i) === 37) { // '%'\n        const nextChar = StringPrototypeCharCodeAt(first\x2C ++i);\n        if (a + 1 !== args.length) {\n          switch (nextChar) {\n            case 115: // 's'\n              const tempArg = args[++a];\n              if (typeof tempArg === 'number') {\n                tempStr = formatNumber(stylizeNoColor\x2C tempArg);\n              } else if (typeof tempArg === 'bigint') {\n                tempStr = `${tempArg}n`;\n              } else if (typeof tempArg !== 'object' ||\n                         tempArg === null ||\n                         !hasBuiltInToString(tempArg)) {\n                tempStr = String(tempArg);\n              } else {\n                tempStr = inspect(tempArg\x2C {\n                  ...inspectOptions\x2C\n                  compact: 3\x2C\n                  colors: false\x2C\n                  depth: 0\n                });\n              }\n              break;\n            case 106: // 'j'\n              tempStr = tryStringify(args[++a]);\n              break;\n            case 100: // 'd'\n              const tempNum = args[++a];\n              if (typeof tempNum === 'bigint') {\n                tempStr = `${tempNum}n`;\n              } else if (typeof tempNum === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumber(stylizeNoColor\x2C Number(tempNum));\n              }\n              break;\n            case 79: // 'O'\n              tempStr = inspect(args[++a]\x2C inspectOptions);\n              break;\n            case 111: // 'o'\n              tempStr = inspect(args[++a]\x2C {\n                ...inspectOptions\x2C\n                showHidden: true\x2C\n                showProxy: true\x2C\n                depth: 4\n              });\n              break;\n            case 105: // 'i'\n              const tempInteger = args[++a];\n              if (typeof tempInteger === 'bigint') {\n                tempStr = `${tempInteger}n`;\n              } else if (typeof tempInteger === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumber(stylizeNoColor\x2C\n                                       NumberParseInt(tempInteger));\n              }\n              break;\n            case 102: // 'f'\n              const tempFloat = args[++a];\n              if (typeof tempFloat === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumber(stylizeNoColor\x2C\n                                       NumberParseFloat(tempFloat));\n              }\n              break;\n            case 99: // 'c'\n              a += 1;\n              tempStr = '';\n              break;\n            case 37: // '%'\n              str += StringPrototypeSlice(first\x2C lastPos\x2C i);\n              lastPos = i + 1;\n              continue;\n            default: // Any other character is not a correct placeholder\n              continue;\n          }\n          if (lastPos !== i - 1) {\n            str += StringPrototypeSlice(first\x2C lastPos\x2C i - 1);\n          }\n          str += tempStr;\n          lastPos = i + 1;\n        } else if (nextChar === 37) {\n          str += StringPrototypeSlice(first\x2C lastPos\x2C i);\n          lastPos = i + 1;\n        }\n      }\n    }\n    if (lastPos !== 0) {\n      a++;\n      join = ' ';\n      if (lastPos < first.length) {\n        str += StringPrototypeSlice(first\x2C lastPos);\n      }\n    }\n  }\n\n  while (a < args.length) {\n    const value = args[a];\n    str += join;\n    str += typeof value !== 'string' ? inspect(value\x2C inspectOptions) : value;\n    join = ' ';\n    a++;\n  }\n  return str;\n}\n\nif (internalBinding('config').hasIntl) {\n  const icu = internalBinding('icu');\n  // icu.getStringWidth(string\x2C ambiguousAsFullWidth\x2C expandEmojiSequence)\n  // Defaults: ambiguousAsFullWidth = false; expandEmojiSequence = true;\n  // TODO(BridgeAR): Expose the options to the user. That is probably the\n  // best thing possible at the moment\x2C since it's difficult to know what\n  // the receiving end supports.\n  getStringWidth = function getStringWidth(str\x2C removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    for (let i = 0; i < str.length; i++) {\n      // Try to avoid calling into C++ by first handling the ASCII portion of\n      // the string. If it is fully ASCII\x2C we skip the C++ part.\n      const code = str.charCodeAt(i);\n      if (code >= 127) {\n        width += icu.getStringWidth(str.slice(i).normalize('NFC'));\n        break;\n      }\n      width += code >= 32 ? 1 : 0;\n    }\n    return width;\n  };\n} else {\n  /**\n   * Returns the number of columns required to display the given string.\n   */\n  getStringWidth = function getStringWidth(str\x2C removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    str = StringPrototypeNormalize(str\x2C 'NFC');\n    for (const char of new SafeStringIterator(str)) {\n      const code = StringPrototypeCodePointAt(char\x2C 0);\n      if (isFullWidthCodePoint(code)) {\n        width += 2;\n      } else if (!isZeroWidthCodePoint(code)) {\n        width++;\n      }\n    }\n\n    return width;\n  };\n\n  /**\n   * Returns true if the character represented by a given\n   * Unicode code point is full-width. Otherwise returns false.\n   */\n  const isFullWidthCodePoint = (code) => {\n    // Code points are partially derived from:\n    // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n    return code >= 0x1100 && (\n      code <= 0x115f ||  // Hangul Jamo\n      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n      (code >= 0x3250 && code <= 0x4dbf) ||\n      // CJK Unified Ideographs .. Yi Radicals\n      (code >= 0x4e00 && code <= 0xa4c6) ||\n      // Hangul Jamo Extended-A\n      (code >= 0xa960 && code <= 0xa97c) ||\n      // Hangul Syllables\n      (code >= 0xac00 && code <= 0xd7a3) ||\n      // CJK Compatibility Ideographs\n      (code >= 0xf900 && code <= 0xfaff) ||\n      // Vertical Forms\n      (code >= 0xfe10 && code <= 0xfe19) ||\n      // CJK Compatibility Forms .. Small Form Variants\n      (code >= 0xfe30 && code <= 0xfe6b) ||\n      // Halfwidth and Fullwidth Forms\n      (code >= 0xff01 && code <= 0xff60) ||\n      (code >= 0xffe0 && code <= 0xffe6) ||\n      // Kana Supplement\n      (code >= 0x1b000 && code <= 0x1b001) ||\n      // Enclosed Ideographic Supplement\n      (code >= 0x1f200 && code <= 0x1f251) ||\n      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff\n      // Emoticons 0x1f600 - 0x1f64f\n      (code >= 0x1f300 && code <= 0x1f64f) ||\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n      (code >= 0x20000 && code <= 0x3fffd)\n    );\n  };\n\n  const isZeroWidthCodePoint = (code) => {\n    return code <= 0x1F || // C0 control codes\n      (code >= 0x7F && code <= 0x9F) || // C1 control codes\n      (code >= 0x300 && code <= 0x36F) || // Combining Diacritical Marks\n      (code >= 0x200B && code <= 0x200F) || // Modifying Invisible Characters\n      // Combining Diacritical Marks for Symbols\n      (code >= 0x20D0 && code <= 0x20FF) ||\n      (code >= 0xFE00 && code <= 0xFE0F) || // Variation Selectors\n      (code >= 0xFE20 && code <= 0xFE2F) || // Combining Half Marks\n      (code >= 0xE0100 && code <= 0xE01EF); // Variation Selectors\n  };\n}\n\n/**\n * Remove all VT control characters. Use to estimate displayed string width.\n */\nfunction stripVTControlCharacters(str) {\n  validateString(str\x2C 'str');\n\n  return str.replace(ansi\x2C '');\n}\n\nmodule.exports = {\n  inspect\x2C\n  format\x2C\n  formatWithOptions\x2C\n  getStringWidth\x2C\n  inspectDefaultOptions\x2C\n  stripVTControlCharacters\n};\n
code-source-info,0x24b37643e51e,14,10110,10152,C0O10119C4O10148,,
tick,0x7fff20384d86,125828,0,0x0,3,0x10c825337,0x24b37643bb08
tick,0x7fff2029724a,125865,0,0x0,3,0x10c825337,0x24b37643bb08
tick,0x7fff20385398,125872,0,0x0,3,0x10c825337,0x24b37643bb08
tick,0x7fff203850e3,125879,0,0x0,3,0x10c825337,0x24b37643bb08
tick,0x10c65deda,126036,0,0x0,3,0x10c825337,0x24b37643bb1e
code-creation,LazyCompile,10,126060,0x24b334c4570e,382,inspect node:internal/util/inspect:286:17,0x24b360894ea0,~
code-source-info,0x24b334c4570e,14,8068,10015,C0O8068C2O8119C9O8208C15O8240C18O8262C28O8285C31O8307C41O8326C44O8348C54O8375C57O8397C67O8427C70O8449C80O8480C83O8502C93O8539C96O8561C106O8595C109O8617C119O8643C122O8665C132O8686C135O8708C145O8729C148O8751C159O8780C166O8787C171O8829C178O8836C183O8849C185O8862C190O8891C192O8912C195O8901C199O8945C206O8952C213O8968C218O8997C220O9019C223O9008C227O9076C233O9115C235O9130C241O9149C245O9183C250O9183C255O9220C257O9235C261O9225C266O9270C268O9277C272O9471C279O9516C282O9486C291O9561C296O9588C298O9603C301O9597C307O9633C313O9741C315O9757C319O9245C324O9207C327O9803C333O9811C335O9823C339O9853C345O9899C348O9897C352O9919C358O9967C361O9965C365O9979C376O9986C381O10013,,
code-creation,LazyCompile,10,126297,0x24b334c45c6e,460,formatValue node:internal/util/inspect:726:21,0x24b3608954c0,~
code-source-info,0x24b334c45c6e,14,21561,24106,C0O21649C14O21726C17O21726C23O21761C26O21788C37O21768C42O21809C43O21816C47O21853C58O21853C64O21877C65O21961C68O22089C73O22118C80O22089C86O22132C88O22171C94O22190C106O22197C111O22235C112O22246C117O22401C123O22442C125O22448C127O22447C131O22474C137O22607C142O22713C148O22734C153O22746C160O22756C165O22902C174O22930C181O22936C185O22989C188O22995C193O23033C195O23022C200O23060C208O23120C223O23060C229O23265C231O23273C236O23296C242O23337C254O23344C259O23380C260O23410C276O23434C281O23445C286O23434C296O23410C302O23464C303O23650C308O23655C313O23655C320O23690C323O23705C329O23737C331O23756C334O23752C339O23750C343O23777C348O23786C353O23786C361O23836C366O23845C371O23845C377O23863C379O23910C384O23919C388O23924C392O23941C397O23950C402O23950C408O23998C418O24020C432O23998C438O24041C439O24049C454O24056C459O24104,,
code-creation,LazyCompile,10,126755,0x24b334c46796,3322,formatRaw node:internal/util/inspect:796:19,0x24b360895510,~
code-source-info,0x24b334c46796,14,24126,34631,C0O24173C2O24185C4O24207C10O24242C14O24235C19O24255C25O24278C28O24322C44O24322C50O24434C54O24477C61O24484C66O24497C68O24538C70O24544C72O24543C76O24678C82O24720C87O24741C95O24762C101O24802C107O24855C111O24838C118O24889C121O24916C124O24938C127O24965C129O24992C131O25008C133O25032C141O25045C147O25062C150O25099C155O25313C157O25323C159O25322C168O25370C170O25394C176O25398C182O25517C184O25530C191O25549C208O25614C231O25567C242O25645C248O25652C254O25699C265O25712C280O25745C287O25752C292O25766C299O25773C308O25816C309O25832C320O25839C321O25846C326O25883C331O25919C337O25923C343O25958C349O25958C355O26007C369O26046C388O26007C395O26062C399O26088C405O26069C411O26107C419O26160C428O26160C440O26198C451O26209C455O26209C461O26198C468O26243C469O26252C474O26266C481O26273C490O26316C500O26337C501O26344C512O26357C531O26385C537O26389C543O26424C549O26424C555O26473C569O26512C588O26473C595O26528C599O26554C605O26535C611O26573C619O26626C628O26626C640O26664C651O26675C655O26675C661O26664C668O26710C669O26719C674O26733C681O26740C690O26783C700O26804C701O26811C712O26824C731O26852C737O26856C743O26885C749O26892C755O26951C758O26979C762O26989C766O27025C772O27036C778O27138C784O27161C791O27146C798O27207C804O27207C810O27265C820O27307C842O27265C849O27323C860O27336C875O27369C882O27376C887O27390C894O27397C899O27411C905O27431C906O27447C917O27454C918O27610C922O27639C937O27639C943O27670C950O27712C956O27716C962O27746C966O27772C972O27753C978O27791C986O27800C992O27886C996O27913C1005O27913C1014O27944C1020O27948C1026O27978C1030O28004C1036O27985C1042O28023C1050O28032C1056O28118C1060O28145C1069O28145C1078O28184C1080O28215C1084O28237C1088O28263C1094O28244C1100O28280C1105O28305C1107O28321C1112O28343C1118O28347C1124O28383C1129O28393C1135O28425C1137O28433C1142O28451C1159O28466C1172O28461C1176O28531C1183O28538C1192O28583C1193O28599C1204O28606C1207O28626C1213O28667C1226O28674C1232O28731C1239O28738C1248O28792C1258O28792C1264O28817C1267O28829C1273O28833C1279O28906C1295O28981C1301O28977C1308O28913C1313O29025C1327O29025C1334O29070C1336O29081C1341O29104C1348O29123C1353O29147C1360O29154C1369O29222C1373O29216C1378O29235C1384O29273C1394O29273C1400O29297C1403O29317C1409O29321C1415O29399C1423O29418C1427O29418C1433O29406C1441O29457C1445O29457C1453O29496C1457O29496C1462O29550C1476O29550C1483O29593C1485O29604C1490O29625C1497O29644C1502O29667C1509O29674C1518O29730C1528O29730C1534O29752C1537O29772C1543O29776C1549O29800C1568O29807C1574O29871C1581O29878C1590O29921C1592O29933C1595O29945C1601O29949C1607O30184C1613O30184C1627O30273C1640O30273C1647O30319C1651O30359C1656O30412C1663O30419C1672O30464C1680O30528C1686O30543C1692O30511C1708O30478C1711O30559C1712O30574C1717O30589C1725O30584C1729O30606C1739O30606C1746O30660C1752O30664C1758O30691C1775O30706C1788O30701C1792O30822C1813O30822C1820O30900C1826O30904C1832O30930C1849O30945C1862O30940C1866O30994C1871O31032C1877O31036C1883O31062C1900O31077C1913O31072C1917O31142C1932O31204C1938O31208C1944O31234C1961O31249C1974O31244C1978O31314C1993O31376C1999O31380C2005O31420C2022O31435C2035O31430C2039O31535C2043O31569C2052O31569C2061O31598C2067O31602C2073O31635C2092O31642C2098O31707C2105O31714C2117O31759C2119O31771C2122O31808C2129O31815C2141O31860C2147O31864C2157O31911C2163O31911C2173O31934C2187O31935C2199O31970C2211O31992C2234O31970C2246O32015C2247O32034C2260O32044C2281O32085C2282O32100C2298O32115C2319O32110C2327O32192C2331O32186C2339O32205C2345O32249C2358O32249C2370O32285C2387O32286C2401O32304C2405O32336C2411O32358C2430O32393C2440O32393C2452O32429C2453O32436C2463O32462C2473O32467C2483O32467C2493O32482C2495O32499C2503O32521C2505O32558C2517O32586C2526O32595C2537O32641C2539O32657C2543O32650C2551O32685C2567O32744C2587O32699C2599O32685C2609O32666C2616O32636C2619O32773C2623O32818C2639O32818C2664O32891C2679O32891C2691O32927C2708O32928C2722O32946C2741O32953C2751O33019C2752O33034C2762O33082C2772O33091C2782O33091C2794O33107C2796O33162C2808O33179C2831O33162C2845O33282C2856O33290C2864O33310C2866O33322C2880O33346C2895O33359C2905O33390C2910O33405C2924O33424C2937O33400C2945O33455C2955O33460C2965O33460C2973O33478C2983O33515C2994O33522C3005O33549C3015O33561C3017O33580C3019O33576C3027O33617C3037O33617C3050O33655C3058O33662C3066O33697C3076O33710C3086O33724C3090O33717C3098O33697C3110O33731C3120O33732C3132O33763C3142O33777C3152O33791C3156O33784C3164O33804C3176O33763C3186O33849C3211O33849C3222O33957C3232O33968C3240O33963C3250O34023C3258O34017C3265O34037C3275O34048C3287O34064C3295O34565C3301O34579C3309O34596C3311O34606C3319O34618C3321O34629,,
code-creation,LazyCompile,10,127136,0x24b334c47b36,319,getConstructorName node:internal/util/inspect:548:28,0x24b3608952e0,~
code-source-info,0x24b334c47b36,14,15972,17205,C0O16017C2O16043C7O16061C13O16064C16O16064C22O16116C30O16116C36O16172C38O16230C46O16273C51O16279C58O16284C66O16331C71O16302C78O16347C84O16400C91O16421C94O16436C99O16451C104O16457C109O16436C116O16475C127O16519C138O16475C143O16597C148O16603C152O16608C153O16620C158O16626C164O16657C168O16695C173O16050C176O16726C180O16757C181O16769C182O16789C187O16789C192O16848C196O16842C201O16861C207O16883C216O16919C217O16947C222O17001C235O16947C241O17022C243O17054C256O17103C265O17129C275O17149C280O17072C295O17162C296O17170C308O17188C318O17203,,
tick,0x7fff20318483,127333,0,0x0,3,0x10c825337,0x24b334c467c2,0x24b334c45e34,0x24b334c45886,0x24b37643bb1e
code-creation,LazyCompile,10,127359,0x24b334c47e06,13,isInstanceof node:internal/util/inspect:540:22,0x24b360895290,~
code-source-info,0x24b334c47e06,14,15846,15943,C3O15876C5O15890C8O15907C11O15924C12O15937,,
code-creation,LazyCompile,10,127538,0x24b334c4800e,223,getKeys node:internal/util/inspect:669:17,0x24b3608953d0,~
code-source-info,0x24b334c4800e,14,19667,20642,C0O19667C9O19695C11O19719C21O19719C26O19757C30O19779C40O19786C45O19836C51O19843C56O19856C63O19856C73O20216C83O20223C91O20221C101O20268C112O20275C118O20275C127O20301C134O20306C143O20343C151O20343C156O20268C160O20382C172O20389C179O20445C185O20452C190O20482C195O20546C206O20576C209O20576C215O20546C220O20628C222O20640,,
code-creation,LazyCompile,10,127605,0x24b334c48266,19,isError node:internal/util:80:17,0x24b3c05aa098,~
code-source-info,0x24b334c48266,12,1846,2080,C0O2032C5O2039C13O2072C15O2061C18O2078,,
code-creation,LazyCompile,10,127798,0x24b334c48696,1166,formatError node:internal/util/inspect:1165:21,0x24b3608956a0,~
code-source-info,0x24b334c48696,14,37724,40825,C0O37780C9O37795C13O37806C19O37795C28O37840C33O37866C41O37874C45O37885C51O37874C59O37894C63O37894C68O38032C74O38051C81O38058C86O38090C120O38082C151O38082C154O38147C160O38147C167O38240C169O38250C177O38266C185O38278C190O38266C197O38302C207O38302C213O38071C284O38478C288O38518C298O38518C305O38551C311O38551C318O38584C326O38591C333O38607C340O38613C347O38629C354O38635C359O38668C362O38681C366O38735C378O38735C385O38804C397O38804C404O38844C408O38870C416O38903C421O38917C428O38974C441O38974C448O39011C461O39012C469O39030C471O39039C476O39070C482O39070C489O39096C490O39104C495O39123C509O39145C516O39181C521O39207C527O39207C539O39254C553O39276C566O39290C572O39290C582O39401C588O39418C594O39430C600O39418C610O39449C612O39457C617O39480C623O39488C634O39586C644O39586C651O39614C653O39629C658O39643C664O39655C678O39682C684O39766C693O39766C700O39812C708O39829C713O39812C720O39833C730O39834C736O39870C764O39862C795O39862C798O39903C806O39909C810O39903C816O39934C820O39955C824O39968C832O39979C837O39968C844O39995C848O40016C858O40016C877O40152C879O40172C888O40208C890O40237C896O40257C902O40257C908O40237C910O40342C916O40364C920O40370C925O40342C938O40403C946O40421C955O40403C968O40464C975O40482C980O40486C984O40470C988O40219C991O40512C992O40528C1004O40548C1010O40548C1019O39851C1093O40578C1098O40670C1105O40685C1110O40718C1114O40722C1120O40733C1126O40722C1132O40768C1150O40788C1156O40768C1163O40810C1165O40823,,
code-creation,LazyCompile,10,127943,0x24b334c48e4e,158,getPrefix node:internal/util/inspect:654:19,0x24b360895380,~
code-source-info,0x24b334c48e4e,14,19245,19614,C20O19289C24O19321C26O19329C33O19348C38O19365C43O19376C50O19387C63O19413C73O19421C74O19432C79O19443C86O19454C96O19479C97O19487C99O19495C106O19517C111O19532C117O19556C130O19565C140O19573C141O19580C147O19604C157O19612,,
code-creation,LazyCompile,10,128104,0x24b334c48ffe,21,exists node:internal/bootstrap/loaders:236:16,0x24b3c058f600,~
code-source-info,0x24b334c48ffe,9,7275,7322,C0O7286C5O7306C10O7310C15O7310C20O7318,,
code-creation,LazyCompile,10,128160,0x24b334c49156,82,stylizeWithColor node:internal/util/inspect:521:26,0x24b3608951a0,~
code-source-info,0x24b334c49156,14,15408,15649,C0O15443C3O15451C10O15457C14O15472C16O15517C19O15525C26O15531C30O15544C32O15575C36O15597C52O15604C65O15622C78O15629C79O15636C81O15647,,
code-creation,LazyCompile,10,128197,0x24b334c4928e,6,get node:internal/util/inspect:409:8,0x24b360894f90,~
code-source-info,0x24b334c4928e,14,12107,12144,C0O12118C2O12129C5O12138,,
code-creation,RegExp,3,128279,0x114305840,2052,^    at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$
code-creation,LazyCompile,10,128331,0x24b334c493be,3,getEmptyFormatArray node:internal/util/inspect:536:29,0x24b360895240,~
code-source-info,0x24b334c493be,14,15804,15823,C0O15811C2O15821,,
tick,0x10c48af4e,128493,0,0x0,2,0x10c825337,0x24b334c471b1,0x24b334c45e34,0x24b334c45886,0x24b37643bb1e
code-creation,LazyCompile,10,128567,0x24b334c497c6,1000,formatProperty node:internal/util/inspect:1672:24,0x24b360895ce0,~
code-source-info,0x24b334c497c6,14,55679,58199,C29O55773C31O55779C33O55798C36O55805C42O55820C46O55820C61O55884C71O55922C77O55967C84O55975C91O55996C93O55992C106O56022C114O56044C117O56041C121O56054C125O56082C137O56060C143O56108C145O56117C150O56130C158O56144C162O56168C168O56144C173O56142C178O56185C186O56202C192O56213C198O56202C208O56242C216O56264C219O56261C225O56288C231O56332C244O56398C249O56422C252O56445C258O56461C265O56469C270O56496C278O56504C283O56522C289O56559C297O56567C302O56585C311O56640C317O56667C323O56640C330O56691C337O56710C341O56724C345O56754C351O56769C364O56763C387O56786C402O56806C414O56835C420O56876C426O56891C439O56885C467O56908C479O56992C492O56992C499O57032C505O57047C518O57041C535O57064C545O57076C555O57108C562O57127C581O57179C589O57205C605O57226C611O57241C624O57235C641O57258C651O57268C665O57319C677O57331C690O57319C699O57370C705O57405C719O57405C728O57462C742O57462C749O57503C751O57516C753O57512C758O57534C760O57545C761O57552C767O57599C775O57629C779O57629C787O57665C793O57693C797O57599C803O57713C807O57728C817O57728C837O57764C839O57772C844O57795C849O57837C856O57848C861O57877C869O57944C875O57972C882O57877C888O57987C894O57998C908O58015C916O58039C920O58019C927O58076C937O58076C946O58124C956O58132C966O58124C973O58165C987O58183C995O58191C999O58197,,
code-creation,LazyCompile,10,128688,0x24b334c49dc6,11,isUndetectableObject node:internal/util/inspect:156:30,0x24b360892de0,~
code-source-info,0x24b334c49dc6,14,3085,3135,C0O3117C9O3122C10O3135,,
code-creation,LazyCompile,10,128780,0x24b334c4a04e,364,formatPrimitive node:internal/util/inspect:1382:25,0x24b360895830,~
code-source-info,0x24b334c4a04e,14,45832,46991,C0O45832C9O45853C15O45904C18O45922C23O45935C27O45929C32O45984C37O45997C41O45991C45O46034C52O46047C57O46034C65O46071C70O46088C83O46125C99O46161C105O46169C110O46296C119O46305C121O46303C126O46337C131O46350C136O46368C140O46362C143O46383C146O46344C151O46418C161O46418C167O46443C177O46444C183O46497C194O46514C199O46525C203O46540C207O46514C217O46498C225O46548C228O46558C229O46569C237O46579C245O46576C253O46607C256O46617C257O46624C263O46659C271O46666C276O46690C277O46693C283O46728C291O46735C296O46759C297O46762C303O46798C308O46811C313O46805C318O46831C319O46834C325O46872C334O46879C339O46908C340O46937C347O46947C350O46947C358O46944C363O46989,,
code-creation,LazyCompile,10,128908,0x24b334c4a49e,359,strEscape node:internal/util/inspect:465:19,0x24b360895150,~
code-source-info,0x24b334c4a49e,14,13614,15381,C0O13641C5O13689C10O13737C13O13996C21O14000C28O14131C36O14136C43O14179C48O14208C56O14213C65O14266C71O14266C78O14310C81O14338C83O14354C88O14370C93O14421C98O14568C107O14575C114O14586C117O14586C124O14628C127O14635C132O14663C133O14674C140O14681C145O14694C152O14743C161O14700C168O14758C171O14765C176O14793C177O14814C180O14831C182O14858C187O14881C189O14886C191O14886C196O14924C201O14924C207O14963C209O14973C216O15006C223O15030C230O15053C239O15068C244O15084C246O15093C251O15110C253O15120C258O15124C270O15156C272O15169C284O15169C293O15206C298O15210C312O15235C314O15244C318O14900C323O14868C326O15262C328O15271C333O15292C335O15302C338O15302C350O15341C353O15348C358O15379,,
code-creation,LazyCompile,10,129002,0x24b334c4a7ce,62,addQuotes node:internal/util/inspect:451:19,0x24b3608950b0,~
code-source-info,0x24b334c4a7ce,14,13279,13419,C0O13297C2O13308C7O13322C12O13333C22O13340C23O13347C25O13358C30O13372C35O13384C45O13392C46O13399C51O13410C61O13417,,
code-creation,RegExp,3,129098,0x114306100,964,^[a-zA-Z_][a-zA-Z_0-9]*$
code-creation,LazyCompile,10,129210,0x24b334c4aa2e,575,reduceToSingleString node:internal/util/inspect:1764:30,0x24b360895d80,~
code-source-info,0x24b334c4aa2e,14,59190,61939,C0O59266C6O59274C11O59305C19O59333C26O59341C31O59512C36O59627C38O59646C40O59642C47O59674C52O59689C64O59698C71O60337C78O60350C82O60371C86O60365C91O60411C95O60400C100O60654C105O60667C109O60661C114O60712C118O60716C122O60682C126O60730C130O60723C133O60737C137O60751C152O60755C159O60813C165O60833C179O60854C195O60861C201O60861C216O60906C223O60882C226O60912C227O61010C232O61015C238O61046C243O61015C253O61069C259O61089C273O61110C283O61116C296O61143C304O61160C315O61143C324O61179C331O61199C338O61132C341O61205C342O61308C356O61312C363O61360C364O61376C371O61382C378O61393C399O61408C405O61408C423O61444C426O61430C429O61448C430O61475C438O61506C443O61475C449O61713C451O61718C457O61734C461O61738C468O61745C479O61766C486O61777C504O61793C515O61859C516O61875C523O61881C530O61886C538O61905C549O61886C567O61931C574O61937,,
code-creation,LazyCompile,10,129324,0x24b334c4ae76,134,isBelowBreakLength node:internal/util/inspect:1740:28,0x24b360895d30,~
code-source-info,0x24b334c4ae76,14,58228,59159,C0O58681C7O58688C11O58724C15O58715C19O58737C23O58731C28O58754C29O58767C30O58783C32O58797C36O58788C41O58824C47O58840C49O58855C54O58874C58O58855C63O58878C76O58906C78O58927C82O58931C93O58971C97O58965C102O58992C103O59005C104O58806C109O58770C112O59098C114O59110C121O59121C127O59121C133O59157,,
code-creation,LazyCompile,10,129391,0x24b334c4b02e,75,join node:internal/util:378:14,0x24b3c05aa8d0,~
code-source-info,0x24b334c4b02e,12,10457,10766,C0O10491C3O10508C9O10515C14O10553C18O10560C22O10582C24O10587C26O10587C31O10669C33O10682C43O10693C45O10700C52O10601C57O10569C60O10721C62O10734C72O10753C74O10764,,
tick,0x7fff203559ee,129693,0,0x0,0
